% \iffalse meta-comment
%
% File: siunitx-unit.dtx Copyright (C) 2014-2017 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    http://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{siunitx.sty}
%
% \title{^^A
%   \pkg{siunitx-unit} -- Parsing and formatting units^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%
% This submodule is dedicated to formatting physical units. The main function,
% \cs{siunitx_unit_format:nN}, takes user input specify physical units and
% converts it into a formatted token list suitable for typesetting in math
% mode. While the formatter will deal correctly with \enquote{literal} user
% input, the key strength of the module is providing a method to describe
% physical units in a \enquote{symbolic} manner. The output format of these
% symbolic units can then be controlled by a number of key--value options
% made available by the module.
%
% A small number of \LaTeXe{} math mode commands are assumed to be available
% as part of the formatted output. The \cs{mathchoice} command
% (normally the \TeX{} primitive) is needed when using
% |per-mode = symbol-or-fraction|. The commands \cs{frac}, \cs{mathrm},
% \cs{mbox}, \verb*|\ | and \cs{,} are used by the standard module settings,
% and \cs{ensuremath}, \cs{hbar}, \cs{mathit} and \cs{mathrm} in some standard
% unit definitions (for atomic and natural units). For the display of colored
% (highlighted) and cancelled units, the commands \cs{textcolor} and
% \cs{cancel} are assumed to be available.

% \section{Formatting units}
%
% \begin{function}{\siunitx_unit_format:nN}
%   \begin{syntax}
%     \cs{siunitx_unit_format:nN} \Arg{units} \meta{tl~var}
%   \end{syntax}
%   This function converts the input \meta{units} into a processed
%   \meta{tl~var} which can then be inserted in math mode to typeset the
%   material. Where the \meta{units} are given in symbolic form, described
%   elsewhere, this formatting process takes place in two stages: the
%   \meta{units} are parsed into a structured form before the generation
%   of the appropriate output form based on the active settings. When the
%   \meta{units} are given as literals, processing is minimal: the
%   characters |.| and |~| are converted to unit products (boundaries).
%   In both cases, the result is a series of tokens intended to be typeset
%   in math mode with appropriate choice of font for typesetting of the
%   textual parts.
%
%   For example,
%   \begin{verbatim}
%     \siunitx_unit_format:nN { \kilo \metre \per \second } \l_tmpa_tl
%   \end{verbatim}
%   will, with standard settings, result in \cs{l_tmpa_tl} being set to
%   \begin{verbatim}
%     \mathrm{km}\,\mathrm{s}^{-1}
%   \end{verbatim}
% \end{function}
%
% \begin{function}{\siunitx_unit_format:nNN}
%   \begin{syntax}
%     \cs{siunitx_unit_format:nNN} \Arg{units} \meta{tl~var} \meta{fp~var}
%   \end{syntax}
%   This function formats the \meta{units} in the same way as described for
%   \cs{siunitx_unit_format:nN}. When the input is given in symbolic form,
%   any decimal unit prefixes will be extracted and the overall power of
%   ten that these represent will be stored in the \meta{fp~var}.
%
%   For example,
%   \begin{verbatim}
%     \siunitx_unit_format:nNN { \kilo \metre \per \second }
%       \l_tmpa_tl \l_tmpa_fp
%   \end{verbatim}
%   will, with standard settings, result in \cs{l_tmpa_tl} being set to
%   \begin{verbatim}
%     \mathrm{m}\,\mathrm{s}^{-1}
%   \end{verbatim}
%   with \cs{l_tmpa_fp} taking value~$3$. Note that the latter is a floating
%   point variable: it is possible for non-integer values to be obtained here.
% \end{function}
%
% \section{Defining symbolic units}
%
% \begin{function}{\siunitx_unit_prefix_set:Nnn}
%   \begin{syntax}
%     \cs{siunitx_unit_prefix_set:Nnn} \meta{prefix} \Arg{symbol} \Arg{power}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. The prefix
%   should represent an integer \meta{power} of $10$, and this information
%   may be used to convert from one or more \meta{prefix} symbols to an
%   overall power applying to a unit. See also
%   \cs{siunitx_unit_prefix_set:Nn}.
% \end{function}
%
% \begin{function}{\siunitx_unit_prefix_set:Nn}
%   \begin{syntax}
%     \cs{siunitx_unit_prefix_set:Nn}  \meta{prefix} \Arg{symbol}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. In contrast
%   to \cs{siunitx_unit_prefix_set:Nnn}, there is no assumption about the
%   mathematical nature of the \meta{prefix}, \emph{i.e.}~the prefix may
%   represent a power of any base. As a result, no conversion of the
%   \meta{prefix} to a numerical power will be possible.
% \end{function}
%
% \begin{function}{\siunitx_unit_power_set:NnN}
%   \begin{syntax}
%     \cs{siunitx_unit_set:Nn} \meta{power} \Arg{value} \meta{precedes}
%   \end{syntax}
%   Defines a symbolic \meta{power} (which should be a control sequence
%   such as |\squsred|) to be converted by the parser to the \meta{value}.
%   The latter should be an integer or floating point number in the format
%   defined for \pkg{l3fp}. Powers may precede a unit or be given after it:
%   which case applies to the \meta{power} is determined by the boolean
%   \meta{precedes}. In literal mode, the \meta{value} will be applied as
%   a superscript to either the next token in the input (\meta{precedes}
%   true) or appended to the previously-typeset material (\meta{precedes}
%   false).
% \end{function}
%
% \begin{function}{\siunitx_unit_qualifier_set:Nn}
%   \begin{syntax}
%     \cs{siunitx_unit_qualifier_set:Nn} \meta{qualifier} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{qualifier} (which should be a control sequence
%   such as |\catalyst|) to be converted by the parser to the \meta{meaning}.
%   The latter should consist of literal content (\emph{e.g.}~|cat|). In
%   literal mode the \meta{meaning} will be typeset following a space after
%   the unit to which it applies.
% \end{function}
%
% \begin{function}{\siunitx_unit_set:Nn, \siunitx_unit_set:Nx}
%   \begin{syntax}
%     \cs{siunitx_unit_set:Nn} \meta{unit} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{unit} (which should be a control sequence
%   such as |\kilogram|) to be converted by the parser to the \meta{meaning}.
%   The latter may consist of literal content (\emph{e.g.}~|kg|), other
%   symbolic unit commands (\emph{e.g.}~|\kilo\gram|) or a mixture of the two.
%   In literal mode the \meta{meaning} will be typeset directly.
% \end{function}
%
% \begin{variable}{\l_siunitx_unit_symbolic_seq}
%   This sequence contains all of the symbolic \meta{unit} names defined :
%   these will be in the form of control sequences such as |\kilogram|.
%   The order of the sequence is unimportant.
% \end{variable}
%
% \section{Pre-defined symbolic unit components}
%
% The unit parser is defined to recognise a number of pre-defined units,
% prefixes and powers, and also interpret a small selection of
% \enquote{generic} symbolic parts.
%
% Broadly, the pre-defined units are those defined by the \textsc{bipm} in the
% documentation for the \emph{International System of Units} (SI)~\cite{BIPM}.
% As far as possible, the names given to the command names for units are those
% used by the \textsc{bipm}, omitting spaces and using only \textsc{ascii}
% characters. The standard symbols are also taken from the same documentation.
% In the following documentation, the order of the description of units
% broadly follows the SI~Brochure.
%
% \begin{function}
%   {
%     \kilogram ,
%     \metre    ,
%     \meter    ,
%     \mole     ,
%     \kelvin   ,
%     \candela  ,
%     \second   ,
%     \ampere
%   }
%   The base units as defined in Section~2.1 of the SI Brochure~\cite{SI:2.1}.
%   Notice that \cs{meter} is defined as an alias for \cs{metre} as the former
%   spelling is common in the US (although the latter is the official spelling).
% \end{function}
%
% \begin{function}{\gram}
%   The base unit \cs{kilogram} is defined using an SI prefix: as such the
%   (derived) unit \cs{gram} is required by the module to correctly produce
%   output for the \cs{kilogram}.
% \end{function}
%
% \begin{function}
%   {
%     \yocto ,
%     \zepto ,
%     \atto  ,
%     \femto ,
%     \pico  ,
%     \nano  ,
%     \micro ,
%     \milli ,
%     \centi ,
%     \deci  ,
%     \deca  ,
%     \deka  ,
%     \hecto ,
%     \kilo  ,
%     \mega  ,
%     \giga  ,
%     \tera  ,
%     \peta  ,
%     \exa   ,
%     \zetta ,
%     \yotta
%   }
%   Prefixes, all of which are integer powers of $10$: the powers are stored
%   internally by the module and can be used for conversion from prefixes to
%   their numerical equivalent. These prefixes are documented in Section~3.1
%   of the SI~Brochure~\cite{SI:3.1}.
%
%   Note that the \cs{kilo} prefix is required to
%   define the base \cs{kilogram} unit. Also note the two spellings available
%   for \cs{deca}/\cs{deka}.
% \end{function}
%
% \begin{function}
%   {
%     \becquerel     ,
%     \degreeCelsius ,
%     \coulomb       ,
%     \farad         ,
%     \gray          ,
%     \hertz         ,
%     \henry         ,
%     \joule         ,
%     \katal         ,
%     \lumen         ,
%     \lux           ,
%     \newton        ,
%     \ohm           ,
%     \pascal        ,
%     \radian        ,
%     \siemens       ,
%     \sievert       ,
%     \steradian     ,
%     \tesla         ,
%     \volt          ,
%     \watt          ,
%     \weber
%   }
%   The defined SI~units with defined names and symbols, as given in
%   Section~2.2.2 of the SI~Brochure~\cite{SI:2.2.2}. Notice that the names
%   of the units are lower case with the exception of \cs{degreeCelsius}, and
%   that this unit name includes \enquote{degree}.
% \end{function}
%
% \begin{function}
%   {
%     \day       ,
%     \hectare   ,
%     \hour      ,
%     \litre     ,
%     \liter     ,
%     \minute    ,
%     \tonne
%   }
%   Units accepted for use with the SI: here \cs{minute} is a unit of time
%   not of plane angle. These units are taken from Table~4.1 of the
%   SI~Brochure~\cite{SI:4.1.T6}.
%
%   For the unit \cs{litre}, both |l| and |L| are listed
%   as acceptable symbols: the latter is the standard setting of the module.
%   The alternative spelling \cs{liter} is also given for this unit for US
%   users (as with \cs{metre}, the official spelling is \enquote{re}).
% \end{function}
%
% \begin{function}
%   {
%     \arcminute ,
%     \arcsecond ,
%     \degree
%   }
%   Units for plane angles accepted for use with the SI: to avoid a clash
%   with units for time, here \cs{arcminute} and \cs{arcsecond} are used in
%   place of \cs{minute} and \cs{second}. These units are taken from Table~4.1
%   of the SI~Brochure~\cite{SI:4.1.T6}.
% \end{function}
%
% \begin{function}
%   {
%     \astronomicalunit ,
%     \atomicmassunit   ,
%     \dalton           ,
%     \electronvolt     ,
%     \nuaction         ,
%     \numass           ,
%     \nuspeed          ,
%     \nutime           ,
%     \auaction         ,
%     \aucharge         ,
%     \auenergy         ,
%     \aulength         ,
%     \aumass           ,
%     \autime           ,
%     \bohr             ,
%     \hartree
%   }
%   Non-SI where values must be determined experimentally. These units are taken from
%   Table~7 of the SI~Brochure~\cite{SI:4.1.T7}. Where no better name is given for
%   the unit in the SI~Brochure, the prefixes |nu| (natural unit) and |au| (atomic
%   unit) are used.
%
%   Note that the value of the natural unit of speed (the speed of light) is used
%   to define the second and is thus not determined by experiment: it is however
%   included in this set of units.
% \end{function}
%
% \begin{function}
%   {
%     \angstrom          ,
%     \bar               ,
%     \barn              ,
%     \bel               ,
%     \decibel           ,
%     \knot              ,
%     \millimetremercury ,
%     \nauticalmile      ,
%     \neper
%   }
%   Non-SI units accepted for use with the SI. These units are taken from
%   Table~8 of the SI~Brochure~\cite{SI:4.1.T8}.
% \end{function}
%
% \begin{function}
%   {
%     \dyne    ,
%     \erg     ,
%     \gal     ,
%     \gauss   ,
%     \maxwell ,
%     \oersted ,
%     \phot    ,
%     \poise   ,
%     \stilb   ,
%     \stokes
%   }
%   Non-SI units associated with the CGS and the CGS-Gaussian system of units.
%   These units are taken from Table~9 of the SI~Brochure~\cite{SI:4.1.T9}.
% \end{function}
%
% \begin{function}{\percent}
% \end{function}
%
% \begin{function}{\square, \cubic}
%   \begin{syntax}
%     \cs{square} \meta{prefix} \meta{unit}
%     \cs{cubic} \meta{prefix} \meta{unit}
%   \end{syntax}
%   Pre-defined unit powers which apply to the next \meta{prefix}/\meta{unit}
%   combination.
% \end{function}
%
% \begin{function}{\squared, \cubed}
%   \begin{syntax}
%     \meta{prefix} \meta{unit} \cs{squared}
%     \meta{prefix} \meta{unit} \cs{cubed}
%   \end{syntax}
%   Pre-defined unit powers which apply to the preceding
%   \meta{prefix}/\meta{unit} combination.
% \end{function}
%
% \begin{function}{\per}
%   \begin{syntax}
%     \cs{per} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   is reciprocal, \emph{i.e.}~raises it to the power $-1$. This symbolic
%   representation may be applied in addition to a \cs{power}, and will work
%   correctly if the \cs{power} itself is negative. In literal mode \cs{per}
%   will print a slash (\enquote{$/$}).
% \end{function}
%
% \begin{function}{\cancel}
%   \begin{syntax}
%     \cs{cancel} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be \enquote{cancelled out}. In the parsed output, the entire unit
%   combination will be given as the argument to a function \cs{cancel}, which
%   is assumed to be available at a higher level. In literal mode, the same
%   higher-level \cs{cancel} will be applied to the next token. It is the
%   responsibility of the calling code to provide an appropriate definition
%   for \cs{cancel} outside of the scope of the unit parser.
% \end{function}
%
% \begin{function}{\highlight}
%   \begin{syntax}
%     \cs{highlight} \Arg{color} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be highlighted in the specified \meta{color}. In the parsed output,
%   the entire unit combination will be given as the argument to a function
%   \cs{textcolor}, which is assumed to be available at a higher level. In
%   literal mode, the same higher-level \cs{textcolor} will be applied to the
%   next token. It is the responsibility of the calling code to provide an
%   appropriate definition for \cs{textcolor} outside of the scope of the unit
%   parser.
% \end{function}
%
% \begin{function}{\of}
%   \begin{syntax}
%     \meta{prefix} \meta{unit} \meta{power} \cs{of} \Arg{qualifier}
%   \end{syntax}
%   Indicates that the \meta{qualifier} applies to the current
%   \meta{prefix}/\meta{unit}/\meta{power} combination. In parsed mode, the
%   display of the result will depend upon module options. In literal mode,
%   the \meta{qualifier} will be printed in parentheses following the preceding
%   \meta{unit} and a full-width space.
% \end{function}
%
% \begin{function}{\raiseto, \tothe}
%   \begin{syntax}
%     \cs{raiseto} \Arg{power} \meta{prefix} \meta{unit}
%     \meta{prefix} \meta{unit} \cs{tothe} \Arg{power}
%   \end{syntax}
%   Indicates that the \meta{power} applies to the current
%   \meta{prefix}/\meta{unit} combination. As shown, \cs{raiseto} applies to
%   the next \meta{unit} whereas \cs{tothe} applies to the preceding unit. In
%   literal mode the \cs{power} will be printed as a superscript attached to
%   the next token (\cs{raiseto}) or preceding token (\cs{tothe}) as
%   appropriate.
% \end{function}
%
% \subsection{Key--value options}
%
% The options defined by this submodule are available within the \pkg{l3keys}
% |siunitx/unit| tree.
%
% \begin{function}{bracket-denominator}
%   \begin{syntax}
%     |bracket-denominator| = |true|\verb"|"|false|
%   \end{syntax}
%   Switch to determine whether brackets are added to the denominator part of
%   a unit when printed using inline fractional form (with |per-mode| as
%   |repeated-symbol|, |symbol| or |symbol-or-fraction|). The standard setting
%   is |true|.
% \end{function}
%
% \begin{function}{close-bracket}
%   \begin{syntax}
%     |close-bracket| = |true|\verb"|"|false|
%   \end{syntax}
%   Bracket symbol used to close a matched pair around units when once is
%   required to maintain mathematical logic. The standard setting is ^^A (
%   |)|.
% \end{function}
%
% \begin{function}{font-command}
%   \begin{syntax}
%     |font-command| = \meta{command}
%   \end{syntax}
%   Command applied to text during output of units: should be command usable
%   in math mode for font selection. Notice that in a typical unit this does
%   not (necessarily) apply to all output, for example powers or brackets.
%   The standard setting is |\mathrm|.
% \end{function}
%
% \begin{function}{fraction-command}
%   \begin{syntax}
%     |fraction-command| = \meta{command}
%   \end{syntax}
%   Command used to create fractional output when |per-mode| is set to
%   |fraction|. The standard setting is |\frac|.
% \end{function}
%
% \begin{function}{open-bracket}
%   \begin{syntax}
%     |open-bracket| = \meta{symbol}
%   \end{syntax}
%   Bracket symbol used to open a matched pair around units when once is
%   required to maintain mathematical logic. The standard setting is |(|. ^^A )
% \end{function}
%
% \begin{function}{parse}
%   \begin{syntax}
%     |parse| = |true|\verb"|"|false|
%   \end{syntax}
%   Determines whether parsing of unit symbols is attempted or literal
%   mode is used directly. The standard setting is |true|.
% \end{function}
%
% \begin{function}{per-mode}
%   \begin{syntax}
%     |per-mode| = \meta{choice}
%   \end{syntax}
%   Selects how the negative powers (\cs{per}) are formatted: a choice from
%   the options |fraction|, |power|, |power-positive-first|, |repeated-symbol|,
%   |symbol| and |symbol-or-fraction|. The option |fraction| generates
%   fractional output when appropriate using the command specified by
%   the |fraction-command| option. The setting |power| uses reciprocal powers
%   leaving the units in the order of input, while |power-positive-first| uses
%   the same display format but sorts units such that the positive powers
%   come before negative ones. The |symbol| setting uses a symbol (specified
%   by |per-symbol|) between positive and negative powers, while
%   |repeated-symbol| uses the same symbol but places it before \emph{every}
%   unit with a negative power (this is mathematically \enquote{wrong} but
%   often seen in real work). Finally, |symbol-or-fraction| acts like
%   |symbol| for inline output and like |fraction| when the output is used
%   in a display math environment. The standard setting is |power|.
% \end{function}
%
% \begin{function}{per-symbol}
%   \begin{syntax}
%     |per-symbol| = \meta{symbol}
%   \end{syntax}
%   Specifies the symbol to be used to denote negative powers when the option
%   |per-mode| is set to |repeated-symbol|, |symbol| or |symbol-or-fraction|.
%   The standard setting is |/|.
% \end{function}
%
% \begin{function}{product}
%   \begin{syntax}
%     |product| = \meta{separator}
%   \end{syntax}
%   Inserted between unit combinations in parsed mode, and used to replace
%   |.| and |~| in literal mode. The standard setting is |\,|.
% \end{function}
%
% \begin{function}{qualifier-mode}
%   \begin{syntax}
%     |qualifier-mode| = \meta{choice}
%   \end{syntax}
%   Selects how qualifiers are formatted: a choice from the options |brackets|,
%   |combine|, |phrase| and |subscript|. The option |bracket| wraps
%   the qualifier in parenthesis, |combine| joins the qualifier with the unit
%   directly, |phrase| inserts the content stored by the option
%   |qualifier-phrase| between the unit and qualifier, and |subscript| formats
%   the qualifier as a subscript. The standard setting is |subscript|.
% \end{function}
%
% \begin{function}{qualifier-phrase}
%   \begin{syntax}
%     |qualifier-phrase| = \meta{choice}
%   \end{syntax}
%   Defines the text to be inserted between a unit and qualifier when
%   |qualifier-mode| is set to |phrase|. This material is inserted without
%   any font control and so if text mode is required it should be
%   included in the setting, for example \verb*|\ \mbox{of}\ |. The
%   standard setting is a full width space (\verb*|\ |).
% \end{function}
%
% \begin{function}{sticky-per}
%   \begin{syntax}
%     |sticky-per| = |true|\verb"|"|false|
%   \end{syntax}
%   Used to determine whether \cs{per} should be applied one a unit-by-unit
%   basis (when |false|) or should apply to all following units
%   (when |true|). The latter mode is somewhat akin conceptually to the
%   \TeX{} \cs{over} primitive. The standard setting is |false|.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{siunitx-unit} implementation}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention): only
% internal material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_unit>
%    \end{macrocode}
%
% \subsection{Initial set up}
%
% The mechanisms defined here need a few variables to exist and to be
% correctly set: these don't belong to one subsection and so are created
% in a small general block.
%
%   Variants not provided by \pkg{expl3}.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_replace_all:Nnn { NnV }
%    \end{macrocode}
%
% \begin{variable}{\l_@@_tmp_fp}
% \begin{variable}{\l_@@_tmp_int}
% \begin{variable}{\l_@@_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\fp_new:N \l_@@_tmp_fp
\int_new:N \l_@@_tmp_int
\tl_new:N  \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{variable}{\c_@@_math_subscript_tl}
%   Useful tokens with awkward category codes.
%    \begin{macrocode}
\tl_const:Nx \c_@@_math_subscript_tl { \char_generate:nn { `\_ } { 8 } }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_parsing_bool}
%   A boolean is used to indicate when the symbolic unit functions should
%   produce symbolic or literal output. This is used when the symbolic names
%   are used along with literal input, and ensures that there is a sensible
%   fall-back for these cases.
%    \begin{macrocode}
\bool_new:N \l_@@_parsing_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_test_bool}
%   A switch used to indicate that the code is testing the input to find
%   if there is any typeset output from individual unit macros. This is needed
%   to allow the \enquote{base} macros to be found, and also to pick up the
%   difference between symbolic and literal unit input.
%    \begin{macrocode}
\bool_new:N \l_@@_test_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_if_symbolic:nTF}
%   The test for symbolic units is needed in two places. First, there is the
%   case of \enquote{pre-parsing} input to check if it can be parsed. Second,
%   when parsing there is a need to check if the current unit is built up
%   from others (symbolic) or is defined in terms of some literals. To do this,
%   the approach used is to set all of the symbolic unit commands expandable
%   and to do nothing, with the few special cases handled manually. If
%   an \texttt{f}-type definition then yields nothing at all then the
%   assumption is that the input is symbolic. (We use \texttt{f}-type
%   expansion since it will turn the symbolic unit names into nothing at
%   all but doesn't require them to be expandable.)
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_symbolic:n #1 { TF }
  {
    \group_begin:
      \bool_set_true:N \l_@@_test_bool
      \tl_set:Nf \l_@@_tmp_tl {#1}
    \exp_args:NNV \group_end:
    \tl_if_blank:nTF \l_@@_tmp_tl
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Defining symbolic unit}
%
% Unit macros and related support are created here. These exist only within
% the scope of the unit processor code, thus not polluting document-level
% namespace and allowing overlap with other areas in the case of useful short
% names (for example \cs{pm}). Setting up the mechanisms to allow this requires
% a few additional steps on top of simply saving the data given by the user
% in creating the unit.
%
% \begin{variable}{\l_siunitx_unit_symbolic_seq}
%   A list of all of the symbolic units, \emph{etc.}, set up. This is needed
%   to allow the symbolic names to be defined within the scope of the unit
%   parser but not elsewhere using simple mappings.
%    \begin{macrocode}
\seq_new:N \l_siunitx_unit_symbolic_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_set_symbolic:Nnn}
% \begin{macro}{\@@_set_symbolic:Npnn}
% \begin{macro}{\@@_set_symbolic:NNpnn}
%   The majority of the work for saving each symbolic definition is the same
%   irrespective of the item being defined (unit, prefix, power, qualifier).
%   This is therefore all carried out in a single internal function which
%   does the common tasks. The three arguments here are the symbolic macro
%   name, the literal output and the code to insert when doing full unit
%   parsing. To allow for the \enquote{special cases} (where arguments are
%   required) the entire mechanism is set up in a two-part fashion allowing
%   for flexibility at the slight cost of additional functions.
%
%   Importantly, notice that the unit macros are declared as expandable. This
%   is required so that literals can be correctly converted into a token list
%   of material which does not depend on local redefinitions for the unit
%   macros. That is required so that the unit formatting system can be grouped.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_symbolic:Nnn #1
  { \@@_set_symbolic:NNnnn \cs_set:cpn #1 { } }
\cs_new_protected:Npn \@@_set_symbolic:Npnn #1#2#
  { \@@_set_symbolic:NNnnn \cs_set:cpn #1 {#2} }
\cs_new_protected:Npn \@@_set_symbolic:NNnnn #1#2#3#4#5
  {
    \seq_put_right:Nn \l_siunitx_unit_symbolic_seq {#2}
    #1 { units ~ > ~ \token_to_str:N #2 } #3
      {
        \bool_if:NF \l_@@_test_bool
          {
            \bool_if:NTF \l_@@_parsing_bool
              {#5}
              {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\siunitx_unit_power_set:NnN}
%   For powers, there is the slight complication that the symbolic name may
%   appear either before or after the unit it applies to, and these two
%   different cases need slightly different code for the literal case. A
%   boolean is used to determine which case is in operation, and in parsing
%   mode this data is passed directly to the underlying function.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_unit_power_set:NnN #1#2#3
  {
    \bool_if:NTF #3
      {
        \@@_set_symbolic:Nnn #1
          { \@@_literal_power:nN {#1} }
      }
      {
        \@@_set_symbolic:Nnn #1
          { ^ {#2} }
      }
        { \@@_parse_power:nnN {#1} {#2} #3 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_unit_prefix_set:Nn}
% \begin{macro}{\siunitx_unit_prefix_set:Nnn}
% \begin{variable}
%   {\l_@@_prefixes_forward_prop, \l_@@_prefixes_reverse_prop}
%   For prefixes there are a couple of options. In all cases, the basic
%   requirement is to set up to parse the prefix using the appropriate
%   internal function. For prefixes which are powers of $10$, there is also
%   the need to be able to do conversion to/from the numerical equivalent.
%   That is handled using two properly lists which can be used to supply
%   the conversion data later.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_unit_prefix_set:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      { \@@_parse_prefix:Nn #1 {#2} }
  }
\cs_new_protected:Npn \siunitx_unit_prefix_set:Nnn #1#2#3
  {
    \siunitx_unit_prefix_set:Nn #1 {#2}
    \prop_put:Nnn \l_@@_prefixes_forward_prop {#2} {#3}
    \prop_put:Nnn \l_@@_prefixes_reverse_prop {#3} {#2}
  }
\prop_new:N \l_@@_prefixes_forward_prop
\prop_new:N \l_@@_prefixes_reverse_prop
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\siunitx_unit_qualifier_set:Nn}
%   Qualifiers are relatively easy to handle: nothing to do other than save
%   the input appropriately.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_unit_qualifier_set:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      { \  ( #2 ) }
      { \@@_parse_qualifier:nn {#1} {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_unit_set:Nn, \siunitx_unit_set:Nx}
%   For the unit parsing, allowing for variations in definition order requires
%   that a test is made for the output of each unit at point of use.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_unit_set:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      {
        \@@_if_symbolic:nTF {#2}
          {#2}
          { \@@_parse_unit:Nn #1 {#2} }
      }
  }
\cs_generate_variant:Nn \siunitx_unit_set:Nn { Nx }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Non-standard symbolic units}
%
% A few of the symbolic units require non-standard definitions: these are
% created here. They all use parts of the more general code but have particular
% requirements which can only be addressed by hand. Some of these could in
% principle be used in place of the dedicated definitions above, but at point
% of use that would then require additional expansions for each unit parsed:
% as the macro names would still be needed, this does not offer any real
% benefits.
%
% \begin{macro}{\per}
%   The \cs{per} symbolic unit is a bit special: it has a mechanism entirely
%   different from everything else, so has to be set up by hand. In literal
%   mode it is represented by a very simple symbol!
%    \begin{macrocode}
\@@_set_symbolic:Nnn \per
  { / }
  { \@@_parse_per: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cancel}
% \begin{macro}{\highlight}
%   The two special cases, \cs{cancel} and \cs{highlight}, are easy to deal
%   with when parsing. When not parsing, a precaution is taken to ensure that
%   the user level equivalents always get a braced argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \cancel
  { \@@_literal_special:nN { \cancel } }
  { \@@_parse_special:n { \cancel } }
\@@_set_symbolic:Npnn \highlight #1
  { \@@_literal_special:nN { \textcolor {#1} } }
  { \@@_parse_special:n { \textcolor {#1} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\of}
%   The generic qualifier is simply the same as the dedicated ones except for
%   needing to grab an argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \of #1
  { \  ( #1 ) }
  { \@@_parse_qualifier:nn { \of {#1} } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\raiseto, \tothe}
%   Generic versions of the pre-defined power macros. These require an
%   argument and so cannot be handled using the general approach. Other than
%   that, the code here is very similar to that in
%   \cs{siunitx_unit_power_set:NnN}.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \raiseto #1
  { \@@_literal_power:nN {#1} }
  { \@@_parse_power:nnN { \raiseto {#1} } {#1} \c_true_bool }
\@@_set_symbolic:Npnn \tothe #1
  { ^ {#1} }
  { \@@_parse_power:nnN { \tothe {#1} } {#1} \c_false_bool }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Main formatting routine}
%
% Unit input can take two forms, \enquote{literal} units (material to be
% typeset directly) or \enquote{symbolic} units (macro-based). Before any
% parsing or typesetting is carried out, a small amount of pre-parsing has to
% be carried out to decide which of these cases applies.
%
% \begin{variable}{\l_@@_font_tl, \l_@@_product_tl}
%   Options which apply to the main formatting routine, and so are not tied
%   to either symbolic or literal input.
%    \begin{macrocode}
\keys_define:nn { siunitx / unit }
  {
    font-command .tl_set:N = \l_@@_font_tl    ,
    product      .tl_set:N = \l_@@_product_tl
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_formatted_tl}
%   A token list for the final formatted result: may or may not be generated
%   by the parser, depending on the nature of the input.
%    \begin{macrocode}
\tl_new:N \l_@@_formatted_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\siunitx_unit_format:nN}
% \begin{macro}{\siunitx_unit_format:nNN}
% \begin{macro}{\@@_format:nNN}
% \begin{macro}{\@@_format_aux:}
%   Formatting parsed units can take place either with the prefixes printed or
%   separated out into a power of ten. This variation is handled using two
%   separate functions: as this submodule does not really deal with numbers,
%   formatting the numeral part here would be tricky and it is better therefore
%   to have a mechanism to return a simple numerical power. At the same time,
%   most uses will no want this more complex return format and so a version of
%   the code which does not do this is also provided.
%
%   The main unit formatting routine groups all of the parsing/formatting, so
%   that the only value altered will be the return token list. As definitions
%   for the various unit macros are not globally created, the first step is to
%   map over the list of names and active the unit definitions: these do
%   different things depending on the switches set. There is then a decision to
%   be made: is the unit input one that can be parsed (\enquote{symbolic}), or
%   is is one containing one or more literals. In the latter case, there is a
%   still the need to convert the input into an expanded token list as some
%   parts of the input could still be using unit macros.
%
%   Notice that for \cs{siunitx_unit_format:nN} a second return value from the
%   auxiliary has to be allowed for, but is simply discarded.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_unit_format:nN #1#2
  {
    \bool_set_false:N \l_@@_prefix_power_bool
    \@@_format:nNN {#1} #2 \l_@@_tmp_fp
  }
\cs_new_protected:Npn \siunitx_unit_format:nNN #1#2#3
  {
    \bool_set_true:N \l_@@_prefix_power_bool
    \@@_format:nNN {#1} #2 #3
  }
\cs_new_protected:Npn \@@_format:nNN #1#2#3
  {
    \group_begin:
      \seq_map_inline:Nn \l_siunitx_unit_symbolic_seq
        { \cs_set_eq:Nc ##1 { units ~ > ~ \token_to_str:N ##1 } }
      \tl_clear:N \l_@@_formatted_tl
      \fp_zero:N \l_@@_prefix_fp
      \bool_if:NTF \l_@@_parse_bool
        {
          \@@_if_symbolic:nTF {#1}
            {
              \@@_parse:n {#1}
              \prop_if_empty:NF \l_@@_parsed_prop
                { \@@_format_parsed: }
            }
            { \@@_format_literal:n {#1} }
        }
        { \@@_format_literal:n {#1} }
      \cs_set_protected:Npx \@@_format_aux:
        {
          \tl_set:Nn \exp_not:N #2
            { \exp_not:V \l_@@_formatted_tl }
          \fp_set:Nn \exp_not:N #3
            { \fp_use:N \l_@@_prefix_fp }
        }
    \exp_after:wN \group_end:
    \@@_format_aux:
  }
\cs_new_protected:Npn \@@_format_aux: { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Formatting literal units}
%
% While in literal mode no parsing occurs, there is a need to provide a few
% auxiliary functions to handle one or two special cases.
%
% \begin{macro}{\@@_literal_power:nN}
%   For printing literal units which are given before the unit they apply to,
%   there is a slight rearrangement.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_literal_power:nN #1#2 { #2 ^ {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_literal_special:nN}
%   When dealing with the special cases, there is an argument to absorb. This
%   should be braced to be passed up to the user level, which is dealt with
%   here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_literal_special:nN #1#2 { #1 {#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_format_literal:n}
% \begin{macro}{\@@_format_literal_auxi:w}
% \begin{macro}{\@@_format_literal_auxii:w}
% \begin{macro}{\@@_format_literal_auxiii:w}
% \begin{macro}{\@@_format_literal_auxiv:w}
% \begin{macro}{\@@_format_literal_auxv:w}
% \begin{variable}{\l_@@_separator_tl}
%   To format literal units, there are two tasks to do. The input is
%   \texttt{x}-type expanded to force any symbolic units to be converted into
%   their literal representation: this requires setting the appropriate
%   switch. In the resulting token list, all |.| and |~| tokens are then
%   replaced by the current unit product token list. To enable this to happen
%   correctly with a normal (active) |~|, a small amount of
%   \enquote{protection} is needed first.
%
%   As with other code dealing with user input, \cs{protected@edef} is used
%   here rather than \cs{tl_set:Nx} as \LaTeXe{} robust commands may be
%   present.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_active:n { `\~ }
  \cs_new_protected:Npx \@@_format_literal:n #1
    {
      \group_begin:
        \exp_not:n { \bool_set_false:N \l_@@_parsing_bool }
        \tl_set:Nn \exp_not:N \l_@@_tmp_tl {#1}
        \tl_replace_all:Nnn \exp_not:N \l_@@_tmp_tl
          { \exp_not:N ~ } { . }
        \tl_replace_all:Nnn \exp_not:N \l_@@_tmp_tl
          { \token_to_str:N ^ } { ^ }
        \tl_replace_all:Nnn \exp_not:N \l_@@_tmp_tl
          { \token_to_str:N _ } { \c_@@_math_subscript_tl }
        \exp_not:n
          {
              \protected@edef \l_@@_tmp_tl { \l_@@_tmp_tl }
              \tl_clear:N \l_@@_formatted_tl
              \tl_if_empty:NF \l_@@_tmp_tl
                {
                  \exp_after:wN \@@_format_literal_auxi:w \l_@@_tmp_tl .
                    \q_recursion_tail . \q_recursion_stop
                }
            \exp_args:NNNV \group_end:
            \tl_set:Nn \l_@@_formatted_tl \l_@@_formatted_tl
          }
    }
\group_end:
%    \end{macrocode}
%   To introduce the font changing commands while still allowing for line
%   breaks in literal units, a loop is needed to replace one |.| at a time.
%   To also allow for division, a second loop is used within that to handle
%   |/|: as a result, the separator between parts has to be tracked.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_literal_auxi:w #1 .
  {
    \quark_if_recursion_tail_stop:n {#1}
    \@@_format_literal_auxii:n {#1}
    \tl_set_eq:NN \l_@@_separator_tl \l_@@_product_tl
    \@@_format_literal_auxi:w
  }
\cs_set_protected:Npn \@@_format_literal_auxii:n #1
  {
    \@@_format_literal_auxiii:w
      #1 / \q_recursion_tail / \q_recursion_stop
  }
\cs_new_protected:Npn \@@_format_literal_auxiii:w #1 /
  {
    \quark_if_recursion_tail_stop:n {#1}
    \@@_format_literal_auxiv:w #1 ^ ^ \q_stop
    \tl_set:Nn \l_@@_separator_tl { / }
    \@@_format_literal_auxiii:w
  }
%    \end{macrocode}
%   Within each unit any sub- and superscript parts need to be separated out:
%   wrapping everything in the font command is incorrect. The superscript part
%   is relatively easy as there is no catcode issue or font command to add,
%   while the subscript part needs a bit more work. As the user might have the
%   two parts in either order, picking up the subscript needs to look in two
%   places. We assume that only one is given: odd input here is simply accepted.
%    \begin{macrocode}
\use:x
  {
    \cs_new_protected:Npn \exp_not:N \@@_format_literal_auxiv:w
      ##1 ^ ##2 ^ ##3 \exp_not:N \q_stop
      {
        \exp_not:N \@@_format_literal_auxv:w
          ##1 \c_@@_math_subscript_tl \c_@@_math_subscript_tl
          \exp_not:N \q_mark
          ##2 \c_@@_math_subscript_tl \c_@@_math_subscript_tl
          \exp_not:N \q_stop
      }
    \cs_new_protected:Npn \exp_not:N \@@_format_literal_auxv:w
      ##1 \c_@@_math_subscript_tl ##2 \c_@@_math_subscript_tl ##3
      \exp_not:N \q_mark
      ##4 \c_@@_math_subscript_tl ##5 \c_@@_math_subscript_tl ##6
      \exp_not:N \q_stop
      {
        \tl_set:Nx \exp_not:N \l_@@_formatted_tl
          {
            \exp_not:N \exp_not:V \exp_not:N \l_@@_formatted_tl
            \exp_not:N \tl_if_empty:NF \exp_not:N \l_@@_formatted_tl
              { \exp_not:N \exp_not:V \exp_not:N \l_@@_separator_tl }
            \exp_not:N \tl_if_blank:nF {##1}
              {
                \exp_not:N \exp_not:V \exp_not:N \l_@@_font_tl
                  { \exp_not:N \exp_not:n {##1} }
              }
            \exp_not:N \tl_if_blank:nF {##4}
              { ^ { \exp_not:N \exp_not:n {##4} } }
            \exp_not:N \tl_if_blank:nF {##2##5}
              {
                \c_@@_math_subscript_tl
                  {
                    \exp_not:N \exp_not:V \exp_not:N \l_@@_font_tl
                      { \exp_not:N \exp_not:n {##2##5} }
                  }
              }
          }
      }
  }
\tl_new:N \l_@@_separator_tl
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Parsing symbolic units}
%
% Parsing units takes place by storing information about each unit in a
% \texttt{prop}. As well as the unit itself, there are various other optional
% data points, for example a prefix or a power. Some of these can come before
% the unit, others only after. The parser therefore tracks the number of units
% read and uses the current position to allocate data to individual units.
%
% The result of parsing is a property list (\cs{l_@@_parsed_prop}) which
% contains one or more entries for each unit:
% \begin{itemize}
%   \item \texttt{prefix-$n$} The symbol for the prefix which applies to this
%     unit, \emph{e.g.} for \cs{kilo} with (almost certainly) would be
%     |k|.
%   \item \texttt{unit-$n$} The symbol for the unit itself, \emph{e.g.}~for
%     \cs{metre} with (almost certainly) would be |m|.
%   \item \texttt{power-$n$} The power which a unit is raised to. During
%     initial parsing this will (almost certainly) be positive, but is combined
%     with \texttt{per-$n$} to give a \enquote{fully qualified} power before
%     any formatting takes place
%   \item \texttt{per-$n$} Indicates that \texttt{per} applies to the current
%     unit: stored during initial parsing then combined with \texttt{power-$n$}
%     (and removed from the list) before further work.
%   \item \texttt{qualifier-$n$} Any qualifier which applies to the current
%     unit.
%   \item \texttt{special-$n$} Any \enquote{special effect} to apply to the
%     current unit.
% \end{itemize}
%
% \begin{variable}{\l_@@_sticky_per_bool}
%   There is one option when \emph{parsing} the input (as opposed to
%   \emph{formatting} for output): how to deal with \cs{per}.
%    \begin{macrocode}
\keys_define:nn { siunitx / unit }
  {
    sticky-per .bool_set:N = \l_@@_sticky_per_bool
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_parsed_prop}
% \begin{variable}{\l_@@_per_bool}
% \begin{variable}{\l_@@_position_int}
%   Parsing units requires a small number of variables are available: a
%   \texttt{prop} for the parsed units themselves, a \texttt{bool} to
%   indicate if \cs{per} is active and an \texttt{int} to track how many units
%   have be parsed.
%    \begin{macrocode}
\prop_new:N \l_@@_parsed_prop
\bool_new:N \l_@@_per_bool
\int_new:N \l_@@_position_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{macro}{\@@_parse:n}
%   The main parsing function is quite simple. After initialising the variables,
%   each symbolic unit is set up. The input is then simply inserted into the
%   input stream: the symbolic units themselves then do the real work of
%   placing data into the parsing system. There is then a bit of tidying up to
%   ensure that later stages can rely on the nature of the data here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse:n #1
  {
    \prop_clear:N \l_@@_parsed_prop
    \bool_set_true:N \l_@@_parsing_bool
    \bool_set_false:N \l_@@_per_bool
    \bool_set_false:N \l_@@_test_bool
    \int_zero:N \l_@@_position_int
    #1
    \int_step_inline:nnnn 1 1 \l_@@_position_int
      { \@@_parse_finalise:n {##1} }
    \@@_parse_finalise:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_parse_add:nnnn}
%   In all cases, storing a data item requires setting a temporary \texttt{tl}
%   which will be used as the key, then using this to store the value. The
%   \texttt{tl} is  set using \texttt{x}-type expansion as this will expand the
%   unit index and any additional calculations made for this.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_add:nnnn #1#2#3#4
  {
    \tl_set:Nx \l_@@_tmp_tl { #1 - #2 }
    \prop_if_in:NVTF \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \msg_error:nnxx { siunitx } { unit / duplicate-part }
          { \exp_not:n {#1} } { \token_to_str:N #3 }
      }
      { \prop_put:NVn \l_@@_parsed_prop \l_@@_tmp_tl {#4} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_parse_prefix:Nn}
% \begin{macro}{\@@_parse_power:nnN}
% \begin{macro}{\@@_parse_qualifier:nn}
% \begin{macro}{\@@_parse_special:n}
%   Storage of the various optional items follows broadly the same pattern
%   in each case. The data to be stored is passed along with an appropriate
%   key name to the underlying storage system. The details for each type of
%   item should be relatively clear. For example, prefixes have to come before
%   their \enquote{parent} unit and so there is some adjustment to do to add
%   them to the correct unit.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_prefix:Nn #1#2
  {
    \int_set:Nn \l_@@_tmp_int { \l_@@_position_int + 1 }
    \@@_parse_add:nnnn { prefix } { \int_use:N \l_@@_tmp_int }
      {#1} {#2}
  }
\cs_new_protected:Npn \@@_parse_power:nnN #1#2#3
  {
    \tl_set:Nx \l_@@_tmp_tl
      { unit- \int_use:N \l_@@_position_int }
    \bool_lazy_or:nnTF
      {#3} { \prop_if_in_p:NV \l_@@_parsed_prop \l_@@_tmp_tl }
      {
        \@@_parse_add:nnnn { power }
          { \int_eval:n { \l_@@_position_int \bool_if:NT #3 { + 1 } } }
          {#1} {#2}
      }
      {
        \msg_error:nnxx { siunitx }
          { unit / part-before-unit } { power } { \token_to_str:N #1 }
      }
  }
\cs_new_protected:Npn \@@_parse_qualifier:nn #1#2
  {
    \tl_set:Nx \l_@@_tmp_tl
      { unit- \int_use:N \l_@@_position_int }
    \prop_if_in:NVTF \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \@@_parse_add:nnnn { qualifier }
          { \int_use:N \l_@@_position_int } {#1} {#2}
      }
      {
        \msg_error:nnnn { siunitx }
          { unit / part-before-unit } { qualifier } { \token_to_str:N #1 }
      }
  }
%    \end{macrocode}
%  Special (exceptional) items should always come before the relevant units.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_special:n #1
  {
    \@@_parse_add:nnnn { special }
      { \int_eval:n { \l_@@_position_int + 1 } }
      {#1} {#1}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_parse_unit:Nn}
%   Parsing units is slightly more involved than the other cases: this is the
%   one place where the tracking value is incremented.  If the switch
%   \cs{l_@@_per_bool} is set true then the current unit is also
%   reciprocal: this can only happen if \cs{l_@@_sticky_per_bool} is also
%   true, so only one test is required.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_unit:Nn #1#2
  {
    \int_incr:N \l_@@_position_int
    \@@_parse_add:nnnn { unit } { \int_use:N \l_@@_position_int }
      {#1} {#2}
    \bool_if:NT \l_@@_per_bool
      {
        \@@_parse_add:nnnn { per } { \int_use:N \l_@@_position_int }
          { \per } { true }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_parse_per:}
%   Storing the \cs{per} command requires adding a data item separate from
%   the power which applies: this makes later formatting much more
%   straight-forward. This data could in principle be combined with the
%   \texttt{power}, but depending on the output format required that may make
%   life  more complex. Thus this information is stored separately for later
%   retrieval. If \cs{per} is set to be \enquote{sticky} then after parsing
%   the first occurrence, any further uses are in error.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_per:
  {
    \bool_if:NTF \l_@@_sticky_per_bool
      {
        \bool_set_true:N \l_@@_per_bool
        \cs_set_protected:Npn \per
          { \msg_error:nn { siunitx } { unit / duplicate-sticky-per } }
      }
      {
        \@@_parse_add:nnnn
          { per } { \int_eval:n { \l_@@_position_int + 1 } }
          { \per } { true }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_parse_finalise:n}
%   If \cs{per} applies to the current unit, the power needs to be multiplied
%   by $-1$. That is done using an \texttt{fp} operation so that non-integer
%   powers are supported. The flag for \cs{per} is also removed as this means
%   we don't have to check that the original power was positive. To be on
%   the safe side, there is a check for a trivial power at this stage.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_finalise:n #1
  {
    \tl_set:Nx \l_@@_tmp_tl { per- #1 }
    \prop_if_in:NVT \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \prop_remove:NV \l_@@_parsed_prop \l_@@_tmp_tl
        \tl_set:Nx \l_@@_tmp_tl { power- #1 }
        \prop_get:NVNTF \l_@@_parsed_prop \l_@@_tmp_tl
          \l_@@_part_tl
          {
            \tl_set:Nx \l_@@_part_tl
              { \fp_eval:n { \l_@@_part_tl * -1 } }
            \fp_compare:nNnTF \l_@@_part_tl = 1
              { \prop_remove:NV \l_@@_parsed_prop \l_@@_tmp_tl }
              {
                \prop_put:NVV \l_@@_parsed_prop
                  \l_@@_tmp_tl \l_@@_part_tl
              }
          }
          { \prop_put:NVn \l_@@_parsed_prop \l_@@_tmp_tl { -1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_parse_finalise:}
%   The final task is to check that there is not a \enquote{dangling} power
%   or prefix: these are added to the \enquote{next} unit so are easy to
%   test for.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_finalise:
  {
    \clist_map_inline:nn { per , power , prefix }
      {
        \tl_set:Nx \l_@@_tmp_tl
          { ##1 - \int_eval:n { \l_@@_position_int + 1 } }
        \prop_if_in:NVT \l_@@_parsed_prop \l_@@_tmp_tl
          { \msg_error:nnn { siunitx } { unit / dangling-part } { ##1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Formatting parsed units}
%
% \begin{variable}
%   {
%     \l_@@_denominator_bracket_bool ,
%     \l_@@_fraction_function_tl     ,
%     \l_@@_bracket_close_tl         ,
%     \l_@@_bracket_open_tl          ,
%     \l_@@_parse_bool               ,
%     \l_@@_per_symbol_tl            ,
%     \l_@@_qualifier_mode_tl        ,
%     \l_@@_qualifier_phrase_tl
%   }
%   Set up the options which apply to formatting.
%    \begin{macrocode}
\keys_define:nn { siunitx / unit }
  {
    bracket-denominator .bool_set:N      = \l_@@_denominator_bracket_bool ,
    fraction-command    .tl_set:N        = \l_@@_fraction_function_tl     ,
    close-bracket       .tl_set:N        = \l_@@_bracket_close_tl         ,
    open-bracket        .tl_set:N        = \l_@@_bracket_open_tl          ,
    parse               .bool_set:N      = \l_@@_parse_bool               ,
    per-mode            .choice:                                          ,
    per-mode / fraction             .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_false:N \l_@@_per_symbol_bool
        \bool_set_true:N  \l_@@_powers_positive_bool
        \bool_set_true:N  \l_@@_two_part_bool
      } ,
    per-mode / power                .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_false:N \l_@@_per_symbol_bool
        \bool_set_false:N \l_@@_powers_positive_bool
        \bool_set_false:N \l_@@_two_part_bool
      } ,
    per-mode / power-positive-first .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_false:N \l_@@_per_symbol_bool
        \bool_set_false:N \l_@@_powers_positive_bool
        \bool_set_true:N  \l_@@_two_part_bool
      } ,
    per-mode / repeated-symbol      .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_true:N  \l_@@_per_symbol_bool
        \bool_set_true:N  \l_@@_powers_positive_bool
        \bool_set_false:N \l_@@_two_part_bool
      } ,
    per-mode / symbol               .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_true:N  \l_@@_per_symbol_bool
        \bool_set_true:N  \l_@@_powers_positive_bool
        \bool_set_true:N  \l_@@_two_part_bool
      } ,
    per-mode / symbol-or-fraction   .code:n =
      {
        \bool_set_true:N \l_@@_autofrac_bool
        \bool_set_true:N \l_@@_per_symbol_bool
        \bool_set_true:N \l_@@_powers_positive_bool
        \bool_set_true:N \l_@@_two_part_bool
      } ,
    per-symbol          .tl_set:N        = \l_@@_per_symbol_tl             ,
    qualifier-mode      .choice:                                           ,
    qualifier-mode / bracket        .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { bracket  } }  ,
    qualifier-mode / combine        .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { combine } }   ,
    qualifier-mode / phrase         .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { phrase } }    ,
    qualifier-mode / subscript      .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { subscript } } ,
    qualifier-phrase    .tl_set:N        = \l_@@_qualifier_phrase_tl
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_bracket_bool}
%   A flag to indicate that the unit currently under construction will require
%   brackets if a power is added.
%    \begin{macrocode}
\bool_new:N \l_@@_bracket_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_font_bool}
%   A flag to control when font wrapping is applied to the output.
%    \begin{macrocode}
\bool_new:N \l_@@_font_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_autofrac_bool        ,
%     \l_@@_powers_positive_bool ,
%     \l_@@_per_symbol_bool      ,
%     \l_@@_two_part_bool
%   }
%   Dealing with the various ways that reciprocal (\cs{per}) can be handled
%   requires a few different switches.
%    \begin{macrocode}
\bool_new:N \l_@@_autofrac_bool
\bool_new:N \l_@@_per_symbol_bool
\bool_new:N \l_@@_powers_positive_bool
\bool_new:N \l_@@_two_part_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_numerator_bool}
%   Indicates that the current unit should go into the numerator when splitting
%   into two parts (fractions or other \enquote{sorted} styles).
%    \begin{macrocode}
\bool_new:N \l_@@_numerator_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_qualifier_mode_tl}
%   For storing the text of options which are best handled by picking
%   function names.
%    \begin{macrocode}
\tl_new:N \l_@@_qualifier_mode_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_prefix_power_bool}
%   Used to determine if prefixes are converted into powers. Note that
%   while this may be set as an option \enquote{higher up}, at this point it
%   is handled as an internal switch (see the two formatting interfaces for
%   reasons).
%    \begin{macrocode}
\bool_new:N \l_@@_prefix_power_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_prefix_fp}
%   When converting prefixes to powers, the calculations are done as an
%   \texttt{fp}.
%    \begin{macrocode}
\fp_new:N \l_@@_prefix_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_current_tl, \l_@@_part_tl}
%   Building up the (partial) formatted unit requires some token list storage.
%   Each part of the unit combination that is recovered also has to be
%   placed in a token list: this is a dedicated one to leave the scratch
%   variables available.
%    \begin{macrocode}
\tl_new:N \l_@@_current_tl
\tl_new:N \l_@@_part_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_denominator_tl}
%   For fraction-like units, space is needed for the denominator as well as
%   the numerator (which is handled using \cs{l_@@_formatted_tl}).
%    \begin{macrocode}
\tl_new:N \l_@@_denominator_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_total_int}
%   The formatting routine needs to know both the total number of units and
%   the current unit. Thus an \texttt{int} is required in addition to
%   \cs{l_@@_position_int}.
%    \begin{macrocode}
\int_new:N \l_@@_total_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_format_parsed:}
% \begin{macro}{\@@_format_parsed_aux:n}
%   The main formatting routine is essentially a loop over each position,
%   reading the various parts of the unit to build up complete unit
%   combination.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_parsed:
  {
    \int_set_eq:NN \l_@@_total_int \l_@@_position_int
    \tl_clear:N \l_@@_denominator_tl
    \tl_clear:N \l_@@_formatted_tl
    \fp_zero:N \l_@@_prefix_fp
    \int_zero:N \l_@@_position_int
    \int_do_while:nNnn \l_@@_position_int < \l_@@_total_int
      {
        \bool_set_false:N \l_@@_bracket_bool
        \tl_clear:N \l_@@_current_tl
        \bool_set_false:N \l_@@_font_bool
        \bool_set_true:N \l_@@_numerator_bool
        \int_incr:N \l_@@_position_int
        \clist_map_inline:nn { prefix , unit , qualifier , power , special }
          { \@@_format_parsed_aux:n {##1} }
        \@@_format_output:
      }
    \@@_format_finalise:
  }
\cs_new_protected:Npn \@@_format_parsed_aux:n #1
  {
    \tl_set:Nx \l_@@_tmp_tl { #1 - \int_use:N \l_@@_position_int }
    \prop_get:NVNT \l_@@_parsed_prop
      \l_@@_tmp_tl \l_@@_part_tl
      { \use:c { @@_format_ #1 : } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[EXP]{\@@_format_bracket:N}
%   A quick utility function which wraps up a token list variable in brackets
%   if they are required.
%    \begin{macrocode}
\cs_new:Npn \@@_format_bracket:N #1
  {
    \bool_if:NTF \l_@@_bracket_bool
      {
        \exp_not:V \l_@@_bracket_open_tl
        \exp_not:V #1
        \exp_not:V \l_@@_bracket_close_tl
      }
      { \exp_not:V #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_format_power:}
% \begin{macro}[EXP]{\@@_format_power_aux:wTF}
% \begin{macro}
%   {
%     \@@_format_power_positive: ,
%     \@@_format_power_negative:
%   }
% \begin{macro}[EXP]{\@@_format_power_negative_aux:w}
% \begin{macro}{\@@_format_power_superscript:}
%   Formatting powers requires a test for negative numbers and depending on
%   output format requests some adjustment to the stored value. This could be
%   done using an \texttt{fp} function, but that would be slow compared to
%   a dedicated if lower-level approach based on delimited arguments.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_power:
  {
    \@@_format_font:
    \exp_after:wN \@@_format_power_aux:wTF \l_@@_part_tl - \q_stop
      { \@@_format_power_negative: }
      { \@@_format_power_positive: }
  }
\cs_new:Npn \@@_format_power_aux:wTF #1 - #2 \q_stop
  { \tl_if_empty:nTF {#1} }
%    \end{macrocode}
%   In the case of positive powers, there is little to do: add the power
%   as a subscript (must be required as the parser ensures it's $\neq 1$).
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_power_positive:
  { \@@_format_power_superscript: }
%    \end{macrocode}
%   Dealing with negative powers starts by flipping the switch used to track
%   where in the final output the current part should get added to. For the
%   case where the output is fraction-like, strip off the |~| then ensure that
%   the result is not the trivial power~$1$. Assuming all is well, addition
%   to the current unit combination goes ahead.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_power_negative:
  {
    \bool_set_false:N \l_@@_numerator_bool
    \bool_if:NTF \l_@@_powers_positive_bool
      {
        \tl_set:Nx \l_@@_part_tl
          {
            \exp_after:wN \@@_format_power_negative_aux:w
              \l_@@_part_tl \q_stop
          }
        \str_if_eq_x:nnF { \exp_not:V \l_@@_part_tl } { 1 }
          { \@@_format_power_superscript: }
      }
      { \@@_format_power_superscript: }
  }
\cs_new:Npn \@@_format_power_negative_aux:w - #1 \q_stop
  { \exp_not:n {#1} }
%    \end{macrocode}
%   Adding the power as a superscript has the slight complication that there
%   is the possibility of needing some brackets. The superscript itself uses
%   \cs{sp} as that avoids any category code issues and also allows redirection
%   at a higher level more readily.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_power_superscript:
  {
    \tl_set:Nx \l_@@_current_tl
      {
        \@@_format_bracket:N \l_@@_current_tl
        ^ { \exp_not:V \l_@@_part_tl }
      }
    \bool_set_false:N \l_@@_bracket_bool
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_format_prefix:}
% \begin{macro}{\@@_format_prefix_power:, \@@_format_prefix_symbol:}
%   Formatting for prefixes depends on whether they are to be expressed as
%   symbols or collected up to be returned as a power of $10$. The latter
%   case requires a bit of processing, which includes checking that the
%   conversion is possible and allowing for any power that applies to the
%   current unit.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_prefix:
  {
    \bool_if:NTF \l_@@_prefix_power_bool
      { \@@_format_prefix_power: }
      { \@@_format_prefix_symbol: }
  }
\cs_new_protected:Npn \@@_format_prefix_power:
  {
    \prop_get:NVNTF \l_@@_prefixes_forward_prop
      \l_@@_part_tl \l_@@_part_tl
      {
        \tl_set:Nx \l_@@_tmp_tl
          { power- \int_use:N \l_@@_position_int }
        \prop_get:NVNF \l_@@_parsed_prop
          \l_@@_tmp_tl \l_@@_tmp_tl
          { \tl_set:Nn \l_@@_tmp_tl { 1 } }
        \fp_add:Nn \l_@@_prefix_fp
          { \l_@@_tmp_tl * \l_@@_part_tl }
      }
      { \@@_format_prefix_symbol: }
  }
\cs_new_protected:Npn \@@_format_prefix_symbol:
  { \tl_set_eq:NN \l_@@_current_tl \l_@@_part_tl }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_format_qualifier:}
% \begin{macro}
%   {
%     \@@_format_qualifier_bracket :  ,
%     \@@_format_qualifier_combine:   ,
%     \@@_format_qualifier_phrase:    ,
%     \@@_format_qualifier_subscript:
%   }
%  There are various ways that a qualifier can be added to the output. The
%  idea here is to modify the \enquote{base} text appropriately and then add
%  to the current unit. In the case that a linking phrase is in use, the
%  addition of spaces means that the unit may end up ambiguous, and brackets
%  are therefore required \emph{if} there is a power. Notice that when the
%  qualifier is just treated as \enquote{text}, the auxiliary is actually
%  a no-op.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_qualifier:
  {
    \use:c { @@_format_qualifier_ \l_@@_qualifier_mode_tl : }
    \tl_put_right:NV \l_@@_current_tl \l_@@_part_tl
  }
\cs_new_protected:Npn \@@_format_qualifier_bracket:
  {
    \@@_format_font:
    \tl_set:Nx \l_@@_part_tl
      {
        \exp_not:V \l_@@_bracket_open_tl
        \exp_not:V \l_@@_font_tl { \exp_not:V \l_@@_part_tl }
        \exp_not:V \l_@@_bracket_close_tl
      }
  }
\cs_new_protected:Npn \@@_format_qualifier_combine: { }
\cs_new_protected:Npn \@@_format_qualifier_phrase:
  {
    \@@_format_font:
    \tl_set:Nx \l_@@_part_tl
      {
        \exp_not:V \l_@@_qualifier_phrase_tl
        \exp_not:V \l_@@_font_tl { \exp_not:V \l_@@_part_tl }
      }
  }
\cs_new_protected:Npn \@@_format_qualifier_subscript:
  {
    \@@_format_font:
    \tl_set:Nx \l_@@_part_tl
      {
        \c_@@_math_subscript_tl
          {
            \exp_not:V \l_@@_font_tl
              { \exp_not:V \l_@@_part_tl }
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_format_special:}
%   Any special odds and ends are handled by simply making the current
%   combination into an argument for the recovered code.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_special:
  {
    \tl_set:Nx \l_@@_current_tl
      {
        \exp_not:V \l_@@_part_tl
          { \exp_not:V \l_@@_current_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_format_unit:}
%   A very simple task: add the unit to the output currently being
%   constructed.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_unit:
  { \tl_put_right:NV \l_@@_current_tl \l_@@_part_tl }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_format_output:}
% \begin{macro}
%   {\@@_format_output_aux:, \@@_format_output_denominator:}
% \begin{macro}
%   {
%     \@@_format_output_aux:nn ,
%     \@@_format_output_aux:nV ,
%     \@@_format_output_aux:nv
%   }
%   The first step here is to make a choice based on whether the current
%   part should be stored as part of the numerator or denominator of a
%   fraction. In all cases, if the switch \cs{l_@@_numerator_bool} is
%   true then life is simple: add the current part to the numerator with
%   a standard separator
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_output:
  {
    \@@_format_font:
    \bool_set_false:N \l_@@_bracket_bool
    \use:c
      {
        @@_format_output_
        \bool_if:NTF \l_@@_numerator_bool
          { aux: }
          { denominator: }
      }
  }
\cs_new_protected:Npn \@@_format_output_aux:
  {
    \@@_format_output_aux:nV { formatted }
      \l_@@_product_tl
  }
%    \end{macrocode}
%   There are a few things to worry about at this stage if the current part
%   is in the denominator.  Powers have already been dealt with and some
%   formatting outcomes only need a branch at the final point of building
%   the entire unit. That means that there are three possible outcomes here:
%   if collecting two separate parts, add to the denominator with a product
%   separator, or if only building one token list there may be a need to use
%   a symbol separator. When the |repeated-symbol| option is in use there may
%   be a need to add a leading |1| to the output in the case where the
%   first unit is in the denominator: that can be picked up by looking for
%   empty output in combination with the flag for using a symbol in the output
%   but not a two-part strategy.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_output_denominator:
  {
    \bool_if:NTF \l_@@_two_part_bool
      {
        \bool_lazy_and:nnT
          { \l_@@_denominator_bracket_bool }
          { \bool_not_p:n { \tl_if_empty_p:N \l_@@_denominator_tl } }
          { \bool_set_true:N \l_@@_bracket_bool }
        \@@_format_output_aux:nV { denominator }
          \l_@@_product_tl
      }
      {
        \bool_lazy_and:nnT
          { \l_@@_per_symbol_bool }
          { \tl_if_empty_p:N \l_@@_formatted_tl }
          { \tl_set:Nn \l_@@_formatted_tl { 1 } }
        \@@_format_output_aux:nv { formatted }
          {
            l_@@_
            \bool_if:NTF \l_@@_per_symbol_bool
              { per_symbol }
              { product }
            _tl
          }
      }
  }
\cs_new_protected:Npn \@@_format_output_aux:nn #1#2
  {
    \tl_set:cx { l_@@_ #1 _tl }
      {
         \exp_not:v { l_@@_ #1 _tl }
         \tl_if_empty:cF { l_@@_ #1 _tl }
           { \exp_not:n {#2} }
         \exp_not:V \l_@@_current_tl
      }
  }
\cs_generate_variant:Nn \@@_format_output_aux:nn { nV , nv }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\@@_format_font:}
%   A short auxiliary which checks if the font has been applied to the
%   main part of the output: if not, add it and set the flag.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_font:
  {
    \bool_if:NF \l_@@_font_bool
      {
        \tl_set:Nx \l_@@_current_tl
          {
            \exp_not:V \l_@@_font_tl
              { \exp_not:V \l_@@_current_tl }
          }
        \bool_set_true:N \l_@@_font_bool
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\@@_format_finalise:}
% \begin{macro}
%   {
%     \@@_format_finalise_autofrac:   ,
%     \@@_format_finalise_fractional: ,
%     \@@_format_finalise_power:
%   }
%   Finalising the unit format is really about picking up the cases involving
%   fractions: these require assembly of the parts with the need to add
%   additional material in some cases
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_finalise:
  {
    \tl_if_empty:NF \l_@@_denominator_tl
      {
        \bool_if:NTF \l_@@_powers_positive_bool
          { \@@_format_finalise_fractional: }
          { \@@_format_finalise_power: }
      }
  }
%    \end{macrocode}
%   For fraction-like output, there are three possible choices and two
%   actual styles. In all cases, if the numerator is empty then it is set
%   here to |1|.  To deal with the \enquote{auto-format} case, the two
%   styles (fraction and symbol) are handled in auxiliaries: this allows both
%   to be used at the same time! Beyond that, the key here is to use a
%   single \cs{tl_set:Nx} to keep down the number of assignments.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_finalise_fractional:
  {
    \tl_if_empty:NT \l_@@_formatted_tl
      { \tl_set:Nn \l_@@_formatted_tl { 1 } }
    \bool_if:NTF \l_@@_autofrac_bool
      { \@@_format_finalise_autofrac: }
      {
        \bool_if:NTF \l_@@_per_symbol_bool
          { \@@_format_finalise_symbol: }
          { \@@_format_finalise_fraction: }
      }
  }
%    \end{macrocode}
%   For the \enquote{auto-selected} fraction method, the two other auxiliary
%   functions are used to do both forms of formatting. So that everything
%   required is available, this needs one group so that the second auxiliary
%   receives the correct input. After that it is just a case of applying
%   \cs{mathchoice} to the formatted output.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_finalise_autofrac:
  {
    \group_begin:
      \@@_format_finalise_fraction:
    \exp_args:NNNV \group_end:
    \tl_set:Nn \l_@@_tmp_tl \l_@@_formatted_tl
    \@@_format_finalise_symbol:
    \tl_set:Nx \l_@@_formatted_tl
      {
        \mathchoice
          { \exp_not:V \l_@@_tmp_tl }
          { \exp_not:V \l_@@_formatted_tl }
          { \exp_not:V \l_@@_formatted_tl }
          { \exp_not:V \l_@@_formatted_tl }
      }
  }
%    \end{macrocode}
%   When using a fraction function the two parts are now assembled.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_finalise_fraction:
  {
    \tl_set:Nx \l_@@_formatted_tl
      {
        \exp_not:V \l_@@_fraction_function_tl
          { \exp_not:V \l_@@_formatted_tl }
          { \exp_not:V \l_@@_denominator_tl }
      }
  }
\cs_new_protected:Npn \@@_format_finalise_symbol:
  {
    \tl_set:Nx \l_@@_formatted_tl
      {
        \exp_not:V \l_@@_formatted_tl
        \exp_not:V \l_@@_per_symbol_tl
        \@@_format_bracket:N \l_@@_denominator_tl
      }
  }
%    \end{macrocode}
%   In the case of sorted powers, there is a test to make sure there was
%   at least one positive power, and if so a simple join of the two parts
%   with the appropriate product.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_format_finalise_power:
  {
    \tl_if_empty:NTF \l_@@_formatted_tl
      { \tl_set_eq:NN \l_@@_formatted_tl \l_@@_denominator_tl }
      {
        \tl_set:Nx \l_@@_formatted_tl
          {
            \exp_not:V \l_@@_formatted_tl
            \exp_not:V \l_@@_product_tl
            \exp_not:V \l_@@_denominator_tl
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Pre-defined unit components}
%
% Quite a number of units can be predefined: while this is a code-level module,
% there is little point having a unit parser which does not start off able to
% parse any units!
%
% \begin{macro}
%   {
%     \kilogram ,
%     \metre    ,
%     \meter    ,
%     \mole     ,
%     \kelvin   ,
%     \candela  ,
%     \second   ,
%     \ampere
%   }
%   The basic SI units: technically the correct spelling is \cs{metre} but
%   US users tend to use \cs{meter}.
%    \begin{macrocode}
\siunitx_unit_set:Nn \kilogram { \kilo \gram }
\siunitx_unit_set:Nn \metre    { m }
\siunitx_unit_set:Nn \meter    { \metre }
\siunitx_unit_set:Nn \mole     { mol }
\siunitx_unit_set:Nn \second   { s }
\siunitx_unit_set:Nn \ampere   { A }
\siunitx_unit_set:Nn \kelvin   { K }
\siunitx_unit_set:Nn \candela  { cd }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\gram}
%   The gram is an odd unit as it is needed for the base unit kilogram.
%    \begin{macrocode}
\siunitx_unit_set:Nn \gram { g }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \yocto ,
%     \zepto ,
%     \atto  ,
%     \femto ,
%     \pico  ,
%     \nano  ,
%     \micro ,
%     \milli ,
%     \centi ,
%     \deci
%  }
%   The various SI multiple prefixes are defined here: first the small
%   ones.
%    \begin{macrocode}
\siunitx_unit_prefix_set:Nnn \yocto { y } { -24 }
\siunitx_unit_prefix_set:Nnn \zepto { z } { -21 }
\siunitx_unit_prefix_set:Nnn \atto  { a } { -18 }
\siunitx_unit_prefix_set:Nnn \femto { f } { -15 }
\siunitx_unit_prefix_set:Nnn \pico  { p } { -12 }
\siunitx_unit_prefix_set:Nnn \nano  { n } { -9 }
\siunitx_unit_prefix_set:Nnn \micro { \unitsymbol { micro } } { -6 }
\siunitx_unit_prefix_set:Nnn \milli { m } { -3 }
\siunitx_unit_prefix_set:Nnn \centi { c } { -2 }
\siunitx_unit_prefix_set:Nnn \deci  { d } { -1 }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \deca  ,
%     \deka  ,
%     \hecto ,
%     \kilo  ,
%     \mega  ,
%     \giga  ,
%     \tera  ,
%     \peta  ,
%     \exa   ,
%     \zetta ,
%     \yotta
%   }
%   Now the large ones.
%    \begin{macrocode}
\siunitx_unit_prefix_set:Nnn \deca  { da } { 1 }
\siunitx_unit_prefix_set:Nnn \deka  { da } { 1 }
\siunitx_unit_prefix_set:Nnn \hecto { h }  { 2 }
\siunitx_unit_prefix_set:Nnn \kilo  { k }  { 3 }
\siunitx_unit_prefix_set:Nnn \mega  { M }  { 6 }
\siunitx_unit_prefix_set:Nnn \giga  { G }  { 9 }
\siunitx_unit_prefix_set:Nnn \tera  { T }  { 12 }
\siunitx_unit_prefix_set:Nnn \peta  { P }  { 15 }
\siunitx_unit_prefix_set:Nnn \exa   { E }  { 18 }
\siunitx_unit_prefix_set:Nnn \zetta { Z }  { 21 }
\siunitx_unit_prefix_set:Nnn \yotta { Y }  { 24 }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \becquerel     ,
%     \degreeCelsius ,
%     \coulomb       ,
%     \farad         ,
%     \gray          ,
%     \hertz         ,
%     \henry         ,
%     \joule         ,
%     \katal         ,
%     \lumen         ,
%     \lux
%  }
%    Named derived units: first half of alphabet.
%    \begin{macrocode}
\siunitx_unit_set:Nn \becquerel { Bq }
\siunitx_unit_set:Nn \degreeCelsius
  { \ensuremath { { } ^ { \circ } } \kern -\scriptspace C }
\siunitx_unit_set:Nn \coulomb   { C }
\siunitx_unit_set:Nn \farad     { F }
\siunitx_unit_set:Nn \gray      { Gy }
\siunitx_unit_set:Nn \hertz     { Hz }
\siunitx_unit_set:Nn \henry     { H }
\siunitx_unit_set:Nn \joule     { J }
\siunitx_unit_set:Nn \katal     { kat }
\siunitx_unit_set:Nn \lumen     { lm }
\siunitx_unit_set:Nn \lux       { lx }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \newton    ,
%     \ohm       ,
%     \pascal    ,
%     \radian    ,
%     \siemens   ,
%     \sievert   ,
%     \steradian ,
%     \tesla     ,
%     \volt      ,
%     \watt      ,
%     \weber
%  }
%    Named derived units: second half of alphabet.
%    \begin{macrocode}
\siunitx_unit_set:Nn \newton    { N }
\siunitx_unit_set:Nn \ohm       { \ensuremath { \Omega } }
\siunitx_unit_set:Nn \pascal    { Pa }
\siunitx_unit_set:Nn \radian    { rad }
\siunitx_unit_set:Nn \siemens   { S }
\siunitx_unit_set:Nn \sievert   { Sv }
\siunitx_unit_set:Nn \steradian { sr }
\siunitx_unit_set:Nn \tesla     { T }
\siunitx_unit_set:Nn \volt      { V }
\siunitx_unit_set:Nn \watt      { W }
\siunitx_unit_set:Nn \weber     { Wb }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \day       ,
%     \hectare   ,
%     \hour      ,
%     \litre     ,
%     \liter     ,
%     \minute    ,
%     \tonne
%  }
%   Non-SI, but accepted for general use. Once again there are two
%   spellings, here for litre and with different output in this case.
%    \begin{macrocode}
\siunitx_unit_set:Nn \day     { d }
\siunitx_unit_set:Nn \hectare { ha }
\siunitx_unit_set:Nn \hour    { h }
\siunitx_unit_set:Nn \litre   { L }
\siunitx_unit_set:Nn \liter   { \litre }
\siunitx_unit_set:Nn \minute  { min }
\siunitx_unit_set:Nn \tonne   { t }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \arcminute ,
%     \arcsecond ,
%     \degree
%  }
%   Arc units: again, non-SI, but accepted for general use.
%    \begin{macrocode}
\siunitx_unit_set:Nn \arcminute { \ensuremath { ^ { \prime } } }
\siunitx_unit_set:Nn \arcsecond { \ensuremath { ^ { \prime \prime } } }
\siunitx_unit_set:Nn \degree    { \ensuremath { ^ { \circ } } }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\astronomicalunit, \atomicmassunit, \dalton, \electronvolt}
%   A few units based on physical measurements exist: these ones are accepted
%   for use with the International System.
%    \begin{macrocode}
\siunitx_unit_set:Nn \astronomicalunit { ua }
\siunitx_unit_set:Nn \atomicmassunit   { u }
\siunitx_unit_set:Nn \dalton           { Da }
\siunitx_unit_set:Nn \electronvolt     { eV }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\nuaction, \numass, \nuspeed, \nutime}
%   Natural units based on physical constants.
%    \begin{macrocode}
\siunitx_unit_set:Nn \nuaction { \ensuremath { \mathit { \hbar } } }
\siunitx_unit_set:Nx \numass
  {
    \exp_not:N \ensuremath
      {
        \exp_not:N \mathit { m }
          \c_@@_math_subscript_tl { \exp_not:N \mathrm { e } }
      }
  }
\siunitx_unit_set:Nx \nuspeed
  {
    \exp_not:N \ensuremath
      { \exp_not:N \mathit { c } \c_@@_math_subscript_tl { 0 } }
  }
\siunitx_unit_set:Nn \nutime
  { \numass \per \numass \per \nuspeed \squared }
%    \end{macrocode}
% \end{macro}
% \begin{macro}
%   {
%     \auaction ,
%     \aucharge ,
%     \auenergy ,
%     \aulength ,
%     \aumass   ,
%     \autime   ,
%     \bohr     ,
%     \hartree
%   }
%   Atomic units based on physical constants.
%    \begin{macrocode}
\siunitx_unit_set:Nn \auaction { \ensuremath { \mathit { \hbar } } }
\siunitx_unit_set:Nn \aucharge { \ensuremath { \mathit { e } } }
\siunitx_unit_set:Nx \auenergy
  {
    \exp_not:N \ensuremath
      {
        \exp_not:N \mathit { E }
          \c_@@_math_subscript_tl { \exp_not:N \mathrm { h } }
      }
  }
\siunitx_unit_set:Nx \aulength
  {
    \exp_not:N  \ensuremath
      { \exp_not:N \mathit { a } \c_@@_math_subscript_tl { 0 } }
  }
\siunitx_unit_set:Nx \aumass
  {
    \exp_not:N \ensuremath
      {
        \exp_not:N \mathit { m }
          \c_@@_math_subscript_tl { \exp_not:N \mathrm { e } }
      }
  }
\siunitx_unit_set:Nn \autime   { \auaction \per \auenergy }
\siunitx_unit_set:Nn \bohr     { \aulength }
\siunitx_unit_set:Nn \hartree  { \auenergy }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \angstrom          ,
%     \bar               ,
%     \barn              ,
%     \bel               ,
%     \decibel           ,
%     \knot              ,
%     \millimetremercury ,
%     \nauticalmile      ,
%     \neper
%  }
%   There are then some day-to-day units which are accepted for use
%   with SI, but are not part of the official specification.
%    \begin{macrocode}
\siunitx_unit_set:Nn \angstrom          { \mbox { \AA } }
\siunitx_unit_set:Nn \bar               { bar }
\siunitx_unit_set:Nn \barn              { b }
\siunitx_unit_set:Nn \bel               { B }
\siunitx_unit_set:Nn \decibel           { \deci \bel }
\siunitx_unit_set:Nn \knot              { kn }
\siunitx_unit_set:Nn \millimetremercury { mmHg }
\siunitx_unit_set:Nn \nauticalmile      { M }
\siunitx_unit_set:Nn \neper             { Np }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}
%   {
%     \dyne    ,
%     \erg     ,
%     \gal     ,
%     \gauss   ,
%     \maxwell ,
%     \oersted ,
%     \phot    ,
%     \poise   ,
%     \stilb   ,
%     \stokes
%  }
%   \textsc{cgs} units: similar to the set immediately above, these may be used
%   for specific applications.
%    \begin{macrocode}
\siunitx_unit_set:Nn \dyne    { dyn  }
\siunitx_unit_set:Nn \erg     { erg }
\siunitx_unit_set:Nn \gal     { Gal }
\siunitx_unit_set:Nn \gauss   { G }
\siunitx_unit_set:Nn \maxwell { Mx }
\siunitx_unit_set:Nn \oersted { Oe }
\siunitx_unit_set:Nn \phot    { ph }
\siunitx_unit_set:Nn \poise   { P }
\siunitx_unit_set:Nn \stilb   { sb }
\siunitx_unit_set:Nn \stokes  { St }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\percent}
%   For percent, the raw character is the most flexible way of handling output.
%    \begin{macrocode}
\siunitx_unit_set:Nn \percent  { \char "25 ~ }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\square, \cubic}
%  Basic powers which come before the unit.
%    \begin{macrocode}
\siunitx_unit_power_set:NnN \square { 2 } \c_true_bool
\siunitx_unit_power_set:NnN \cubic  { 3 } \c_true_bool
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\squared, \cubed}
%   Basic powers which come after the unit.
%    \begin{macrocode}
\siunitx_unit_power_set:NnN \squared { 2 } \c_false_bool
\siunitx_unit_power_set:NnN \cubed   { 3 } \c_false_bool
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnnn { siunitx } { unit / dangling-part }
  { Found~#1~part~with~no~unit. }
  {
    Each~#1~part~must~be~associated~with~a~unit:~a~#1~part~was~found~
    but~no~following~unit~was~given.
  }
\msg_new:nnnn { siunitx } { unit / duplicate-part }
  { Duplicate~#1~part:~#2. }
  {
    Each~unit~may~have~only~one~#1:\\
    the~additional~#1~part~'#2'~will~be~ignored.
  }
\msg_new:nnnn { siunitx } { unit / duplicate-sticky-per }
  { Duplicate~\token_to_str:N \per. }
  {
    When~the~'sticky-per'~option~is~active,~only~one~
    \token_to_str:N \per \  may~appear~in~a~unit.
  }
\msg_new:nnnn { siunitx } { unit / part-before-unit }
  { Found~#1~part~before~first~unit:~#2. }
  {
    The~#1~part~'#2'~must~follow~after~a~unit:~
    it~cannot~appear~before~any~units~and~will~therefore~be~ignored.
  }
%    \end{macrocode}
%
% \subsection{Standard settings for module options}
%
% Some of these follow naturally from the point of definition
% (\emph{e.g.}~boolean variables are always |false| to begin with),
% but for clarity everything is set here.
%    \begin{macrocode}
\keys_set:nn { siunitx / unit }
  {
    bracket-denominator = true          , % (
    close-bracket       = )             ,
    font-command        = \mathrm       ,
    fraction-command    = \frac         ,
    open-bracket        = (             , % )
    parse               = true          ,
    per-mode            = power         ,
    per-symbol          = /             ,
    product             = \,            ,
    qualifier-mode      = subscript     ,
    qualifier-phrase    = \             ,
    sticky-per          = false
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \begin{thebibliography}{1}
%
%   \bibitem{BIPM}
%     \emph{The International System of Units (SI)},
%     \url{http://www.bipm.org/en/si/}.
%
%   \bibitem{SI:2.1}
%     \emph{SI base units},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter2/2-1/}.
%
%   \bibitem{SI:2.2.2}
%     \emph{Units with special names and symbols; units that
%       incorporate special names and symbols},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter2/2-2/2-2-2.html}.
%
%   \bibitem{SI:3.1}
%     \emph{SI Prefixes},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter3/prefixes.html}.
%
%   \bibitem{SI:4.1.T6}
%     \emph{Non-SI units accepted for use with the International
%       System of Units},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter4/table6.html}.
%
%   \bibitem{SI:4.1.T7}
%     \emph{Non-SI units whose values in SI units must be obtained
%       experimentally},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter4/table7.html}.
%
%   \bibitem{SI:4.1.T8}
%     \emph{Other non-SI units},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter4/table8.html}.
%
%   \bibitem{SI:4.1.T9}
%     \emph{Non-SI units associated with the CGS and the CGS-Gaussian
%       system of units},
%     \url{http://www.bipm.org/en/si/si_brochure/chapter4/table8.html}.
%
% \end{thebibliography}
%
% \PrintIndex
