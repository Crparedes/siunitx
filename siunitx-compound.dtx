% \iffalse meta-comment
%
% File: siunitx-compound.dtx Copyright (C) 2018 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    https://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    https://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{siunitx.sty}
%
% \title{^^A
%   \pkg{siunitx-quantity} -- Multi-part numbers^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{siunitx-compound} implementation}
%
% Start the \pkg{DocStrip} guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 \pkg{DocStrip} convention): only
% internal material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_compound>
%    \end{macrocode}
%
% \begin{variable}{\l_@@_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\tl_new:N \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}
%   {
%     \l_@@_input_product_tl  ,
%     \l_@@_input_quotient_tl
%   }
%    \begin{macrocode}
\keys_define:nn { siunitx }
  {
    input-product  .tl_set:N =
      \l_@@_input_product_tl ,
    input-quotient .tl_set:N =
      \l_@@_input_quotient_tl
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\@@_fraction:nn}
%   For containing the fraction function used in output.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_fraction:nn #1#2 { }
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}
%   {
%     \l_@@_output_product_tl  ,
%     \l_@@_quotient_mode_tl   ,
%     \l_@@_quotient_symbol_tl
%   }
%    \begin{macrocode}
\keys_define:nn { siunitx }
  {
    fraction-function .code:n = 
      \cs_set_protected:Npn \@@_fraction:nn ##1##2
        { #1 {##1} {##2} } ,
    output-product  .tl_set:N =
      \l_@@_output_product_tl ,
    quotient-mode .choices:nn =
     { evaluate , fraction , symbol }
     { \tl_set_eq:NN \l_@@_quotient_mode_tl \l_keys_choice_tl } ,
    quotient-symbol .tl_set:N =
      \l_@@_quotient_symbol_tl
  }
\tl_new:N \l_@@_quotient_mode_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_input_tl}
%   Stored for error reporting.
%    \begin{macrocode}
\tl_new:N \l_@@_input_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_@@_arg_tl, \l_@@_token_tl}
%   To allow search-and-replace operations.
%    \begin{macrocode}
\tl_new:N \l_@@_arg_tl
\tl_new:N \l_@@_token_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\siunitx_compound_number:n}
% \begin{macro}{\@@_number:nn}
% \begin{macro}{\@@_number_aux:w}
% \begin{macro}{\@@_number_aux:nnn}
% \begin{macro}{\@@_number_product:n, \@@_number_quotient:n}
% \begin{macro}{\@@_number_product:nn, \@@_number_quotient:nn}
%   To deal with multi-part numbers, the same approach is employed here
%   as for the exponent token in a single number. First, turn all possible
%   tokens into the first possible one, then use a one-shot split on that
%   token.
%   \begin{macrocode}
\cs_new_protected:Npn \siunitx_compound_number:n #1
  {
    \tl_set:Nn \l_@@_input_tl {#1}
    \@@_number:nn { product } {#1}
  }
\cs_new_protected:Npn \@@_number:nn #1#2
  {
    \tl_if_empty:cTF { l_@@_input_ #1 _tl }
      { \use:c { @@_number_ #1 :n } {#2} }
      {
        \tl_set:Nx \l_@@_token_tl
          { \tl_head:v { l_@@_input_ #1 _tl } }
       \tl_set:Nn \l_@@_arg_tl {#2}
       \tl_map_inline:cn { l_@@_input_ #1 _tl }
          {
            \tl_replace_all:NnV \l_@@_arg_tl
              {##1} \l_@@_token_tl
          }
        \use:x
          {
            \cs_set_protected:Npn
              \exp_not:N \@@_number_aux:w
              ####1 \exp_not:V \l_@@_token_tl
              ####2 \exp_not:V \l_@@_token_tl
              ####3 \exp_not:N \q_stop
          }
            { \@@_number_aux:nnn {#1} {##1} {##2} }
        \use:x
          {
            \@@_number_aux:w
              \exp_not:V \l_@@_arg_tl
              \exp_not:V \l_@@_token_tl \exp_not:N \q_nil
              \exp_not:V \l_@@_token_tl \exp_not:N \q_stop
          }
      }
  }
\cs_new_protected:Npn \@@_number_aux:w { }
%    \end{macrocode}
%   At this stage, the number may be a single part or may have been split.
%   As the next step depends on what we are searching for, the generic code
%   hands off to specific auxiliaries.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_number_aux:nnn #1#2#3
  {
    \quark_if_nil:nTF {#3}
      { \use:c { @@_number_ #1 :n } {#2} }
      {
        \bool_lazy_or:nnTF
          { \tl_if_blank_p:n {#2} }
          { \tl_if_blank_p:n {#3} }
          {
            \msg_error:nnx { siunitx } { malformed-compound-number }
              { \exp_not:V \l_@@_input_tl }
          }
          { \use:c { @@_number_ #1 :nn } {#2} {#3} }
       }
  }
%    \end{macrocode}
%   For a single product, simply pass the \enquote{inner} part to the quotient
%   code. For a single quotient, we are done: it's a single number.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_number_product:n #1
  { \@@_number:nn { quotient } {#1} }
\cs_new_protected:Npn \@@_number_quotient:n #1
  {
    \siunitx_number_format:nN {#1} \l_@@_tmp_tl
    \siunitx_print:nV { number } \l_@@_tmp_tl
  }
%    \end{macrocode}
%   For a product part, we need to deal with the possibility of a quotient,
%   then insert the symbol, then 
%    \begin{macrocode}
\cs_new_protected:Npn \@@_number_product:nn #1#2
  {
    \@@_number:nn { quotient } {#1}
    \exp_args:Nx \siunitx_print:nn { number }
      { \exp_not:V \l_@@_output_product_tl }
    \use:x
      {
        \@@_number_aux:w
          \exp_not:n {#2}
          \exp_not:V \l_@@_token_tl \exp_not:N \q_nil
          \exp_not:V \l_@@_token_tl \exp_not:N \q_stop
      }
  }
\cs_new_protected:Npn \@@_number_quotient:nn #1#2
  {
    \use:c { @@_number_quotient _ \l_@@_quotient_mode_tl :nn }
      {#1} {#2}
  }
\cs_new_protected:Npn \@@_number_quotient_evaluate:nn #1#2
  {
    \exp_args:Nx \siunitx_number_format:nN
      { \fp_eval:n { (#1) / (#2) } } \l_@@_tmp_tl
    \siunitx_print:nV { number } \l_@@_tmp_tl
  }
\cs_new_protected:Npn \@@_number_quotient_fraction:nn #1#2
  {
  }
\cs_new_protected:Npn \@@_number_quotient_symbol:nn #1#2
  {
    \siunitx_number_format:nN {#1} \l_@@_tmp_tl
    \siunitx_print:nV { number } \l_@@_tmp_tl
    \siunitx_print:nV { number } \l_@@_quotient_symbol_tl
    \siunitx_number_format:nN {#2} \l_@@_tmp_tl
    \siunitx_print:nV { number } \l_@@_tmp_tl
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnnn { siunitx } { malformed-compound-number }
  { Invalid~compound~number~'#1'. }
  { The~input~'#1'~could~not~be~parsed~as~a~compound~number. }
%    \end{macrocode}
%
% \subsection{Standard settings for module options}
%
% Some of these follow naturally from the point of definition
% (\foreign{e.g.}~boolean variables are always |false| to begin with),
% but for clarity everything is set here.
%    \begin{macrocode}
\keys_set:nn { siunitx }
  {
    fraction-function = \frac  ,
    input-product     = x      ,
    input-quotient    = /      ,
    output-product    = \times ,
    quotient-mode     = symbol ,
    quotient-symbol   = /
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex