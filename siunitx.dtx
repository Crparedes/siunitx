% \iffalse meta-comment
% !TEX program  = pdflatex
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
The siunitx package --- A comprehensive (SI) units package
Maintained by Joseph Wright
E-mail: joseph.wright@morningstar2.co.uk
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Typesetting values with units requires care to ensure that the
combined mathematical meaning of the value plus unit combination
is clear.  In particular, the SI units system lays down a
consistent set of units with rules on how these are to be used.
However, different countries and publishers have differing
conventions on the exact appearance of numbers (and units).

The siunitx package provides a set of tools for authors to 
typeset numbers and units in a consistent way.  The package has
an extended set of configuration options which make it possible 
to follow varying typographic conventions with the same input
syntax.  The package includes automated processing of numbers
and units, and the ability to control tabular alignment of
numbers.

A number of LaTeX packages have been developed in the past for
formatting units: SIunits, sistyle, unitsdef, units, fancyunits 
and fancynum.  Support for users of all of these packages is 
available as emulation modules in siunitx.  In addition, siunitx
can carry out many of the functions of the dcolumn, rccol and 
numprint packages
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
---------------------------------------------------------------
The siunitx package --- A comprehensive (SI) units package
Maintained by Joseph Wright
E-mail: joseph.wright@morningstar2.co.uk
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
---------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2008-2009 by
  Joseph Wright <joseph.wright@morningstar2.co.uk>

It may be distributed and/or modified under the conditions of
the LaTeX Project Public License (LPPL), either version 1.3c of
this license or (at your option) any later version.  The latest
version of this license is in the file:

   http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
  Joseph Wright.

This work consists of the file  siunitx.dtx
          and the derived files siunitx.pdf,
                                siunitx.sty and
                                siunitx.ins.

\endpostamble
\usedir{tex/latex/siunitx}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/siunitx}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/siunitx}
\generate{
  \file{README.txt}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver|package>
\RequirePackage{expl3}
\GetIdInfo$Id$
  {A comprehensive (SI) units package}
%</driver|package>
%<*driver>
%\fi
\ProvidesFile{\filename.\filenameext}
  [\filedate\space v\fileversion\space\filedescription]
%\iffalse
\documentclass[full]{l3doc}
\usepackage{helvet,mathpazo,siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% 
%\title{^^A
%  \textsf{siunitx} --- A comprehensive (SI) units package\thanks{^^A
%    This file describes version \fileversion, last revised 
%    \filedate.^^A
%  }^^A
%}
%\author{^^A
%  Joseph Wright\thanks{E-mail: joseph.wright@morningstar2.co.uk}^^A
%}
%\date{Released \filedate}
%
%\maketitle
%
%\changes{v1.0}{2008/06/15}{First official release}
%\changes{v1.1}{2008/09/28}{Package extended to a greater range of unit
%  types}
%\changes{v1.2}{2009/01/22}{Correct handling for ranges of numbers 
%  added}
%\changes{v2.0}{2009/06/29}{Complete re-write of package to add many new
%  features}
%  
%\begin{abstract}
% Typesetting values with units requires care to ensure that the
% combined mathematical meaning of the value plus unit combination is
% clear.  In particular, the SI units system lays down a consistent
% set of units with rules on how these are to be used.  However,
% different countries and publishers have differing conventions on
% the exact appearance of numbers (and units).
%
% The \pkg{siunitx} package provides a set of tools for authors
% to typeset numbers and units in a consistent way.  The package has an
% extended set of configuration options which make it possible to 
% follow varying typographic conventions with the same input syntax.  
% The package includes automated processing of numbers and units, and
% the ability to control tabular alignment of numbers.
%
% A number of \LaTeX\ packages have been developed in the past for
% formatting units: \pkg{SIunits}, \pkg{SIstyle}, 
% \pkg{unitsdef}, \pkg{units}, \pkg{fancyunits} and 
% \pkg{fancynum}. Support for users of all of these packages is 
% available as emulation modules in \pkg{siunitx}. In addition, 
% \pkg{siunitx} can carry out many of the functions of the
% \pkg{dcolumn}, \pkg{rccol} and \pkg{numprint} packages.
%\end{abstract}
%
%\begin{multicols}{2}
%  \tableofcontents
%\end{multicols}
%
%\begin{documentation}
%
%\end{documentation}
%
%\begin{implementation}
%
%\section{Implementation}
%
% Most of the code here is \LaTeX3, but there are some parts which need
% to use \LaTeXe functions to work correctly. 
%
%\subsection{Preliminaries}
%
% The usual preliminaries.  
%    \begin{macrocode}
%<*package>
\ProvidesExplPackage
  {\filename}{\filedate}{\fileversion}{\filedescription}
%    \end{macrocode}
%    
%\begin{macro}{\siunitx_load_check:}
%\begin{macro}[aux]{\siunitx_load_check_aux:n}
% There are also a number of packages that are incompatible with
% \pkg{siunitx}. These are all checked for next.  Some of the 
% incompatible packages will not raise an error if loaded after 
% \pkg{siunitx}.  So a test is made at the beginning of the 
% document as well. The message for this may be needed immediately, so
% it is created here not with the other messages.
%    \begin{macrocode}
\msg_new:nnnn { siunitx } { incompatible-package } {%
  Package `#1' incompatible.%
}{%
  The #1 package and siunitx are incompatible.\\%
  Use the `emulate=#1' package option when loading siunitx.%
}
\cs_new_nopar:Nn \siunitx_load_check: {
  \clist_map_function:nN { SIunits, sistyle, siunits, SIstyle }
    \siunitx_load_check_aux:n
}

\cs_new_nopar:Nn \siunitx_load_check_aux:n {
  \group_begin:
    \@ifpackageloaded {#1} {
      \msg_error:nnx { siunitx } { incompatible-package } {#1}
    } {}
  \group_end:
}
\clist_map_function:nN 
  { SIunits, sistyle, siunits, SIstyle, unitsdef, fancyunits }
  \siunitx_load_check_aux:n
\AtBeginDocument { \siunitx_load_check: } 
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
% Now load the support packages.
%    \begin{macrocode}
\RequirePackage{ 
  amstext,
  array,
  keys3,
  xparse
} 
%    \end{macrocode}
%    
%\begin{macro}{\siunitx_tmp:w}
%\begin{macro}{\l_siunitx_tmp_tl}
% Scratch items.
%    \begin{macrocode}
\cs_new:Npn \siunitx_tmp:w { }
\tl_new:N \l_siunitx_tmp_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_error_bool}
%\begin{macro}{\siunitx_error:nxx}
%\begin{macro}{\siunitx_error:nx}
%\begin{macro}{\siunitx_error:n}
% General-purpose functions for throwing errors.
%    \begin{macrocode}
\bool_new:N \l_siunitx_error_bool
\cs_new:Nn \siunitx_error:nxx {
  \bool_set_true:N \l_siunitx_error_bool
  \msg_error:nnxx { siunitx } {#1} {#2} {#3}
}
\cs_new:Nn \siunitx_error:nx {
  \siunitx_error:nxx {#1} {#2} { }
}
\cs_new:Nn \siunitx_error:n {
  \siunitx_error:nxx {#1} { } { }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%    
%\begin{macro}{\siunitx_encoding_ts_one:}
% Some of the \texttt{TS1} encoding is needed to provide symbols in 
% text mode. If the user has not loaded the encoding themselves, it is
% done here.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_encoding_ts_one: { 
  \cs_if_free:cT { T@TS1 } {
    \DeclareFontEncoding{TS1}{}{}%
    \DeclareFontSubstitution{TS1}{cmr}{m}{n}%
  }
}
\AtBeginDocument { \siunitx_encoding_ts_one: }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_siunitx_minus_tl}
% To allow the correct symbol to appear in text mode: this is the same
% as \cs{textminus} from \pkg{textcomp}.
%    \begin{macrocode}
\DeclareTextSymbolDefault \c_siunitx_minus_tl { TS1 }
\DeclareTextSymbol \c_siunitx_minus_tl { TS1 } { 61 }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\c_siunitx_mu_text_tl}
% The lack of an upright mu has to be sorted out.
%    \begin{macrocode}
\DeclareTextSymbol \c_siunitx_mu_text_tl { TS1 } { 181 }
\DeclareTextSymbolDefault \c_siunitx_mu_text_tl { TS1 }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_upgreek_check:}
%\begin{macro}{\c_siunitx_mu_maths_tl}
% For maths mode, there is a need for some care as there are a limited
% number of maths fonts available.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_upgreek_check: { 
  \@ifpackageloaded { upgreek } {
    \cs_set_eq:NN \c_siunitx_mu_maths_tl \ipmu
  }{
    \DeclareFontFamily { OML } { eur } { \skewchar \font 127 }
    \DeclareFontShape { OML } { eur } { m } { n } 
      { <-6> eurm5 <6-8> eurm7 <8-> eurm10 } { }
    \DeclareSymbolFont { siunitx_symbol } { OML } { eur } { m } { n }
    \DeclareMathSymbol \c_siunitx_mu_maths_tl \mathord 
      { siunitx_symbol } { 22 }
  }
}
\AtBeginDocument { \siunitx_upgreek_check: }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Font detection}
%
% A number of controls and tests are needed to control the font used
% for output.  The detection routines set up various functions which can
% then be used inside the \cs{text} macro from the \pkg{amstext}
% package.  By carrying out the changes outside maths mode, bold can
% reliably be applied to maths output.
% 
%\begin{macro}{\c_siunitx_mathsf_int}
%\begin{macro}{\c_siunitx_mathtt_int}
%\begin{macro}{\siunitx_set_maths_fam:n}
% The detection routine needs some basic data about the sans serif and
% monospaced fonts in use.  This is collected up at the start of the 
% document. The families used can change between here and the start of 
% the document. This is run as a hook onto \cs{document}, rather than
% using \cs{AtBeginDocument} as it has to come after anything that
% \pkg{fontspec} does (nasty errors arise otherwise). 
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_set_maths_fam:n {
  \group_begin:
    \hbox_set:Nn \l_tmpa_box {
      \ensuremath {
        \use:c { math #1 } {
          \expandafter \global \expandafter \chardef % Sort out!
            \csname c_siunitx_math #1 _int \endcsname \fam \relax       
        }
      }
    }
  \group_end:
}
\tl_put_right:Nn \document {
  \siunitx_set_maths_fam:n {sf}
  \siunitx_set_maths_fam:n {tt}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_font_set_text_fam:n}
%\begin{macro}{\c_siunitx_textsf_tl}
%\begin{macro}{\c_siunitx_texttt_tl}
% The text families are done in a somewhat different manner: there are 
% no issues with \cs{AtBeginDocument}, luckily. The need to define 
% new macros here arises as \cs{sfdefault} and \cs{ttdefault} are 
% \cs{long}, whereas \cs{f@family} is not.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_set_text_fam:n {
  \tl_new:c { c_siunitx_text #1 _tl }
  \tl_set:cx { c_siunitx_text #1 _tl } { \use:c { #1 default } }
}
\AtBeginDocument{
  \siunitx_set_text_fam:n {sf}
  \siunitx_set_text_fam:n {tt}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_detect_bold_bool}
%\begin{macro}{\l_siunitx_detect_display_maths_bool}
%\begin{macro}{\l_siunitx_detect_family_bool}
%\begin{macro}{\l_siunitx_detect_inline_bold_bool}
%\begin{macro}{\l_siunitx_detect_italic_bool}
%\begin{macro}{\l_siunitx_detect_mode_bool}
% Font detection is all about creating switches, with just a little
% gloss for \texttt{detect-all} and \texttt{detect-none}.
%    \begin{macrocode}
\keys_define:nn { siunitx } {
  detect-all .choice:,
  detect-all .default:n = true,
  detect-all / false .meta:n = {
    detect-bold   = false,
    detect-family = false,
    detect-italic = false,
    detect-mode   = false
  },
  detect-all / true .meta:n = {
    detect-bold   = true,
    detect-family = true,
    detect-italic = true,
    detect-mode   = true
  },
  detect-bold .set_bool:N          = \l_siunitx_detect_bold_bool,
  detect-display-math .set_bool:N  = 
    \l_siunitx_detect_display_maths_bool,
  detect-display-maths .set_bool:N = 
    \l_siunitx_detect_display_maths_bool,
  detect-family .set_bool:N        = \l_siunitx_detect_family_bool,
  detect-inline-bold .choice:,
  detect-inline-bold .value_required:,
  detect-inline-bold / math  .set_bool:N = 
    \l_siunitx_detect_inline_bold_bool,
  detect-inline-bold / maths .set_bool:N = 
    \l_siunitx_detect_inline_bold_bool,
  detect-inline-bold / text .set_bool_inverse:N = 
    \l_siunitx_detect_inline_bold_bool, 
  detect-italic .set_bool:N        = \l_siunitx_detect_italic_bool,
  detect-mode .set_bool:N          = \l_siunitx_detect_mode_bool,
  detect-none .choice:,
  detect-none .default:n = true,
  detect-none / false .meta:n = {
    detect-bold   = true,
    detect-family = true,
    detect-italic = true,
    detect-mode   = true
  },
  detect-none / true .meta:n = {
    detect-bold   = false,
    detect-family = false,
    detect-italic = false,
    detect-mode   = false
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_font_set_bool}
%\begin{macro}{\l_siunitx_font_maths_mode_bool}
% The internals of the package need a number of switches to track what
% is happening.
%    \begin{macrocode}
\bool_new:N \l_siunitx_font_set_bool
\bool_new:N \l_siunitx_font_maths_mode_bool
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_font_family_tl}
% Also some token storage.
%    \begin{macrocode}
\tl_new:N \l_siunitx_font_family_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_font_bold:}
%\begin{macro}{\siunitx_font_italic:}
% These could be token lists or functions!
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_font_bold: { }
\cs_new_nopar:Nn \siunitx_font_italic: { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_detect_font:}
% The main font-setting macro is a control point for the other
% functions.  Nesting font-control should not happen, so the first
% test is to ensure this is not happening.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font: {
  \bool_if:NF \l_siunitx_font_set_bool {
    \siunitx_detect_font_init:
    \bool_if:NT \l_siunitx_detect_bold_bool {
      \siunitx_detect_font_bold:
    }
    \bool_if:NT \l_siunitx_detect_family_bool {
      \siunitx_detect_font_family:
    }
    \bool_if:NT \l_siunitx_detect_italic_bool {
      \siunitx_detect_font_italic:
    }
    \bool_if:NT \l_siunitx_detect_mode_bool {
      \siunitx_detect_font_mode:
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_detect_font_init:}
% Set up the basic macros on the assumption nothing happens.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_init: {
  \bool_set_true:N \l_siunitx_font_set_bool
  \cs_set:Nn \siunitx_font_bold: {
    \unboldmath 
    \mdseries
  }
  \cs_set:Nn \siunitx_font_italic: { \upshape }
  \tl_set:Nn \l_siunitx_font_family_tl { rm }
  \bool_set_true:N \l_siunitx_font_maths_mode_bool
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_detect_font_bold:}
% The bold detection code depends on whether the current text is maths
% or text, and also the type of maths (if appropriate).  For inline 
% maths, there is a choice of what test to apply.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_bold: {
  \mode_if_math:TF {
    \mode_if_inner:TF {
      \bool_if:NTF \l_siunitx_detect_inline_bold_bool {
        \siunitx_detect_font_bold_maths:
      }{
        \siunitx_detect_font_bold_text:
      }
    }{
      \bool_if:NTF \l_siunitx_detect_display_maths_bool {
        \siunitx_detect_font_bold_maths:
      }{
        \siunitx_detect_font_bold_text:
      }
    }
  }{
    \siunitx_detect_font_bold_text:
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\siunitx_detect_font_bold_maths:}
%\begin{macro}{\siunitx_detect_font_bold_text:}
% The tests for bold depend on whether the module is testing text or 
% maths content.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_bold_maths: {
  \tl_if_eq:nVT { bold } \math@version {
    \cs_set:Nn \siunitx_font_bold: {
      \boldmath
      \bfseries
    }
  }
}
\cs_new_nopar:Nn \siunitx_detect_font_bold_text: {
  \tl_if_eq:nxT { b } { \exp_args:NV \tl_head_i:n \f@series } {
    \cs_set:Nn \siunitx_font_bold: {
      \boldmath
      \bfseries
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_detect_font_family:}
% Family detection usually picks up the surrounding text.  However, for
% display maths there are two options, and so a second test may be made.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_family: {
  \siunitx_detect_font_family_text:
  \bool_if:NT \l_siunitx_detect_display_maths_bool {  
    \mode_if_math:TF {
      \mode_if_inner:F {
        \siunitx_detect_font_family_maths:
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\siunitx_detect_font_family_maths:}
%\begin{macro}{\siunitx_detect_font_family_text:}
% The two detections routines check if the current font is sans serif or
% monospaced.  The method used depends on whether the current maths or
% text font is of interest. The maths detection routine re-applies the 
% default (\texttt{rm}), as the text function is always called and may
% have changed things.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_family_maths: {
  \tl_set:Nn \l_siunitx_font_family_tl { rm }
  \intexp_compare:nT { \int:use:N \fam = \c_siunitx_mathsf_int } {
    \tl_set:Nn \l_siunitx_font_family_tl { sf }
  }
  \intexp_compare:nT { \int:use:N \fam = \c_siunitx_mathtt_int } {
    \tl_set:Nn \l_siunitx_font_family_tl { tt }
  }  
}
\cs_new_nopar:Nn \siunitx_detect_font_family_text: {
  \tl_if_eq:NNT \f@family \c_siunitx_textsf_tl {
    \tl_set:Nn \l_siunitx_font_family_tl { sf }
  }
  \tl_if_eq:NNT \f@family \c_siunitx_texttt_tl {
    \tl_set:Nn \l_siunitx_font_family_tl { tt }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_detect_font_italic:}
% The italic test uses \cs{f@shape} as a handy indicator.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_italic: {
  \tl_if_eq:nVT { it } \f@shape {
    \cs_set:Nn \siunitx_font_italic: { \itshape }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_detect_font_mode:}
% The mode switch works from the fact that maths-mode output it the
% standard.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_detect_font_mode: {
  \mode_if_math:F {
    \bool_set_false:N \l_siunitx_font_maths_mode_bool
  }
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Font macros}
%
% With the detection routines in place, the module can apply the result
% to control the font used for output. This requires a series of font 
% names to be available. The appropriate storage areas will be selected
% by name, based on output type (\texttt{unit} or \texttt{value}) and
% the family selected by the detector.
% 
%\begin{macro}{\l_siunitx_number_maths_mode_bool}
%\begin{macro}{\l_siunitx_unit_maths_mode_bool}
% Most of the variables are created by the keys system: these are not.
%    \begin{macrocode}
\bool_new:N \l_siunitx_number_maths_mode_bool
\bool_new:N \l_siunitx_unit_maths_mode_bool
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_number_colour_tl}
%\begin{macro}{\siunitx_number_mathrm:}
%\begin{macro}{\siunitx_number_mathsf:}
%\begin{macro}{\siunitx_number_mathtt:}
%\begin{macro}{\siunitx_number_textrm:}
%\begin{macro}{\siunitx_number_textsf:}
%\begin{macro}{\siunitx_number_texttt:}
% The settings are actually created separately for numbers and units:
% numbers first.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_mathrm: { }
\cs_new_nopar:Nn \siunitx_number_mathsf: { }
\cs_new_nopar:Nn \siunitx_number_mathtt: { }
\cs_new_nopar:Nn \siunitx_number_textrm: { }
\cs_new_nopar:Nn \siunitx_number_textsf: { }
\cs_new_nopar:Nn \siunitx_number_texttt: { }
\keys_define:nn { siunitx } {
  number-color  .meta:n = { number-colour = #1 },
  number-colour .set:N  = \l_siunitx_number_colour_tl,
  number-mathrm .code:n = {
    \cs_set_nopar:Nn \siunitx_number_mathrm: {#1}
  },
  number-mathsf .code:n = {
    \cs_set_nopar:Nn \siunitx_number_mathsf: {#1}
  },
  number-mathtt .code:n = {
    \cs_set_nopar:Nn \siunitx_number_mathtt: {#1}
  },
  number-mode .choice:,
  number-mode / math .code:n = {
    \bool_set_true:N \l_siunitx_number_maths_mode_bool
  },
  number-mode / maths .code:n = {
    \bool_set_true:N \l_siunitx_number_maths_mode_bool
  },
  number-mode / text .code:n = {
    \bool_set_true:N \l_siunitx_number_maths_mode_bool
  },
  number-textrm .code:n = {
    \cs_set_nopar:Nn \siunitx_number_textrm: {#1}
  },
  number-textsf .code:n = {
    \cs_set_nopar:Nn \siunitx_number_textsf: {#1}
  },
  number-texttt .code:n = {
    \cs_set_nopar:Nn \siunitx_number_texttt: {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}  
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%    
%\begin{macro}{\l_siunitx_unit_colour_tl}
%\begin{macro}{\siunitx_unit_mathrm:}
%\begin{macro}{\siunitx_unit_mathsf:}
%\begin{macro}{\siunitx_unit_mathtt:}
%\begin{macro}{\siunitx_unit_textrm:}
%\begin{macro}{\siunitx_unit_textsf:}
%\begin{macro}{\siunitx_unit_texttt:}
% Units look exactly the same. 
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_unit_mathrm: { }
\cs_new_nopar:Nn \siunitx_unit_mathsf: { }
\cs_new_nopar:Nn \siunitx_unit_mathtt: { }
\cs_new_nopar:Nn \siunitx_unit_textrm: { }
\cs_new_nopar:Nn \siunitx_unit_textsf: { }
\cs_new_nopar:Nn \siunitx_unit_texttt: { }
\keys_define:nn { siunitx } {
  unit-color  .meta:n = { unit-colour = #1 },
  unit-colour .set:N  = \l_siunitx_unit_colour_tl,
  unit-mathrm .code:n = {
    \cs_set_nopar:Nn \siunitx_unit_mathrm: {#1}
  },
  unit-mathsf .code:n = {
    \cs_set_nopar:Nn \siunitx_unit_mathsf: {#1}
  },
  unit-mathtt .code:n = {
    \cs_set_nopar:Nn \siunitx_unit_mathtt: {#1}
  },
  unit-mode .choice:,
  unit-mode / math .code:n = {
    \bool_set_true:N \l_siunitx_unit_maths_mode_bool
  },
  unit-mode / maths .code:n = {
    \bool_set_true:N \l_siunitx_unit_maths_mode_bool
  },
  unit-mode / text .code:n = {
    \bool_set_true:N \l_siunitx_unit_maths_mode_bool
  },
  unit-textrm .code:n = {
    \cs_set_nopar:Nn \siunitx_unit_textrm: {#1}
  },
  unit-textsf .code:n = {
    \cs_set_nopar:Nn \siunitx_unit_textsf: {#1}
  },
  unit-texttt .code:n = {
    \cs_set_nopar:Nn \siunitx_unit_texttt: {#1}
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}  
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
% The general settings are all meta-keys. A few initial values are set
% here as they are needed for everything to work.
%    \begin{macrocode}
\keys_define:nn { siunitx } {
  color .meta:n = {
    number-color = #1,
    unit-color   = #1
  },
  colour .meta:n = {
    number-colour = #1,
    unit-colour   = #1
  },
  mathrm .meta:n = {
    number-mathrm = #1,
    unit-mathrm   = #1
  },
  mathrm .initial:n = \mathrm,
  mathsf .meta:n = {
    number-mathsf = #1,
    unit-mathsf   = #1
  },
  mathsf .initial:n = \mathsf,
  mathtt .meta:n = {
    number-mathtt = #1,
    unit-mathtt   = #1
  },
  mathtt .initial:n = \mathtt,
  mode .choice:,
  mode / math .meta:n = {
    number-mode = math,
    unit-mode   = math
  },
  mode / maths .meta:n = {
    number-mode = maths,
    unit-mode   = maths
  },
  mode / text .meta:n = {
    number-mode = text,
    unit-mode   = text
  },
  textrm .meta:n = {
    number-textrm = #1,
    unit-textrm   = #1
  },
  textrm .initial:n = \rmfamily,
  textsf .meta:n = {
    number-textsf = #1,
    unit-textsf   = #1
  },
  textsf .initial:n = \sffamily,
  texttt .meta:n = {
    number-texttt = #1,
    unit-texttt   = #1
  },
  texttt .initial:n = \ttfamily
}
%    \end{macrocode}
%    
%\subsection{Output control}
%
% The \pkg{siunitx} output routine uses all of the font information
% gathered earlier to print the text given in whatever font is required.
% The low-level stuff is done here, with the calling routines expected
% to have taken some steps first (this is to allow line breaks in the
% appropriate places).
% 
%\begin{macro}{\l_siunitx_print_arg_tl}
% The text to print.
%    \begin{macrocode}
\tl_new:N \l_siunitx_print_arg_tl
%    \end{macrocode}
%\end{macro}
% 
%\begin{macro}{\l_siunitx_print_type_tl}
% The type of output (\texttt{num} or \texttt{unit}) is always needed.
%    \begin{macrocode}
\tl_new:N \l_siunitx_print_type_tl
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_print:nn}
%\begin{macro}{\siunitx_print:nV}
% The main printing function does everything inside a group, as 
% there are category code and definition changes to make. First, set
% the fonts.  Then move on to printing mode, before moving to actual
% printing.
%    \begin{macrocode}
\cs_new:Nn \siunitx_print:nn {
  \group_begin:
    \tl_set:Nn \l_siunitx_print_type_tl {#1}
    \tl_set:Nn \l_siunitx_print_arg_tl {#2}
    \siunitx_detect_font:
    \bool_if:NF \l_siunitx_detect_mode_bool {
      \bool_if:cTF { l_siunitx_ #1 _maths_mode_bool } {
        \bool_set_true:N \l_siunitx_maths_mode_bool
      }{
        \bool_set_false:N \l_siunitx_maths_mode_bool
      }
    }
    \siunitx_print_aux:
  \group_end:
}
\cs_generate_variant:Nn \siunitx_print:nn { nV }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\siunitx_print_aux:}
% The various font changes are set up, then the correct printing
% function is called. Everything is inside \cs{text} as this allows 
% proper setting of the various mode settings.
%    \begin{macrocode}
\cs_new:Nn \siunitx_print_aux: {
  \text {
    \siunitx_print_colour:
    \siunitx_font_bold:
    \siunitx_font_italic:
    \use:c {
      siunitx_ \l_siunitx_print_type_tl _ \l_siunitx_font_family_tl :
    }
    \bool_if:NTF \l_siunitx_font_maths_mode_bool {
      \siunitx_print_maths:
    }{
      \siunitx_print_text:
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_print_colour:}
%\begin{macro}{\siunitx_colour_check:}
% The colour system checks if \pkg{color} is loaded, and only does
% anything if it is.  This will change when \LaTeX3 proper is available:
% there will be colour out of the box!
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_print_colour: {
  \tl_if_empty:cF { l_siunitx_ \l_siunitx_print_type_tl _colour_tl } {
    \color {
      \tl_use:c { l_siunitx_ \l_siunitx_print_type_tl _colour_tl }
    }
  }
}
\cs_new_nopar:Nn \siunitx_colour_check: {
  \@ifpackageloaded{color}{}{
    \cs_set_eq:NN \siunitx_print_colour: \scan_stop:
  }
}
\AtBeginDocument { \siunitx_colour_check: }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_print_maths:}
%\begin{macro}{\siunitx_print_text:}
% Printing the text means replacing any awkward characters, which is
% dependent on the output mode. The rest of the package uses |_| and
% |^| to represent sub- and superscripts, respectively. In this way, 
% mode decisions can be delayed as long as possible. 
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn { `\& } { `\_ }
  \char_make_math_subscript:N \&
  \char_make_active:N \-
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Nn \siunitx_print_maths: {
    \ensuremath { \l_siunitx_print_arg_tl }
  }
  \cs_new:Nn \siunitx_print_text: {
    \tl_replace_all_in:Nnn \l_siunitx_print_arg_tl { & } 
      { \siunitx_print_text_sub:n }
    \tl_replace_all_in:Nnn \l_siunitx_print_arg_tl { ^ } 
      { \siunitx_print_text_super:n }
    \group_begin:
      \char_make_active:N \-
      \cs_set:Npn - { \text { \c_siunitx_minus_tl } }
      \exp_args:NnV \tl_rescan:nn { } \l_siunitx_print_arg_tl
    \group_end:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_print_text_sub:n}
%\begin{macro}{\siunitx_print_text_super:n}
% The appropriate macros for sub- and superscript in text mode ensure
% the appearance is the same as maths mode. As |_| is a letter, there
% is the need to do a category-code juggle.
%    \begin{macrocode}
\group_begin:
  \char_set_lccode:nn { `\& } { `\_ }
  \char_make_math_subscript:N \&
\tl_to_lowercase:n {
  \group_end:
  \cs_new:Nn \siunitx_print_text_sub:n {
    \ensuremath {
      & { \text {#1} }
    }
  }
}
\cs_new:Nn \siunitx_print_text_super:n {
  \ensuremath {
    ^ { \text {#1} }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Pre-processing numbers}
%
% Before the main parsing routine can be called, there is a need to 
% pre-process the input. The possibility that the data in can contain
% more than one number needs to be handled.
% 
%\begin{macro}{\l_siunitx_input_product_tl}
%\begin{macro}{\l_siunitx_input_quotient_tl}
% There are a couple of settings which are created here as they are used
% only for pre-processing.
%    \begin{macrocode}
\keys_define:nn { siunitx } {
  input-product  .set:N     = \l_siunitx_input_product_tl,
  input-product  .initial:n = x,
  input-quotient .set:N     = \l_siunitx_input_quotient_tl,
  input-quotient .initial:n = /,
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_number_arg_tl}
%\begin{macro}{\l_siunitx_number_next_arg_tl}
% Storage for the pre-parsed material.  The \texttt{arg} variable 
% contains the current argument, the \texttt{next} variable contains
% anything held-over for the next round.
%    \begin{macrocode}
\tl_new:N \l_siunitx_number_arg_tl
\tl_new:N \l_siunitx_number_next_arg_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\l_siunitx_number_denominator_tl}
%\begin{macro}{\l_siunitx_number_numerator_tl}
% When searching for quotients, some more storage is needed.
%    \begin{macrocode}
\tl_new:N \l_siunitx_number_denominator_tl
\tl_new:N \l_siunitx_number_numerator_tl
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_preprocess:n}
% The pre-processor starts with the obvious: the most likely outcome is
% that all of the argument is passed through unchanged.
%    \begin{macrocode}
\cs_new:Nn \siunitx_number_preprocess:n {
  \siunitx_number_preprocess_init:
  \tl_set:Nn \l_siunitx_number_arg_tl {#1}
  \siunitx_number_preprocess_product:
  \siunitx_number_preprocess_quotient:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_number_preprocess_init:}
% A little initialisation as normal.
%    \begin{macrocode}
\cs_new:Nn \siunitx_number_preprocess_init: {
  \bool_set_false:N \l_siunitx_error_bool
  \tl_clear:N \l_siunitx_number_pre_arg_tl
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_number_preprocess_product:}
%\begin{macro}[aux]{\siunitx_number_preprocess_product_aux:N}
% Rather than search through the entire argument, we use the 
% delimited-argument trick.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_preprocess_product: {
  \tl_map_function:NN \l_siunitx_input_product_tl
    \siunitx_number_preprocess_product_aux:N
}
\cs_new:Nn \siunitx_number_preprocess_product_aux:N {
  \tl_if_in:NnT \l_siunitx_number_arg_tl {#1} {
    \cs_set:Npn \siunitx_tmp:w ##1 #1 ##2 \q_stop {
      \tl_set:Nn \l_siunitx_number_arg_tl {##1}
      \tl_set:Nn \l_siunitx_number_next_arg_tl {##2}      
    }
    \exp_after:wN \siunitx_tmp:w \l_siunitx_number_arg_tl \q_stop
    \tl_if_empty:NT \l_siunitx_number_pre_arg_tl {
      \siunitx_error:n { starting-product-token }
    }
    \tl_if_empty:NT \l_siunitx_number_next_arg_tl {
      \siunitx_error:n { ending-product-token }
    }
    \tl_map_break:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_preprocess_quotient:}
%\begin{macro}[aux]{\siunitx_number_preprocess_quotient_aux:N}
% For the quotient, only one token can appear in each part. So there
% is an additional error check.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_preprocess_quotient: {
  \tl_map_function:NN \l_siunitx_input_quotient_tl
    \siunitx_number_preprocess_quotient_aux:N
}
\cs_new:Nn \siunitx_number_preprocess_quotient_aux:N {
  \tl_if_in:NnT \l_siunitx_number_arg_tl {#1} {
    \cs_set:Npn \siunitx_tmp:w ##1 #1 ##2 \q_stop {
      \tl_set:Nn \l_siunitx_number_numerator_tl {##1}
      \tl_set:Nn \l_siunitx_number_denominator_tl {##2}      
    }
    \exp_after:wN \siunitx_tmp:w \l_siunitx_number_arg_tl \q_stop
    \tl_if_empty:NT \l_siunitx_number_numerator_tl {
      \siunitx_error:n { starting-quotient-token }
    }
    \tl_if_empty:NT \l_siunitx_number_denominator_tl {
      \siunitx_error:n { ending-quotient-token }
    }
    \tl_if_in:NnT \l_siunitx_number_denominator_tl {#1} {
      \siunitx_error:n { duplicate-quotient-token }
    }
    \tl_map_break:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\subsection{Parsing numbers}
%
% The number parser is designed to work with single numbers, which can
% contain exponents, complex parts and uncertainties.  In general, 
% looping over the input is avoided: instead, loops over the check 
% values are used as these will hopefully be shorter, on average. The
% parser will report mathematically invalid numbers here: whether the
% input is valid in the context required is left to the calling 
% function.
% 
%\begin{macro}{\l_siunitx_number_in_prop}
% The number is split up into various parts, all stored here.
%    \begin{macrocode}
\prop_new:N \l_siunitx_number_in_prop
%    \end{macrocode}
%\end{macro} 
%
%\begin{macro}{\l_siunitx_number_valid_tl}
% This list of valid tokens is set when parsing a number, so that it is
% flexible.
%    \begin{macrocode}
\tl_new:N \l_siunitx_number_valid_tl
%    \end{macrocode}
%\end{macro}
% 
%\begin{macro}{\l_siunitx_input_close_uncert_tl}
%\begin{macro}{\l_siunitx_input_complex_tl}
%\begin{macro}{\l_siunitx_input_decimal_tl}
%\begin{macro}{\l_siunitx_input_digit_tl}
%\begin{macro}{\l_siunitx_input_exponent_tl}
%\begin{macro}{\l_siunitx_input_ignore_tl}
%\begin{macro}{\l_siunitx_input_open_uncert_tl}
%\begin{macro}{\l_siunitx_input_protect_tl}
%\begin{macro}{\l_siunitx_input_sign_tl}
%\begin{macro}{\l_siunitx_input_symbol_tl}
% The various tokens to check against when parsing are all set up here.
% These are valid inside a single number: the pre-processor has already
% set up the appropriate things for products and quotients.
%    \begin{macrocode}
\keys_define:nn { siunitx } { % (
  input-close-uncertainty .set:N     = \l_siunitx_input_close_uncert_tl, 
  input-close-uncertainty .initial:n = ),
  input-complex-roots     .set:N     = \l_siunitx_input_complex_tl,
  input-complex-roots     .initial:n = { ij },
  input-decimal-markers   .set:N     = \l_siunitx_input_decimal_tl,
  input-decimal-markers   .initial:n = { ., },
  input-digits            .set:N     = \l_siunitx_input_digit_tl,
  input-digits            .initial:n = { 0123456789 },
  input-exponent-markers  .set:N     = \l_siunitx_input_exponent_tl,
  input-exponent-markers  .initial:n = { dDeE },
  input-ignore            .set:N     = \l_siunitx_input_ignore_tl,
  input-open-uncertainty  .set:N     = \l_siunitx_input_open_uncert_tl, 
  input-open-uncertainty  .initial:n = (, % )
  input-protect-tokens    .set:N     = \l_siunitx_input_protect_tl,
  input-protect-tokens    .initial:n = { \mp \pi \pm },
  input-signs             .set:N     = \l_siunitx_input_sign_tl,
  input-signs             .initial:n = { +-\mp\pm },
  input-symbols           .set:N     = \l_siunitx_input_symbol_tl,
  input-symbols           .initial:n = \pi,
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_parse:n}
%\begin{macro}{\siunitx_number_in_parse:V}
% The master control for parsing numbers is mainly a list of functions
% to carry out. The rescanning allows full expansion of the input while 
% dealing with any hard spaces or awkward characters.
%    \begin{macrocode}
\cs_new:Nn \siunitx_number_in_parse:n {
  \siunitx_number_in_init:
  \tl_set_rescan:Nnx \l_siunitx_number_arg_tl {
    \siunitx_number_in_protect:
    \char_make_ignore:N \~
    \char_make_other:N \,
    \char_make_other:N \.
    \cs_set_eq:NN \, \prg_do_nothing:
  } {#1}
  \tl_if_empty:NF \l_siunitx_number_arg_tl {
    \siunitx_number_in_loop:V \l_siunitx_number_arg_tl
    \bool_if:NF \l_siunitx_error_bool {
      \siunitx_number_in_separate:
    }
    \bool_if:NF \l_siunitx_error_bool {
      \siunitx_number_in_tidy:
    }
    \bool_if:NF \l_siunitx_error_bool {
      \siunitx_number_in_check:
    }
  }
}
\cs_generate_variant:Nn \siunitx_number_in_parse:n { V }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_check:}
%\begin{macro}[aux]{\siunitx_number_in_check_uncertainty:n}
% Checks for invalid number combinations.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_check: {
  \siunitx_number_in_check_uncertainty:n { mantissa }
  \siunitx_number_in_check_uncertainty:n { mantissa-complex }
  \siunitx_number_in_check_uncertainty:n { exponent }
  \siunitx_number_in_check_uncertainty:n { exponent-complex }
  \prop_if_in:NnT \l_siunitx_number_in_prop { exponent } {
    \prop_if_in:NnF \l_siunitx_number_in_prop { exponent-integer } {
      \prop_if_in:NnF \l_siunitx_number_in_prop { exponent-decimal } {
        \prop_if_in:NnF \l_siunitx_number_in_prop { exponent-complex } {
          \siunitx_error:n { empty-exponent }
        }
      }
    }
  }
}
\cs_new_nopar:Nn \siunitx_number_in_check_uncertainty:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -uncertainty } {
    \prop_if_in:NnF \l_siunitx_number_in_prop { #1 -integer } {
      \prop_if_in:NnF \l_siunitx_number_in_prop { #1 -decimal } {
        \siunitx_error:n { uncertainty-only }
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_complex:n}
%\begin{macro}[aux]{\siunitx_number_in_complex_aux:N}
% Finding a valid complex number is a two stage process.  The first part
% is to look for a complex root at the end of the number.  If one is 
% found, look for a sign dividing the real and imaginary parts.  If 
% the number is not complex, then any sign tokens are invalid.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_complex:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop {#1} {
    \prop_get:NnN \l_siunitx_number_in_prop {#1} \l_siunitx_tmp_tl
    \cs_set:Nn \siunitx_number_in_complex_aux:N {
      \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
        \siunitx_number_in_complex_check:N ##1
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -complex } { }
        \tl_map_break:
      }
    }
    \tl_map_function:NN \l_siunitx_input_complex_tl 
      \siunitx_number_in_complex_aux:N
    \bool_if:NF \l_siunitx_error_bool {
      \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -complex } { 
        \prop_del:Nn \l_siunitx_number_in_prop {#1}
        \prop_del:Nn \l_siunitx_number_in_prop { #1 -complex }
        \siunitx_number_in_complex_separate:n {#1}
        \siunitx_number_in_complex_tidy:n {#1}
      }
    }
    \bool_if:NF \l_siunitx_error_bool {
      \siunitx_number_in_complex_check:n {#1}
    }
  }
}
\cs_new:Nn \siunitx_number_in_complex_aux:N { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\siunitx_number_in_complex_check:N}
% To avoid needing to use a second loop to check for the last letter, 
% a bit of trickery.  The argument |##2| has to be empty for the 
% number to be valid.
%    \begin{macrocode}
\cs_new:Nn \siunitx_number_in_complex_check:N {
  \cs_set:Npn \siunitx_tmp:w ##1 #1 ##2 \q_stop {
    \tl_if_empty:nTF {##2} {
      \tl_set:Nn \l_siunitx_tmp_tl {##1}
    }{
      \siunitx_error:nx { misplaced-complex-root } {#1}
    }
  }
  \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\siunitx_number_in_complex_separate:n}
%\begin{macro}[aux]{\siunitx_number_in_complex_separate_aux:N}
%\begin{macro}[aux]{\siunitx_number_in_complex_separate_aux:n}
% The second part of the system has to look for a sign. The complex 
% number is currently in \cs{l_siunitx_tmpa_tl}, so this does not need
% to be recovered from the property list.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_complex_separate:n {
  \cs_set:Nn \siunitx_number_in_complex_seperate_aux:N {
    \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
      \cs_set:Npn \siunitx_tmp:w ####1 ##1 ####2 \q_stop {
        \tl_if_empty:nF {####1} {
          \prop_put:Nnn \l_siunitx_number_in_prop {#1} {####1}
        }
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -complex-sign } 
          {##1}
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -complex } {####2}
      }
      \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
    }
  }
  \tl_map_function:NN \l_siunitx_input_sign_tl
    \siunitx_number_in_complex_seperate_aux:N 
}
\cs_new:Nn \siunitx_number_in_complex_seperate_aux:N { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\siunitx_number_in_complex_tidy:n}
% There is a need to check that the signs match up with the appropriate 
% parts of the number.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_complex_tidy:n {
  \prop_if_in:NnF \l_siunitx_number_in_prop { #1 -complex } {
    \prop_put:NnV \l_siunitx_number_in_prop { #1 -complex } 
      \l_siunitx_tmp_tl
    \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -sign } {
      \prop_get:NnN \l_siunitx_number_in_prop { #1 -sign } 
        \l_siunitx_tmp_tl
      \prop_del:Nn \l_siunitx_number_in_prop { #1 -sign }
      \prop_put:NnV \l_siunitx_number_in_prop { #1 -complex-sign } 
        \l_siunitx_tmp_tl
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\siunitx_number_in_complex_check:n}
%\begin{macro}[aux]{\siunitx_number_in_complex_check_aux:n}
%\begin{macro}[aux]{\siunitx_number_in_complex_check_aux:N}
% Finally for complex numbers, make sure there are no stray tokens.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_complex_check:n {
  \siunitx_number_in_complex_check_aux:n { #1 }
  \siunitx_number_in_complex_check_aux:n { #1 -complex }
}
\cs_new_nopar:Nn \siunitx_number_in_complex_check_aux:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop {#1} {
    \prop_get:NnN \l_siunitx_number_in_prop {#1} \l_siunitx_tmp_tl
    \cs_set:Nn \siunitx_number_in_complex_check_aux:N {
      \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
        \siunitx_error:nx { misplaced-sign } {##1}
      \tl_map_break:
      }
    }
    \tl_map_function:NN \l_siunitx_input_sign_tl
      \siunitx_number_in_uncertainty_check_aux:N
    \cs_set:Nn \siunitx_number_in_complex_check_aux:N {
      \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
        \siunitx_error:nx { misplaced-complex-root } {##1}
      \tl_map_break:
      }
    }
    \tl_map_function:NN \l_siunitx_input_complex_tl
      \siunitx_number_in_uncertainty_check_aux:N
  }
}
\cs_new:Nn \siunitx_number_in_complex_check_aux:N { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_decimal:n}
% The real and complex parts need a slightly different lead-off test
% here, as a valid complex number can have no digits at all.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_decimal:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop {#1} {
    \prop_get:NnN \l_siunitx_number_in_prop {#1} \l_siunitx_tmp_tl
    \siunitx_number_in_decimal_aux:n {#1}
  }
}
\cs_new_nopar:Nn \siunitx_number_in_decimal_complex:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -complex } {
    \prop_get:NnN \l_siunitx_number_in_prop { #1 -complex } 
      \l_siunitx_tmp_tl
    \tl_if_empty:NTF \l_siunitx_tmp_tl {
      \prop_put:Nnn \l_siunitx_number_in_prop { #1 -complex-integer } { }
    }{ 
      \siunitx_number_in_decimal_aux:n { #1 -complex }  
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}[aux]{\siunitx_number_in_decimal_aux:n}
%\begin{macro}[aux]{\siunitx_number_in_decimal_aux:N}
% The main part of the integer--decimal separator avoids a loop. Only a
% single token can be given, and this can be used to find the two parts 
% rapidly.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_decimal_aux:n {
  \tl_if_empty:NF \l_siunitx_tmp_tl {
    \prop_put:NnV \l_siunitx_number_in_prop { #1 -integer } 
      \l_siunitx_tmp_tl
  }
  \cs_set:Nn \siunitx_number_in_decimal_aux:N {
    \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
      \cs_set:Npn \siunitx_tmp:w ####1 ##1 ####2 \q_stop {
        \tl_if_empty:nTF {####1} {
          \prop_del:Nn \l_siunitx_number_in_prop { #1 -integer }
        }{
          \prop_put:Nnn \l_siunitx_number_in_prop { #1 -integer } 
            {####1}
        }
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -decimal } {####2}
      }
      \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
      \tl_map_break:
    }
  }
  \tl_map_function:NN \l_siunitx_input_decimal_tl 
    \siunitx_number_in_decimal_aux:N
  \siunitx_number_in_decimal_check:n { #1 -integer }
  \siunitx_number_in_decimal_check:n { #1 -decimal }
}
\cs_new:Nn \siunitx_number_in_decimal_aux:N { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\siunitx_number_in_decimal_check:n}
%\begin{macro}[aux]{\siunitx_number_in_decimal_check:N}
% A short function which makes sure that there is only one decimal 
% marker.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_decimal_check:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop {#1} {
    \prop_get:NnN \l_siunitx_number_in_prop {#1} 
      \l_siunitx_tmp_tl
    \tl_map_function:NN \l_siunitx_input_decimal_tl 
      \siunitx_number_in_decimal_check:N
  }
}
\cs_new:Nn \siunitx_number_in_decimal_check:N {
  \tl_if_in:NnT \l_siunitx_tmp_tl {#1} {
    \siunitx_error:n { duplicate-decimal-token }
    \tl_map_break:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_exponent:}
%\begin{macro}[aux]{\siunitx_number_in_exponent_aux:N}
% Check for an exponent marker, and if it is there do the separation.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_exponent: {
  \tl_map_function:NN \l_siunitx_input_exponent_tl 
    \siunitx_number_in_exponent_aux:N
}
\cs_new:Nn \siunitx_number_in_exponent_aux:N {
  \prop_put:NnV \l_siunitx_number_in_prop { mantissa } 
    \l_siunitx_number_arg_tl
  \tl_if_in:NnT \l_siunitx_number_arg_tl {#1} {
    \cs_set:Npn \siunitx_tmp:w ##1 #1 ##2 \q_stop {
      \prop_put:Nnn \l_siunitx_number_in_prop { mantissa } {##1}
      \prop_put:Nnn \l_siunitx_number_in_prop { exponent } {##2}
      \tl_set:Nn \l_siunitx_tmp_tl {##2}
      \tl_if_empty:nT {##1} {
        \tl_if_empty:nT {##2} {
          \siunitx_error:n { empty-number }
        }
      }
    }
    \exp_after:wN \siunitx_tmp:w \l_siunitx_number_arg_tl \q_stop
    \tl_if_in:NnT \l_siunitx_tmp_tl {#1} {
      \siunitx_error:n { duplicate-exponent-token }
    }
    \tl_map_break:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_init:}
% In the initialisation code, the token list 
% \cs{l_siunitx_number_valid_tl} is constructed to 
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_init: {
  \bool_set_false:N \l_siunitx_error_bool
  \prop_clear:N \l_siunitx_number_in_prop
  \group_begin:
    \siunitx_number_in_protect:
    \tl_set:Nx \l_siunitx_number_valid_tl {
      \l_siunitx_input_sign_tl
      \l_siunitx_input_ignore_tl
      \l_siunitx_input_digit_tl
      \l_siunitx_input_decimal_tl
      \l_siunitx_input_exponent_tl
      \l_siunitx_input_complex_tl
      \l_siunitx_input_symbol_tl
      \l_siunitx_input_open_uncert_tl
      \l_siunitx_input_close_uncert_tl
    }
  \exp_args:NNNV \group_end:
  \tl_set:Nn \l_siunitx_number_valid_tl \l_siunitx_number_valid_tl
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_loop:n}
%\begin{macro}{\siunitx_number_in_loop:V}
%\begin{macro}[aux]{\siunitx_number_in_loop_aux:N}
% The entire argument is looped over.  Three tasks take place here, to 
% keep down the number of loops.  First, a check is made that the input
% token is valid. The input stream is re-written to remove ignored 
% tokens, and finally a check is made to see if `symbolic' tokens are
% present in the input.
%    \begin{macrocode}
\cs_new:Nn \siunitx_number_in_loop:n {
  \tl_clear:N \l_siunitx_number_arg_tl
  \tl_map_function:nN {#1} \siunitx_number_in_loop_aux:N
}
\cs_generate_variant:Nn \siunitx_number_in_loop:n { V }
\cs_new:Nn \siunitx_number_in_loop_aux:N {
  \tl_if_in:NnF \l_siunitx_number_valid_tl {#1} {
    \siunitx_error:nxx { invalid-token-in-number } {#1} { 
      \l_siunitx_number_valid_tl
    }
    \tl_map_break:
  }
  \tl_if_in:NnF \l_siunitx_input_ignore_tl {#1} {
    \tl_put_right:Nn \l_siunitx_number_arg_tl {#1} 
  }
  \tl_if_in:NnT \l_siunitx_input_symbol_tl {#1} {
    \prop_put:Nnn \l_siunitx_number_in_prop { symbolic } { true }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_protect:}
%\begin{macro}[aux]{\siunitx_number_in_protect_aux:N}
% Under some circumstances (for example when loading \pkg{breqn}) 
% some tokens do not behave safely under \texttt{x} expansion (at the
% moment). To get round this, they are redefined here.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_protect: {
  \tl_map_function:NN \l_siunitx_input_protect_tl
    \siunitx_number_in_protect_aux:N
}
\cs_new:Nn \siunitx_number_in_protect_aux:N {
  \cs_set_eq:NN #1 \scan_stop:
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_separate:}
%\begin{macro}[aux]{\siunitx_number_in_separate_aux:n}
% The main separator macro divides the input into the various parts.
% As everything is done for the mantissa and the exponent, an auxiliary
% function is used to keep the code shorter. At each stage where an 
% error might arise, a check is made for the error switch.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_separate: {
  \siunitx_number_in_exponent:
  \siunitx_number_in_separate_aux:n { mantissa }
  \siunitx_number_in_separate_aux:n { exponent }
}
\cs_new_nopar:Nn \siunitx_number_in_separate_aux:n {
  \bool_if:NF \l_siunitx_error_bool {
    \siunitx_number_in_sign:n {#1}
    \siunitx_number_in_complex:n {#1}
  }
  \bool_if:NF \l_siunitx_error_bool {
    \siunitx_number_in_decimal:n {#1}
    \siunitx_number_in_decimal_complex:n {#1}
  }
  \bool_if:NF \l_siunitx_error_bool {
    \siunitx_number_in_uncertainty:n {#1}
    \siunitx_number_in_uncertainty:n { #1 -complex }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_sign:n}
% Separating signs first converts `\texttt{+-}' to \cs{pm} and 
% `\texttt{-+}' to \cs{mp} before looking for a single-token sign.  
% This is done using the fact that only the very first token needs to be
% examined.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_sign:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop {#1} {
    \prop_get:NnN \l_siunitx_number_in_prop {#1} \l_siunitx_tmp_tl
    \tl_replace_all_in:Nnn \l_siunitx_tmp_tl { -+ } { \mp }
    \tl_replace_all_in:Nnn \l_siunitx_tmp_tl { +- } { \pm }
    \cs_set:Npn \siunitx_tmp:w ##1##2 \q_stop {
      \tl_if_in:NnTF \l_siunitx_input_sign_tl {##1} {
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -sign } { ##1 }
        \prop_put:Nnn \l_siunitx_number_in_prop {#1} { ##2 }
      }{
        \prop_put:Nnn \l_siunitx_number_in_prop {#1} { ##1 ##2 }
      }
    }
    \tl_if_empty:NF \l_siunitx_tmp_tl {
      \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_tidy:}
%\begin{macro}[aux]{\siunitx_number_in_tidy_aux:n}
% There are some minor bits of tidying up to do now. Two issues need to
% be handled, both concerned with zero.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_tidy: { 
  \siunitx_number_in_tidy_aux:n { mantissa }
  \siunitx_number_in_tidy_aux:n { exponent }
}
\cs_new_nopar:Nn \siunitx_number_in_tidy_aux:n {
  \siunitx_number_in_tidy_zeros:n {#1}
  \siunitx_number_in_tidy_zeros:n { #1 -complex }
  \siunitx_number_in_tidy_sign:n {#1}
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\siunitx_number_in_tidy_zeros:n}
% Here, any leading zeros are found in the integer part of the number.
% By constructing the loop in this way, every character in the input 
% does not have to be tested.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_tidy_zeros:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -integer } {
    \prop_get:NnN \l_siunitx_number_in_prop { #1 -integer } 
      \l_siunitx_tmp_tl
    \tl_if_in:NnT \l_siunitx_tmp_tl { 0 } {
      \cs_set:Npn \siunitx_tmp:w ##1 0 ##2 \q_stop {
        \tl_if_empty:nTF {##1} {
          \tl_if_in:nnTF {##2} { 0 } {
            \siunitx_tmp:w ##2 \q_stop
          }{
            \tl_set:Nn \l_siunitx_tmp_tl {##2}
            \prop_put:Nnn \l_siunitx_number_in_prop { #1 -integer }
              { ##2 }
          }
        }{
          \prop_put:Nnn \l_siunitx_number_in_prop { #1 -integer }
            { ##1 0 ##2 }
        }
      }
      \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
      \tl_if_empty:NT \l_siunitx_tmp_tl {
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -integer } { 0 }
      }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%\begin{macro}{\siunitx_number_in_tidy_sign:n}
%\begin{macro}[aux]{\siunitx_number_in_tidy_sign_aux_i:n}
%\begin{macro}[aux]{\siunitx_number_in_tidy_sign_aux_ii:n}
% The number zero does not take a sign. The test is complicated by some 
% issues. First, the check for complex numbers needs to ensure that it
% only fires if there is no real part. The integer part of the problem 
% is easy: it will just be zero if there is no value.  However, the 
% decimal part can be an arbitrary number of zeros. 
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_tidy_sign:n {
  \prop_if_in:NnTF \l_siunitx_number_in_prop {#1} {
    \siunitx_number_in_tidy_sign_aux_i:n {#1}
  }{
    \siunitx_number_in_tidy_sign_aux_i:n { #1 -complex }
  }
}
\cs_new_nopar:Nn \siunitx_number_in_tidy_sign_aux_i:n {
  \prop_if_in:NnTF \l_siunitx_number_in_prop { #1 -integer } {
    \prop_get:NnN \l_siunitx_number_in_prop { #1 -integer } 
      \l_siunitx_tmp_tl 
    \tl_if_eq:nVTF { 0 } \l_siunitx_tmp_tl {
      \siunitx_number_in_tidy_sign_aux_ii:n {#1}
    }{
      \tl_if_empty:NT \l_siunitx_tmp_tl {
        \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -decimal } {
          \siunitx_number_in_tidy_sign_aux_ii:n {#1}
        }
      }
    }
  }{
    \siunitx_number_in_tidy_sign_aux_ii:n {#1}
  }
}
\cs_new_nopar:Nn \siunitx_number_in_tidy_sign_aux_ii:n {
  \prop_if_in:NnTF \l_siunitx_number_in_prop { #1 -decimal } {
    \prop_get:NnN \l_siunitx_number_in_prop { #1 -decimal } 
      \l_siunitx_tmp_tl
    \cs_set:Npn \siunitx_tmp:w ##1 {
      \tl_if_eq:nnF {##1} { 0 } {
        \tl_clear:N \l_siunitx_tmp_tl
        \tl_map_break:
      }
    }
    \tl_reverse:N \l_siunitx_tmp_tl
    \tl_map_function:NN \l_siunitx_tmp_tl \siunitx_tmp:w
    \tl_if_empty:NF \l_siunitx_tmp_tl {
      \prop_del:Nn \l_siunitx_number_in_prop { #1 -sign }
    }
  }{
    \prop_del:Nn \l_siunitx_number_in_prop { #1 -sign }
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_number_in_uncertainty:n}
%\begin{macro}[aux]{\siunitx_number_in_uncertainty_close:nn}
%\begin{macro}[aux]{\siunitx_number_in_uncertainty_close:N}
% Finding any uncertainty depends on whether there is a decimal part. A
% check is made first for the closing symbol: it must be at the end of 
% the number, and so is relatively easy to find.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_uncertainty:n {
  \prop_if_in:NnTF \l_siunitx_number_in_prop { #1 -decimal } {
    \siunitx_number_in_uncertainty_close:nn {#1} { decimal } 
  }{
    \prop_if_in:NnT \l_siunitx_number_in_prop { #1 -integer } {
      \siunitx_number_in_uncertainty_close:nn {#1} { integer }
    }
  }
  \siunitx_number_in_uncertainty_check:n {#1}
}
\cs_new_nopar:Nn \siunitx_number_in_uncertainty_close:nn {
  \prop_get:NnN \l_siunitx_number_in_prop { #1 - #2 } \l_siunitx_tmp_tl
  \cs_set:Nn \siunitx_number_in_uncertainty_close:N {
    \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
      \cs_set:Npn \siunitx_tmp:w ####1 ##1 ####2 \q_stop {
        \tl_if_empty:nTF {####2} {
          \prop_put:Nnn \l_siunitx_number_in_prop { #1 -uncertainty } 
            { }
          \tl_set:Nn \l_siunitx_tmp_tl {####1}
        }{
          \siunitx_error:nx { misplaced-closing-uncertainty } {##1}
        }
      }
      \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
      \tl_map_break:
    }
  }
  \tl_map_function:NN \l_siunitx_input_close_uncert_tl
    \siunitx_number_in_uncertainty_close:N
  \prop_if_in:NnT \l_siunitx_number_in_prop { #1 - uncertainty } {
    \siunitx_number_in_uncertainty_open:nn {#1} {#2}
  }
}
\cs_new:Nn \siunitx_number_in_uncertainty_close:N { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}[aux]{\siunitx_number_in_uncertainty_open:nn}
%\begin{macro}[aux]{\siunitx_number_in_uncertainty_open:N}
% Now to look for the opening character. This is done on the basis that
% a search can always look first in the integer part.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_uncertainty_open:nn {
  \cs_set:Nn \siunitx_number_in_uncertainty_open:N {
    \tl_if_in:NnT \l_siunitx_tmp_tl {##1} {
      \cs_set:Npn \siunitx_tmp:w ####1 ##1 ####2 \q_stop {
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 - #2 } {####1}
        \prop_put:Nnn \l_siunitx_number_in_prop { #1 -uncertainty } 
          {####2}
        \tl_if_empty:nT {####2} {
          \siunitx_error:n { empty-uncertainty }
        }
      }
      \exp_after:wN \siunitx_tmp:w \l_siunitx_tmp_tl \q_stop
      \tl_map_break:
    }
  }
  \tl_map_function:NN \l_siunitx_input_open_uncert_tl
    \siunitx_number_in_uncertainty_open:N
}
\cs_new_nopar:Nn \siunitx_number_in_uncertainty_open:N { }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\begin{macro}{\siunitx_number_in_uncertainty_check:n}
%\begin{macro}{\siunitx_number_in_uncertainty_check_aux:n}
%\begin{macro}{\siunitx_number_in_uncertainty_check_aux:N}
% To make sure no stray tokens are about.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_number_in_uncertainty_check:n {
  \siunitx_number_in_uncertainty_check_aux:n { #1 -integer }
  \siunitx_number_in_uncertainty_check_aux:n { #1 -decimal }
  \siunitx_number_in_uncertainty_check_aux:n { #1 -uncertainty }
}
\cs_new_nopar:Nn \siunitx_number_in_uncertainty_check_aux:n {
  \prop_if_in:NnT \l_siunitx_number_in_prop {#1} {
    \prop_get:NnN \l_siunitx_number_in_prop {#1} \l_siunitx_tmp_tl
    \tl_map_function:NN \l_siunitx_input_open_uncert_tl
      \siunitx_number_in_uncertainty_check_aux:N
    \tl_map_function:NN \l_siunitx_input_close_uncert_tl
      \siunitx_number_in_uncertainty_check_aux:N
  }
}
\cs_new:Nn \siunitx_number_in_uncertainty_check_aux:N {
  \tl_if_in:NnT \l_siunitx_tmp_tl {#1} {
    \siunitx_error:nx { misplaced-uncertainty } {#1}
    \tl_map_break:
  }
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Symbols}
%
% Not all units use letters alone for their symbol. This raises two 
% problems. First, the symbols need to work in maths and in text mode.
% Second, the user needs to be able to adjust each symbol.
% 
%\begin{macro}{\l_siunitx_redefine_symbols_bool}
%    \begin{macrocode}
\keys_define:nn { siunitx } {
  redefine-symbols .set_bool:N = \l_siunitx_redefine_symbols_bool,
  redefine-symbols .initial:n     = { true }
}
%    \end{macrocode}
%\end{macro} 
%
%\begin{macro}{\siunitx_redefine_symbols:}
% The redefinition of symbols has to do a number of checks to ensure
% that there are no clashes.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_redefine_symbols: {
  \bool_if:NT \l_siunitx_redefine_symbols_bool {
    \@ifpackageloaded { textcomp } {
      \keys_set:nn { siunitx } {
        maths-degree = \text { \textdegree },
        text-degree  = \textdegree,
      }%
      \@ifpackageloaded { mathptmx } { } {
        \keys_set:nn { siunitx } {
          text-micro = \textmu,
          text-ohm   = \textomega
        }%
      }%
      \tl_if_eq:nVT { OT1 } \encodingdefault { 
        \keys_set:nn { siunitx } {
         maths-angstrom = \text { \capitalring { A } },
         text-angstrom  = \capitalring { A }
        }
      }
    } { }
    \@ifpackageloaded { upgreek } {
      \keys_set:nn { siunitx } {
        maths-ohm = \Upomega
      }
    } { }
  }
}
%\AtBeginDocument { \siunitx_redefine_symbols: }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\l_siunitx_angstrom_maths_tl}
%\begin{macro}{\l_siunitx_arcminute_maths_tl}
%\begin{macro}{\l_siunitx_arcsecond_maths_tl}
%\begin{macro}{\l_siunitx_celsius_maths_tl}
%\begin{macro}{\l_siunitx_degree_maths_tl}
%\begin{macro}{\l_siunitx_micro_maths_tl}
%\begin{macro}{\l_siunitx_ohm_maths_tl}
% The symbol storage macros are created separately for maths and text
% mode, although this is all pretty similar. The default definitions use
% what is generally available, except for those for micro, where 
% Computer Modern does not have the appropriate symbol at all. For the 
% maths mode omega option, the |\text{\ensuremath{...}}| construction
% deals with the case where \cs{mathnormal} has the wrong symbol.
%    \begin{macrocode}
\keys_define:nn { siunitx } {
  math-angstrom   .set:N     = \l_siunitx_angstrom_maths_tl,
  maths-angstrom  .set:N     = \l_siunitx_angstrom_maths_tl,
  maths-angstrom  .initial:n = { \text { \AA } },
  math-arcminute  .set:N     = \l_siunitx_arcminute_maths_tl,
  maths-arcminute .set:N     = \l_siunitx_arcminute_maths_tl,
  maths-arcminute .initial:n = { { } ^ { \prime } },
  math-arcsecond  .set:N     = \l_siunitx_arcsecond_maths_tl,
  maths-arcsecond .set:N     = \l_siunitx_arcsecond_maths_tl,
  maths-arcsecond .initial:n = { { } ^ { \prime \prime } },
  math-celsius    .set:N     = \l_siunitx_celsius_maths_tl,
  maths-celsius   .set:N     = \l_siunitx_celsius_maths_tl,
  maths-celsius   .initial:n = { 
    { } ^ { \circ } \kern - \scriptspace C 
  },
  math-degree     .set:N     = \l_siunitx_degree_maths_tl,
  maths-degree    .set:N     = \l_siunitx_degree_maths_tl,
  maths-degree    .initial:n = { { } ^ { \circ } },
  math-micro      .set:N     = \l_siunitx_micro_maths_tl,
  maths-micro     .set:N     = \l_siunitx_micro_maths_tl,
  maths-micro     .initial:n = { \c_siunitx_mu_maths_tl },
  math-ohm        .set:N     = \l_siunitx_ohm_maths_tl,
  maths-ohm       .set:N     = \l_siunitx_ohm_maths_tl,
  maths-ohm       .initial:n = { \text { \ensuremath { \Omega } } },
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\l_siunitx_angstrom_text_tl}
%\begin{macro}{\l_siunitx_arcminute_text_tl}
%\begin{macro}{\l_siunitx_arcsecond_text_tl}
%\begin{macro}{\l_siunitx_celsius_text_tl}
%\begin{macro}{\l_siunitx_degree_text_tl}
%\begin{macro}{\l_siunitx_micro_text_tl}
%\begin{macro}{\l_siunitx_ohm_text_tl}
% Text versions are similar.
%    \begin{macrocode}
\keys_define:nn { siunitx } {
  text-angstrom  .set:N     = \l_siunitx_angstrom_text_tl,
  text-angstrom  .initial:n = { \AA },
  text-arcminute .set:N     = \l_siunitx_arcminute_text_tl,
  text-arcminute .initial:n = { \ensuremath { { } ^ { \prime } } },
  text-arcsecond .set:N     = \l_siunitx_arcsecond_text_tl,
  text-arcsecond .initial:n = { 
    \ensuremath { { } ^ { \prime \prime } } 
  },
  text-celsius   .set:N     = \l_siunitx_celsius_text_tl,
  text-celsius   .initial:n = { 
    \ensuremath { { } ^ { \circ } \kern - \scriptspace C }
  },
  text-degree    .set:N     = \l_siunitx_degree_text_tl,
  text-degree    .initial:n = { \ensuremath { { } ^ { \circ } } },
  text-micro     .set:N     = \l_siunitx_micro_text_tl,
  text-micro     .initial:n = { \c_siunitx_mu_text_tl },
  text-ohm       .set:N     = \l_siunitx_ohm_text_tl,
  text-ohm       .initial:n = { \ensuremath { \Omega } },
}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\siunitx_symbol_new:n}
% For creating the outer symbol macro.
%    \begin{macrocode}
\cs_new_nopar:Nn \siunitx_symbol_new:n {
  \exp_args:Nc \DeclareDocumentCommand { SIUnitSymbol #1 } { } {
    \mode_if_math:TF {
      \tl_to_lowercase:n { \use:c { l_siunitx_ #1 _maths_tl } }
    }{
      \tl_to_lowercase:n { \use:c { l_siunitx_ #1 _text_tl } }
    }
  }
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\SIUnitSymbolAngstrom}
%\begin{macro}{\SIUnitSymbolArcminute}
%\begin{macro}{\SIUnitSymbolArcsecond}
%\begin{macro}{\SIUnitSymbolCelsius}
%\begin{macro}{\SIUnitSymbolDegree}
%\begin{macro}{\SIUnitSymbolMicro}
%\begin{macro}{\SIUnitSymbolOhm}
% The wrapper macros are created.
%    \begin{macrocode}
\siunitx_symbol_new:n { Angstrom }
\siunitx_symbol_new:n { Arcminute }
\siunitx_symbol_new:n { Arcsecond }
\siunitx_symbol_new:n { Celsius }
\siunitx_symbol_new:n { Degree } 
\siunitx_symbol_new:n { Micro }
\siunitx_symbol_new:n { Ohm }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\subsection{Messages}
%
% Lots of messages, all of them together in one block to make life
% easier.
%    \begin{macrocode}
\msg_new:nnnn { siunitx } { duplicate-decimal-token } {%
  Duplicate decimal token.%
}{%
  Only one decimal token can appear in a single number.%
}
\msg_new:nnnn { siunitx } { duplicate-exponent-token } {%
  Duplicate exponent token found.%
}{%
  Only one exponent token can appear in a single number.%
}
\msg_new:nnnn { siunitx } { duplicate-quotient-token } {%
  Duplicate quotient token.%
}{%
  Only one quotient token can appear in a single number.%
}
\msg_new:nnnn { siunitx } { empty-exponent } {%
  Empty exponent.%
}{%
  The exponent contains no number.%
}
\msg_new:nnnn { siunitx } { empty-number } {%
  Empty numerical argument.%
}{%
  The given `number' contains no information.%
}
\msg_new:nnnn { siunitx } { empty-uncertainty } {%
  Empty uncertainty given.%
}{%
  The number given contains an empty uncertainty.%
}
\msg_new:nnnn { siunitx } { ending-product-token } {%
  Misplaced product token.%
}{%
  A number cannot end with a product token.%
}
\msg_new:nnnn { siunitx } { ending-quotient-token } {%
  Misplaced quotient token.%
}{%
  A number cannot end with a quotient token.%
}
\msg_new:nnnn { siunitx } { invalid-token-in-number } {%
  Invalid token `#1' in numerical input.%
}{%
  Only the tokens\\%
  \msg_space: \msg_space: #2\\%
  are valid for numerical input.%
}
\msg_new:nnnn { siunitx } { misplaced-complex-root } {%
  Misplaced complex root.%
}{%
  The complex root token `#1' can only come at the end of a number.%
}
\msg_new:nnnn { siunitx } { misplaced-closing-uncertainty } {%
  Misplaced closing uncertainty token.%
}{%
  The closing uncertainty token `#1' can only come at the end of a 
  number.%
}
\msg_new:nnnn { siunitx } { misplaced-sign } {%
  Misplaced sign token.%
}{%
  The sign token `#1' can only come at the beginning of a number.%
}
\msg_new:nnnn { siunitx } { misplaced-uncertainty } {%
  Misplaced uncertainty token.%
}{%
  The uncertainty token `#1' does not properly match another token.%
}
\msg_new:nnnn { siunitx } { starting-product-token } {%
  Misplaced product token.%
}{%
  A number cannot begin with a product token.%
}
\msg_new:nnnn { siunitx } { starting-quotient-token } {%
  Misplaced quotient token.%
}{%
  A number cannot begin with a quotient token.%
}
\msg_new:nnnn { siunitx } { uncertainty-only } {%
  Uncertainty but no number.%
}{%
  A number contains an uncertainty part with no main value.%
}
%    \end{macrocode}
%    
%\subsection{Design-level macros}
% 
%\begin{macro}{\DeclareSIPower}
%\begin{macro}{\DeclareSIPrefix}
%\begin{macro}{\DeclareSIQualifier}
%\begin{macro}{\DeclareSIUnit}%
% The macros for creating units and so on are in design name space.
% Basically, a set of shuffles for arguments.
%    \begin{macrocode}
\DeclareDocumentCommand \DeclareSIPower { s m m } {
}
\DeclareDocumentCommand \DeclareSIPrefix { s m m m } {
}
\DeclareDocumentCommand \DeclareSIQualifier { s m m m } {
}
\DeclareDocumentCommand \DeclareSIUnit { o m m } {
  \IfNoValueF {#1} {
  }
}
%    \end{macrocode}
%\end{macro} 
%\end{macro}
%\end{macro}
%\end{macro}
% 
% None of this should be done after the preamble.
%    \begin{macrocode}
\@onlypreamble \DeclareSIPower
\@onlypreamble \DeclareSIPrefix
\@onlypreamble \DeclareSIQualifier
\@onlypreamble \DeclareSIUnit
%    \end{macrocode}
%
%\subsection{Document macros}
%
% The user document macros are all collected together here for ease.
% 
%\begin{macro}{\num}
% The \cs{num} macro is quite simple: read the number, check it is 
% correct then print it. 
%    \begin{macrocode}
\DeclareDocumentCommand \num { o m } {
  \group_begin:
    \IfNoValueF {#1} {
      \keys_set:nn { siunitx } {#1}
    }
  \group_end:
}
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\SI}
%    \begin{macrocode}
\DeclareDocumentCommand \SI { o m o m } {
  \group_begin:
    \IfNoValueF {#1} {
      \keys_set:nn { siunitx } {#1}
    }
  \group_end:
}
%    \end{macrocode}
%\end{macro}
% 
%\begin{macro}{\sisetup}
% The set up macro simply moves to the correct path and executes 
% whatever has been passed.
%    \begin{macrocode}
\DeclareDocumentCommand \sisetup { m } {
  \keys_set:nn { siunitx } {#1}
}
%    \end{macrocode}
%\end{macro}
%
%\subsection{Physical units}
%
%\begin{macro}{\kilogram}
%\begin{macro}{\metre}
%\begin{macro}{\meter}
%\begin{macro}{\mole}
%\begin{macro}{\kelvin}
%\begin{macro}{\candela}
%\begin{macro}{\second}
%\begin{macro}{\ampere}
% The basic SI units are always defined, including both variants for
% metre.
%    \begin{macrocode}
\DeclareSIUnit \kilogram { \kilo \gram }
\DeclareSIUnit \metre    { m }
\DeclareSIUnit \meter    { \metre }
\DeclareSIUnit \mole     { mol }
\DeclareSIUnit \second   { s }
\DeclareSIUnit \ampere   { A }
\DeclareSIUnit \kelvin   { K }
\DeclareSIUnit \candela  { cd }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\gram}
% The gram is an odd unit as it is needed for the base unit kilogram.
%    \begin{macrocode}
\DeclareSIUnit \gram { g }
%    \end{macrocode}
%\end{macro}
%
%\begin{macro}{\yocto}
%\begin{macro}{\zepto}
%\begin{macro}{\atto}
%\begin{macro}{\femto}
%\begin{macro}{\pico}
%\begin{macro}{\nano}
%\begin{macro}{\micro}
%\begin{macro}{\milli}
%\begin{macro}{\centi}
%\begin{macro}{\deci}
% The various SI multiple prefixes are defined here: first the small
% ones. 
%    \begin{macrocode}
\DeclareSIPrefix \yocto { y } { -24 }
\DeclareSIPrefix \zepto { z } { -21 }
\DeclareSIPrefix \atto  { a } { -18 }
\DeclareSIPrefix \femto { f } { -15 }
\DeclareSIPrefix \pico  { p } { -12 }
\DeclareSIPrefix \nano  { n } { -9 }
\DeclareSIPrefix \micro { \SIUnitSymbolMicro } { -6 }
\DeclareSIPrefix \milli { m } { -3 }
\DeclareSIPrefix \centi { c } { -2 }
\DeclareSIPrefix \deci  { d } { -1 }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\deca}
%\begin{macro}{\deka}
%\begin{macro}{\hecto}
%\begin{macro}{\kilo}
%\begin{macro}{\mega}
%\begin{macro}{\giga}
%\begin{macro}{\tera}
%\begin{macro}{\peta}
%\begin{macro}{\exa}
%\begin{macro}{\zetta}
%\begin{macro}{\yotta}
% Now the large ones.
%    \begin{macrocode}
\DeclareSIPrefix \deca  { da } { 1 }
\DeclareSIPrefix \deka  { da } { 1 }
\DeclareSIPrefix \hecto { h }  { 2 }
\DeclareSIPrefix \kilo  { k }  { 3 }
\DeclareSIPrefix \mega  { M }  { 6 }
\DeclareSIPrefix \giga  { G }  { 9 }
\DeclareSIPrefix \tera  { T }  { 12 }
\DeclareSIPrefix \peta  { P }  { 15 }
\DeclareSIPrefix \exa   { E }  { 18 }
\DeclareSIPrefix \zetta { Z }  { 21 }
\DeclareSIPrefix \yotta { Y }  { 24 }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\becquerel}
%\begin{macro}{\celsius}
%\begin{macro}{\coulomb}
%\begin{macro}{\farad}
%\begin{macro}{\gray}
%\begin{macro}{\hertz}
%\begin{macro}{\henry}
%\begin{macro}{\joule}
%\begin{macro}{\katal}
%\begin{macro}{\lumen}
%\begin{macro}{\lux}
% A number of derived units with defined names and symbols.
%    \begin{macrocode}
\DeclareSIUnit \becquerel { Bq }
\DeclareSIUnit \celsius   { \SIUnitSymbolCelsius }
\DeclareSIUnit \coulomb   { C }
\DeclareSIUnit \farad     { F }
\DeclareSIUnit \gray      { Gy }
\DeclareSIUnit \hertz     { Hz }
\DeclareSIUnit \henry     { H }
\DeclareSIUnit\joule      { J }
\DeclareSIUnit \katal     { kat }
\DeclareSIUnit \lumen     { lm }
\DeclareSIUnit \lux       { lx }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\newton}
%\begin{macro}{\ohm}
%\begin{macro}{\pascal}
%\begin{macro}{\radian}
%\begin{macro}{\siemens}
%\begin{macro}{\sievert}
%\begin{macro}{\steradian}
%\begin{macro}{\tesla}
%\begin{macro}{\volt}
%\begin{macro}{\watt}
%\begin{macro}{\weber}
% More units.
%    \begin{macrocode}
\DeclareSIUnit \newton    { N }
\DeclareSIUnit \ohm       { \SIUnitSymbolOhm }
\DeclareSIUnit \pascal    { Pa }
\DeclareSIUnit \radian    { rad }
\DeclareSIUnit \siemens   { S }
\DeclareSIUnit \sievert   { Sv }
\DeclareSIUnit \steradian { sr }
\DeclareSIUnit \tesla     { T }
\DeclareSIUnit \volt      { V }
\DeclareSIUnit \watt      { W }
\DeclareSIUnit \weber     { Wb }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\arcminute}
%\begin{macro}{\arcsecond}
%\begin{macro}{\day}
%\begin{macro}{\degree}
%\begin{macro}{\hectare}
%\begin{macro}{\hour}
%\begin{macro}{\litre}
%\begin{macro}{\liter}
%\begin{macro}{\minute}
%\begin{macro}{\percent}
%\begin{macro}{\tonne}
% Non-SI, but accepted for general use.
%    \begin{macrocode}
\DeclareSIUnit[units/output/number-unit separator={}]
  \arcmin { \arcminute } 
\DeclareSIUnit[units/output/number-unit separator={}]
  \arcminute { \SIUnitSymbolArcminute }
\DeclareSIUnit[units/output/number-unit separator={}]
   \arcsecond { \SIUnitSymbolArcsecond }
\DeclareSIUnit \day { d }
\DeclareSIUnit[units/output/number-unit separator={}]
  \degree { \SIUnitSymbolDegree }
\DeclareSIUnit \hectare { ha }
\DeclareSIUnit \hour    { h }
\DeclareSIUnit \litre   { l }
\DeclareSIUnit \liter   { L }
\DeclareSIUnit \minute  { min }
\DeclareSIUnit \percent { \char37 }
\DeclareSIUnit \tonne   { t }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\astronomicalunit}
%\begin{macro}{\atomicmassunit}
%\begin{macro}{\electronvolt}
%\begin{macro}{\dalton}
% A few units based on physical measurements exist.  
%    \begin{macrocode}
\DeclareSIUnit \astronomicalunit { ua }
\DeclareSIUnit \atomicmassunit   { u }
\DeclareSIUnit \electronvolt     { eV }
\DeclareSIUnit \dalton           { Da }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\clight}
%\begin{macro}{\electronmass}
%\begin{macro}{\planckbar}
% A set of `natural units'.
%    \begin{macrocode}
\DeclareSIUnit \clight       {\text{\ensuremath{c_{0}}}}
\DeclareSIUnit \electronmass {\text{\ensuremath{m_{\text{e}}}}}
\DeclareSIUnit \planckbar    {\text{\ensuremath{\hbar}}}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\begin{macro}{\elementarycharge}
%\begin{macro}{\bohr}
%\begin{macro}{\hartree}
% A set of `atomic units'.
%    \begin{macrocode}
\DeclareSIUnit \elementarycharge {\text{\ensuremath{e}}}
\DeclareSIUnit \bohr             {\text{\ensuremath{a_{0}}}}
\DeclareSIUnit \hartree          {\text{\ensuremath{E_{\textup{h}}}}}
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%
%\begin{macro}{\angstrom}
%\begin{macro}{\bar}
%\begin{macro}{\barn}
%\begin{macro}{\bel}
%\begin{macro}{\bel}
%\begin{macro}{\knot}
%\begin{macro}{\mmHg}
%\begin{macro}{\nauticalmile}
%\begin{macro}{\neper}
% There are then some day-to-day units which are accepted for use
% with SI, but are not part of the official specification.
%    \begin{macrocode}
\DeclareSIUnit \angstrom     { \SIUnitSymbolAngstrom }
\DeclareSIUnit \bar          { bar }
\DeclareSIUnit \barn         { b }
\DeclareSIUnit \bel          { B }
\DeclareSIUnit \decibel      { \deci \bel }
\DeclareSIUnit \knot         { kn }
\DeclareSIUnit \mmHg         { mmHg }
\DeclareSIUnit \nauticalmile { M }
\DeclareSIUnit \neper        { Np }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro} 
%\end{macro} 
%\end{macro} 
%
%\begin{macro}{\square}
%\begin{macro}{\squared}
%\begin{macro}{\cubic}
%\begin{macro}{\cubed}
% The basic powers are also defined.
%    \begin{macrocode}
\DeclareSIPower  \square  { 2 }
\DeclareSIPower* \squared { 2 }
\DeclareSIPower  \cubic   { 3 }
\DeclareSIPower* \cubed   { 3 }
%    \end{macrocode}
%\end{macro}
%\end{macro}
%\end{macro}
%\end{macro}

%    
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
%\end{implementation}