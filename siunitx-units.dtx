% \iffalse meta-comment
%
% File: siunitx-units.dtx Copyright (C) 2014 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    http://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% 
% \GetFileInfo{siunitx.sty}
% 
% \title{^^A
%   \pkg{siunitx-units} -- Parsing and formatting units^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
% 
% \begin{documentation}
% 
% This submodule is dedicated to formatting physical units. The main function,
% \cs{siunitx_units_format:nN}, takes user input specify physical units and
% converts it into a formatted token list suitable for typesetting in math
% mode. While the formatter will deal correctly with \enquote{literal} user
% input, the key strength of the module is providing a method to describe
% physical units in a \enquote{symbolic} manner. The output format of these
% symbolic units can then be controlled by a number of key--value options
% made available by the module.
% 
% \section{Defining symbolic units}
% 
% \begin{function}{\siunitx_units_set_prefix:Nnn}
%   \begin{syntax}
%     \cs{siunitx_units_set_prefix:Nnn} \meta{prefix} \Arg{symbol} \Arg{power}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. The prefix
%   should represent an integer \meta{power} of $10$, and this information
%   may be used to convert from one or more \meta{prefix} symbols to an
%   overall power applying to a unit. See also
%   \cs{siunitx_units_set_prefix:Nn}.
% \end{function}
% 
% \begin{function}{\siunitx_units_set_prefix:Nn}
%   \begin{syntax}
%     \cs{siunitx_units_set_prefix:Nn}  \meta{prefix} \Arg{symbol}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. In contrast
%   to \cs{siunitx_units_set_prefix:Nnn}, there is no assumption about the
%   mathematical nature of the \meta{prefix}, \emph{i.e.}~the prefix may
%   represent a power of any base. As a result, no conversion of the
%   \meta{prefix} to a numerical power will be possible.
% \end{function}
% 
% \begin{function}{\siunitx_units_set_power:NnN}
%   \begin{syntax}
%     \cs{siunitx_units_set_unit:Nn} \meta{power} \Arg{value} \meta{precedes}
%   \end{syntax}
%   Defines a symbolic \meta{power} (which should be a control sequence
%   such as |\squsred|) to be converted by the parser to the \meta{value}.
%   The latter should be an integer or floating point number in the format
%   defined for \pkg{l3fp}. Powers may precede a unit or be given after it:
%   which case applies to the \meta{power} is determined by the boolean
%   \meta{precedes}. In literal mode, the \meta{value} will be applied as
%   a superscript to either the next token in the input (\meta{precedes} 
%   true) or appended to the previously-typeset material (\meta{precedes}
%   false).
% \end{function}
% 
% \begin{function}{\siunitx_units_set_qualifier:Nn}
%   \begin{syntax}
%     \cs{siunitx_units_set_qualifier:Nn} \meta{qualifier} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{qualifier} (which should be a control sequence
%   such as |\catalyst|) to be converted by the parser to the \meta{meaning}.
%   The latter should consist of literal content (\emph{e.g.}~|cat|). In
%   literal mode the \meta{meaning} will be typeset following a space after
%   the unit to which it applies.
% \end{function}
% 
% \begin{function}{\siunitx_units_set_unit:Nn}
%   \begin{syntax}
%     \cs{siunitx_units_set_unit:Nn} \meta{unit} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{unit} (which should be a control sequence
%   such as |\kilogram|) to be converted by the parser to the \meta{meaning}.
%   The latter may consist of literal content (\emph{e.g.}~|kg|), other
%   symbolic unit commands (\emph{e.g.}~|\kilo\gram|) or a mixture of the two.
%   In literal mode the \meta{meaning} will be typeset directly.
% \end{function}
% 
% \section{Pre-defined symbolic unit components}
% 
% The unit parser is defined to recognise a number of pre-defined units,
% prefixes and powers, and also interpret a small selection of
% \enquote{generic} symbolic parts
% 
% \begin{function}{\per}
%   \begin{syntax}
%     \cs{per} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   is reciprocal, \emph{i.e.}~raises it to the power $-1$. This symbolic
%   representation may be applied in addition to a \cs{power}, and will work
%   correctly if the \cs{power} itself is negative. In literal mode \cs{per}
%   will print a slash (\enquote{$/$}).
% \end{function}
% 
% \begin{function}{\cancel}
%   \begin{syntax}
%     \cs{cancel} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be \enquote{cancelled out}. In the parsed output, the entire unit
%   combination will be given as the argument to a function \cs{cancel}, which
%   is assumed to be available at a higher level. In literal mode, the same
%   higher-level \cs{cancel} will be applied to the next token. It is the
%   responsibility of the calling code to provide an appropriate definition
%   for \cs{cancel} outside of the scope of the unit parser.
% \end{function}
% 
% \begin{function}{\highlight}
%   \begin{syntax}
%     \cs{highlight} \Arg{color} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be highlighted in the specified \meta{color}. In the parsed output,
%   the entire unit combination will be given as the argument to a function
%   \cs{textcolor}, which is assumed to be available at a higher level. In
%   literal mode, the same higher-level \cs{textcolor} will be applied to the
%   next token. It is the responsibility of the calling code to provide an
%   appropriate definition for \cs{textcolor} outside of the scope of the unit
%   parser.
% \end{function}
%
% \begin{function}{\of}
%   \begin{syntax}
%     \meta{prefix} \meta{unit} \meta{power} \cs{of} \Arg{qualifier}
%   \end{syntax}
%   Indicates that the \meta{qualifier} applies to the current
%   \meta{prefix}/\meta{unit}/\meta{power} combination. In parsed mode, the
%   display of the result will depend upon module options. In literal mode,
%   the \meta{qualifier} will be printed in parentheses following the preceding
%   \meta{unit} and a full-width space.  
% \end{function}
% 
% \begin{function}{\raiseto, \tothe}
%   \begin{syntax}
%     \cs{raiseto} \Arg{power} \meta{prefix} \meta{unit}
%     \meta{prefix} \meta{unit} \cs{tothe} \Arg{power}
%   \end{syntax}
%   Indicates that the \meta{power} applies to the current
%   \meta{prefix}/\meta{unit} combination. As shown, \cs{raiseto} applies to
%   the next \meta{unit} whereas \cs{tothe} applies to the preceding unit. In
%   literal mode the \cs{power} will be printed as a superscript attached to
%   the next token (\cs{raiseto}) or preceding token (\cs{tothe}) as 
%   appropriate.
% \end{function}
% 
% \subsection{Key--value options}
% 
% The options defined by this submodule are available within the \pkg{l3keys}
% |siunitx/units| tree. 
% 
% \begin{function}{inter-unit-product}
%   \begin{syntax}
%     |inter-unit-product| = \meta{separator}
%   \end{syntax}
%   Inserted between unit combinations in parsed mode, and used to replace
%   |.| and |~| in literal mode. The standard setting is |\,|.
% \end{function}
% 
% \begin{function}{sticky-per}
%   \begin{syntax}
%     |sticky-per| = |true|\verb"|"|false|
%   \end{syntax}
%   Used to determine whether \cs{per} should be applied one a unit-by-unit
%   basis (when |false|) or should apply to all following units
%   (when |true|). The latter mode is somewhat akin conceptually to the
%   \TeX{} \cs{over} primitive. The standard setting is |false|.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
% 
% \section{\pkg{siunitx-units} implementation}
% 
% Start the DocStrip guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 DocStrip convention): only internal
% material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_units>
%    \end{macrocode}
%    
% \subsection{Initial set up}
%
% The mechanisms defined here need a few variables to exist and to be
% correctly set: these don't belong to one subsection and so are created
% in a small general block.
%
%   Variants not provided by \pkg{expl3}.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_replace_all:Nnn { NnV }
%    \end{macrocode}
% 
% \begin{variable}[int]{\l_@@_tmp_int}
% \begin{variable}[int]{\l_@@_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\int_new:N \l_@@_tmp_int
\tl_new:N  \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
% 
% \begin{variable}[int]{\l_@@_parsing_bool}
%   A boolean is used to indicate when the symbolic unit functions should
%   produce symbolic or literal output. This is used when the symbolic names
%   are used along with literal input, and ensures that there is a sensible
%   fall-back for these cases.
%    \begin{macrocode}
\bool_new:N \l_@@_parsing_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_test_bool}
%   A switch used to indicate that the code is testing the input to find
%   if there is any typeset output from individual unit macros. This is needed
%   to allow the \enquote{base} macros to be found, and also to pick up the
%   difference between symbolic and literal unit input.
%    \begin{macrocode}
\bool_new:N \l_@@_test_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_if_symbolic:nTF}
%   The test for symbolic units is needed in two places. First, there is the
%   case of \enquote{pre-parsing} input to check if it can be parsed. Second,
%   when parsing there is a need to check if the current unit is built up
%   from others (symbolic) or is defined in terms of some literals. To do this,
%   the approach used is to set all of the symbolic unit commands expandable
%   and to do nothing, with the few special cases handled manually. If
%   an \texttt{x}-type definition then yields nothing at all then the
%   assumption is that the input is symbolic.
%   
%   Note that as we are dealing with arbitrary \LaTeXe{} input, there is the
%   need to use \cs{protected@edef} here: in a \enquote{pure} \LaTeX3 version
%   that would replaced by \cs{tl_set:Nx}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_symbolic:n #1 { TF }
  {
    \group_begin:
      \bool_set_true:N \l_@@_test_bool
      \protected@edef \l_@@_tmp_tl {#1}
    \exp_args:NNV \group_end:
    \tl_if_blank:nTF \l_@@_tmp_tl
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Defining symbolic unit}
%
% Unit macros and related support are created here. These exist only within
% the scope of the unit processor code, thus not polluting document-level
% namespace and allowing overlap with other areas in the case of useful short
% names (for example \cs{pm}). Setting up the mechanisms to allow this requires
% a few additional steps on top of simply saving the data given by the user
% in creating the unit.
% 
% \begin{variable}[int]{\l_@@_symbolic_seq}
%   A list of all of the symbolic units, \emph{etc.}, set up. This is needed
%   to allow the symbolic names to be defined within the scope of the unit
%   parser but not elsewhere using simple mappings.
%    \begin{macrocode}
\seq_new:N \l_@@_symbolic_seq
%    \end{macrocode}
% \end{variable}
% 
% \begin{macro}[int]{\@@_set_symbolic:Nnn}
% \begin{macro}[int]{\@@_set_symbolic:Npnn}
% \begin{macro}[aux]{\@@_set_symbolic:NNpnn}
%   The majority of the work for saving each symbolic definition is the same
%   irrespective of the item being defined (unit, prefix, power, qualifier).
%   This is therefore all carried out in a single internal function which
%   does the common tasks. The three arguments here are the symbolic macro
%   name, the literal output and the code to insert when doing full unit
%   parsing. To allow for the \enquote{special cases} (where arguments are
%   required) the entire mechanism is set up in a two-part fashion allowing
%   for flexibility at the slight cost of additional functions.
%   
%   Importantly, notice that the unit macros are declared as expandable. This
%   is required so that literals can be correctly converted into a token list
%   of material which does not depend on local redefinitions for the unit
%   macros. That is required so that the unit formatting system can be grouped.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_symbolic:Nnn #1
  { \@@_set_symbolic:NNnnn \cs_set_nopar:cpn #1 { } }
\cs_new_protected:Npn \@@_set_symbolic:Npnn #1#2#
  { \@@_set_symbolic:NNnnn \cs_set:cpn #1 {#2} }
\cs_new_protected:Npn \@@_set_symbolic:NNnnn #1#2#3#4#5
  {
    \seq_put_right:Nn \l_@@_symbolic_seq {#2}
    #1 { units ~ > ~ \token_to_str:N #2 } #3
      {
        \bool_if:NF \l_@@_test_bool
          {
            \bool_if:NTF \l_@@_parsing_bool
              {#5}
              {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\siunitx_units_set_power:NnN}
%   For powers, there is the slight complication that the symbolic name may
%   appear either before or after the unit it applies to, and these two
%   different cases need slightly different code for the literal case. A
%   boolean is used to determine which case is in operation, and in parsing
%   mode this data is passed directly to the underlying function.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_power:NnN #1#2#3
  {
    \bool_if:NTF #3
      {
        \@@_set_symbolic:Nnn #1
          { \@@_literal_power:nN {#1} }
      }
      {
        \@@_set_symbolic:Nnn #1
          { ^ {#2} }
      }
        { \@@_parse_power:nnN {#1} {#2} #3 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_prefix:Nn}
% \begin{macro}{\siunitx_units_set_prefix:Nnn}
% \begin{variable}[int]
%   {\l_@@_prefixes_forward_prop, \l_@@_prefixes_reverse_prop}
%   For prefixes there are a couple of options. In all cases, the basic
%   requirement is to set up to parse the prefix using the appropriate
%   internal function. For prefixes which are powers of $10$, there is also
%   the need to be able to do conversion to/from the numerical equivalent.
%   That is handled using two properly lists which can be used to supply
%   the conversion data later.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_prefix:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      { \@@_parse_prefix:Nn #1 {#2} }
  }
\cs_new_protected:Npn \siunitx_units_set_prefix:Nnn #1#2#3
  {
    \siunitx_units_set_prefix:Nn #1 {#2}
    \prop_put:Nnn \l_@@_prefixes_forward_prop {#2} {#3}
    \prop_put:Nnn \l_@@_prefixes_reverse_prop {#3} {#2}
  }
\prop_new:N \l_@@_prefixes_forward_prop
\prop_new:N \l_@@_prefixes_reverse_prop
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_qualifier:Nn}
%   Qualifiers are relatively easy to handle: nothing to do other than save
%   the input appropriately.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_qualifier:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      { \  ( #2 ) }
      { \@@_parse_qualifier:nn {#1} {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_unit:Nn}
%   For the unit parsing, allowing for variations in definition order requires
%   that a test is made for the output of each unit at point of use.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_unit:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      {
        \@@_if_symbolic:nTF {#2}
          {#2}
          { \@@_parse_unit:Nn #1 {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Non-standard symbolic units}
%
% A few of the symbolic units require non-standard definitions: these are
% created here. They all use parts of the more general code but have particular
% requirements which can only be addressed by hand. Some of these could in
% principle be used in place of the dedicated definitions above, but at point
% of use that would then require additional expansions for each unit parsed:
% as the macro names would still be needed, this does not offer any real
% benefits.
%
% \begin{macro}{\per}
%   The \cs{per} symbolic unit is a bit special: it has a mechanism entirely
%   different from everything else, so has to be set up by hand. In literal
%   mode it is represented by a very simple symbol!
%    \begin{macrocode}
\@@_set_symbolic:Nnn \per
  { / }
  { \@@_parse_per: }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cancel}
% \begin{macro}{\highlight}
%   The two special cases, \cs{cancel} and \cs{highlight}, are easy to deal
%   with when parsing. When not parsing, a precaution is taken to ensure that
%   the user level equivalents always get a braced argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \cancel
  { \@@_literal_special:nN { \cancel } }
  { \@@_parse_special:n { \cancel } }
\@@_set_symbolic:Npnn \highlight #1
  { \@@_literal_special:nN { \textcolor {#1} } }
  { \@@_parse_special:n { \textcolor {#1} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\of}
%   The generic qualifier is simply the same as the dedicated ones except for
%   needing to grab an argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \of #1
  { \  ( #1 ) }
  { \@@_parse_qualifier:nn { \of {#1} } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\raiseto, \tothe}
%   Generic versions of the pre-defined power macros. These require an
%   argument and so cannot be handled using the general approach. Other than
%   that, the code here is very similar to that in
%   \cs{siunitx_units_set_power:NnN}.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \raiseto #1
  { \@@_literal_power:nN {#1} }
  { \@@_parse_power:nnN { \raiseto {#1} } {#1} \c_true_bool }
\@@_set_symbolic:Npnn \tothe #1
  { ^ {#1} }
  { \@@_parse_power:nnN { \tothe {#1} } {#1} \c_false_bool }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Main formatting routine}
%
% Unit input can take two forms, \enquote{literal} units (material to be
% typeset directly) or \enquote{symbolic} units (macro-based). Before any
% parsing or typesetting is carried out, a small amount of pre-parsing has to
% be carried out to decide which of these cases applies.
% 
% \begin{variable}[int]{\l_@@_product_tl}
%   Options which apply to the main formatting routine, and so are not tided
%   to either symbolic or literal input.
%    \begin{macrocode}
\keys_define:nn { siunitx / units }
  {
    inter-unit-product .tl_set:N = \l_@@_product_tl
  }
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}[int]{\l_@@_formatted_tl}
%   A token list for the final formatted result: may or may not be generated
%   by the parser, depending on the nature of the input.
%    \begin{macrocode}
\tl_new:N \l_@@_formatted_tl
%    \end{macrocode}
% \end{variable}
% 
% \subsection{Formatting literal units}
% 
% While in literal mode no parsing occurs, there is a need to provide a few
% auxiliary functions to handle one or two special cases.
%
% \begin{macro}[int]{\@@_literal_power:nN}
%   For printing literal units which are given before the unit they apply to,
%   there is a slight rearrangement.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_literal_power:nN #1#2 { #2 ^ {#1} }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}[int]{\@@_literal_special:nN}
%   When dealing with the special cases, there is an argument to absorb. This
%   should be braced to be passed up to the user level, which is dealt with
%   here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_literal_special:nN #1#2 { #1 {#2} }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}[int]{\@@_format_literal:n}
%   To format literal units, there are two tasks to do. The input is
%   \texttt{x}-type expanded to force any symbolic units to be converted into
%   their literal representation: this requires setting the appropriate
%   switch. In the resulting token list, all |.| and |~| tokens are then
%   replaced by the current unit product token list. To enable this to happen
%   correctly with a normal (active) |~|, a small amount of
%   \enquote{protection} is needed first. The same is true fro \cs{sb} and
%   \cs{sp} as they may be made expandable by the \pkg{mathstyle} package.
%   
%   The series of \cs{tl_replace_all:Nnn} are needed as if the output ends up
%   inside for example \cs{textrm} then math mode sub/superscripts cannot be
%   used. Replacing them all here is done using two category codes: the normal
%   \LaTeXe{} ones and as \enquote{other} characters. The reason for the latter
%   is that most packages that carry out \enquote{special effects} with these
%   chars use mathcode rather than catcode to alter behaviour.
%   
%   As with other code dealing with user input, \cs{protected@edef} is used
%   here rather than \cs{tl_set:Nx} as \LaTeXe{} robust commands may be
%   present.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_active:n { `\~ }
  \char_set_catcode_math_subscript:n { `\= }
  \char_set_lccode:nn { `\+ } { `\^ }
  \char_set_lccode:nn { `\= } { `\_ }
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new_protected:Npn \@@_format_literal:n #1
        {
          \group_begin:
            \bool_set_false:N \l_@@_parsing_bool
            \cs_set_protected_nopar:Npn ~ { }
            \cs_set_protected_nopar:Npn \sb { }
            \cs_set_protected_nopar:Npn \sp { }
            \protected@edef \l_@@_formatted_tl {#1}
            \tl_replace_all:NnV \l_@@_formatted_tl { . }
              \l_@@_product_tl
            \tl_replace_all:NnV \l_@@_formatted_tl { ~ }
              \l_@@_product_tl
            \tl_replace_all:Nnn \l_@@_formatted_tl { ^ } { \sp }
            \tl_replace_all:Nnn \l_@@_formatted_tl { + } { \sp }
            \tl_replace_all:Nnn \l_@@_formatted_tl { _ } { \sb }
            \tl_replace_all:Nnn \l_@@_formatted_tl { = } { \sb }
          \exp_args:NNNV \group_end:
          \tl_set:Nn \l_@@_formatted_tl \l_@@_formatted_tl
        }
    }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Parsing symbolic units}
%
% Parsing units takes place by storing information about each unit in a
% \texttt{prop}. As well as the unit itself, there are various other optional
% data points, for example a prefix or a power. Some of these can come before
% the unit, others only after. The parser therefore tracks the number of units
% read and uses the current position to allocate data to individual units.
%
% The result of parsing is a property list (\cs{l_@@_parsed_prop}) which
% contains one or more entries for each unit:
% \begin{itemize}
%   \item \texttt{prefix-$n$} The symbol for the prefix which applies to this
%     unit, \emph{e.g.} for \cs{kilo} with (almost certainly) would be
%     |k|.
%   \item \texttt{unit-$n$} The symbol for the unit itself, \emph{e.g.}~for
%     \cs{metre} with (almost certainly) would be |m|.
%   \item \texttt{power-$n$} The power which a unit is raised to. During
%     initial parsing this will (almost certainly) be positive, but is combined
%     with \texttt{per-$n$} to give a \enquote{fully qualified} power before
%     any formatting takes place 
%   \item \texttt{per-$n$} Indicates that \texttt{per} applies to the current
%     unit: stored during initial parsing then combined with \texttt{power-$n$}
%     (and removed from the list) before further work.
%   \item \texttt{qualifier-$n$} Any qualifier which applies to the current
%     unit.
%   \item \texttt{special-$n$} Any \enquote{special effect} to apply to the
%     current unit.
% \end{itemize}
% 
% \begin{variable}[int]{\l_@@_sticky_per_bool}
%   There is one option when \emph{parsing} the input (as opposed to
%   \emph{formatting} for output): how to deal with \cs{per}.
%    \begin{macrocode}
\keys_define:nn { siunitx / units }
  {
    sticky-per .bool_set:N = \l_@@_sticky_per_bool
  }
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}[int]{\l_@@_parsed_prop}
% \begin{variable}[int]{\l_@@_per_bool}
% \begin{variable}[int]{\l_@@_position_int}
%   Parsing units requires a small number of variables are available: a
%   \texttt{prop} for the parsed units themselves, a \texttt{bool} to
%   indicate if \cs{per} is active and an \texttt{int} to track how many units
%   have be parsed.
%    \begin{macrocode}
\prop_new:N \l_@@_parsed_prop
\bool_new:N \l_@@_per_bool
\int_new:N \l_@@_position_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
% 
% \begin{macro}[int]{\@@_parse:n}
%   The main parsing function is quite simple. After initialising the variables,
%   each symbolic unit is set up. The input is then simply inserted into the
%   input stream: the symbolic units themselves then do the real work of
%   placing data into the parsing system. There is then a bit of tidying up to
%   ensure that later stages can rely on the nature of the data here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse:n #1
  {
    \prop_clear:N \l_@@_parsed_prop
    \bool_set_true:N \l_@@_parsing_bool
    \bool_set_false:N \l_@@_per_bool
    \bool_set_false:N \l_@@_test_bool
    \int_zero:N \l_@@_position_int
    #1
    \int_step_inline:nnnn \c_one \c_one \l_@@_position_int
      { \@@_parse_finalise:n {##1} }
    \@@_parse_finalise:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_add:nnnn}
%   In all cases, storing a data item requires setting a temporary \texttt{tl}
%   which will be used as the key, then using this to store the value. The
%   \texttt{tl} is  set using \texttt{x}-type expansion as this will expand the
%   unit index and any additional calculations made for this.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_add:nnnn #1#2#3#4
  {
    \tl_set:Nx \l_@@_tmp_tl { #1 - #2 }
    \prop_if_in:NVTF \l_@@_parsed_prop \l_@@_tmp_tl
      { \msg_error:nnnn { siunitx / units } { duplicate-part } {#1} {#3} }
      { \prop_put:NVn \l_@@_parsed_prop \l_@@_tmp_tl {#4} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_prefix:Nn}
% \begin{macro}[int]{\@@_parse_power:nnN}
% \begin{macro}[int]{\@@_parse_qualifier:nn}
% \begin{macro}[int]{\@@_parse_special:nn}
%   Storage of the various optional items follows broadly the same pattern
%   in each case. The data to be stored is passed along with an appropriate
%   key name to the underlying storage system. The details for each type of
%   item should be relatively clear. For example, prefixes have to come before
%   their \enquote{parent} unit and so there is some adjustment to do to add
%   them to the correct unit.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_prefix:Nn #1#2
  {
    \int_set:Nn \l_@@_tmp_int { \l_@@_position_int + \c_one }
    \@@_parse_add:nnnn { prefix } { \int_use:N \l_@@_tmp_int }
      {#1} {#2}
  }
\cs_new_protected:Npn \@@_parse_power:nnN #1#2#3
  {
    \@@_parse_add:nnnn { power }
      { \int_eval:n { \l_@@_position_int \bool_if:NT #3 { + \c_one } } }
      {#1} {#2}
  }
\cs_new_protected:Npn \@@_parse_qualifier:nn #1#2
  {
    \tl_set:Nx \l_@@_tmp_tl
      { unit- \int_use:N \l_@@_position_int }
    \prop_if_in:NVTF \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \@@_parse_add:nnnn { qualifier }
          { \int_use:N \l_@@_position_int } {#1} {#2}
      }
      { \msg_error:nnn { siunitx / units } { qualifier-before-unit } {#1} }
  }
%    \end{macrocode}
%  Special (exceptional) items should always come before the relevant units.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_special:nn #1#2
  {
    \@@_parse_add:nnnn { special }
      { \int_eval:n { \l_@@_position_int + \c_one } }
      {#1} {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_unit:Nn}
%   Parsing units is slightly more involved than the other cases: this is the
%   one place where the tracking value is incremented.  If the switch
%   \cs{l_@@_per_bool} is set true then the current unit is also
%   reciprocal: this can only happen if \cs{l_@@_sticky_per_bool} is also
%   true, so only one test is required.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_unit:Nn #1#2
  {
    \int_incr:N \l_@@_position_int
    \@@_parse_add:nnnn { unit } { \int_use:N \l_@@_position_int }
      {#1} {#2}
    \bool_if:NT \l_@@_per_bool
      {
        \@@_parse_add:nnnn { per } { \int_use:N \l_@@_position_int }
          { \per } { true }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_per:}
%   Storing the \cs{per} command requires adding a data item separate from
%   the power which applies: this makes later formatting much more
%   straight-forward. This data could in principle be combined with the
%   \texttt{power}, but depending on the output format required that may make
%   life  more complex. Thus this information is stored separately for later
%   retrieval. If \cs{per} is set to be \enquote{sticky} then after parsing
%   the first occurrence, any further uses are in error.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_per:
  {
    \bool_if:NTF \l_@@_sticky_per_bool
      {
        \bool_set_true:N \l_@@_per_bool
        \cs_set_protected_nopar:Npn \per
          { \msg_error:nn { siunitx / units } { duplicate-sticky-per } }
      }
      {
        \@@_parse_add:nnnn
          { per } { \int_eval:n { \l_@@_position_int + \c_one } }
          { \per } { true }
      }
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}[int]{\@@_parse_finalise:n}
%   If \cs{per} applies to the current unit, the power needs to be multiplied
%   by $-1$. That is done using an \texttt{fp} operation so that non-integer
%   powers are supported. The flag for \cs{per} is also removed as this means
%   we don't have to check that the original power was positive. To be on
%   the safe side, there is a check for a trivial power at this stage.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_finalise:n #1
  {
    \tl_set:Nx \l_@@_tmp_tl { per- #1 }
    \prop_if_in:NVT \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \prop_remove:NV \l_@@_parsed_prop \l_@@_tmp_tl
        \tl_set:Nx \l_@@_tmp_tl { power- #1 }
        \prop_get:NVNTF \l_@@_parsed_prop \l_@@_tmp_tl
          \l_@@_part_tl
          {
            \tl_set:Nx \l_@@_part_tl
              { \fp_eval:n { \l_@@_part_tl * -1 } }
            \fp_compare:nNnTF \l_@@_part_tl = \c_one_fp
              { \prop_remove:NV \l_@@_parsed_prop \l_@@_tmp_tl }
              {
                \prop_put:NVV \l_@@_parsed_prop
                  \l_@@_tmp_tl \l_@@_part_tl
              }
          }
          { \prop_put:NVn \l_@@_parsed_prop \l_@@_tmp_tl { -1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}[int]{\@@_parse_finalise:}
%   The final task is to check that there is not a \enquote{dangling} prefix:
%   these are added to the \enquote{next} unit so are easy to test for.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_finalise:
  {
    \tl_set:Nx \l_@@_tmp_tl
      { prefix- \int_eval:n { \l_@@_position_int + \c_one } }
    \prop_if_in:NVT \l_@@_parsed_prop \l_@@_tmp_tl
      { \msg_error:nn { siunitx / units } { prefix-only } }
  }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Formatting parsed units}
% 
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnnn { siunitx / units } { duplicate-part }
  { Duplicate~#1~part~'#2'. }
  {
    Each~unit~may~have~only~one~#1:\\
    the~additional~value~'#2'~will~be~ignored.
  }
\msg_new:nnnn { siunitx / units } { duplicate-sticky-per }
  { Duplicate~\token_to_str:N \per. }
  {
    When~the~'sticky-per'~option~is~active,~only~one~
    \token_to_str:N \per \c_space_tl may~appear~in~a~unit.
  }
\msg_new:nnn { siunitx / units } { prefix-only }
  { Prefix~with~no~unit. }
\msg_new:nnnn { siunitx / units } { qualifier-before-unit }
  { Qualifier~before~unit:~'#1'. }
  {
    Unit~qualifiers~have~to~follow~after~units:~
    they~cannot~appear~before~them.\\ \\
    The~qualifier~'#1'~will~be~ignored.
  }
%    \end{macrocode}
%    
% \subsection{Standard settings for module options}
%
% Some of these follow naturally from the point of definition
% (\emph{e.g.}~boolean variables are always |false| to begin with),
% but for clarity everything is set here.
%    \begin{macrocode}
\keys_set:nn { siunitx / units }
  {
    inter-unit-product = \,    ,
    sticky-per         = false 
  }
%    \end{macrocode}
%    
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex