% \iffalse meta-comment
%
% File: siunitx-units.dtx Copyright (C) 2014 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    http://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
% 
% \GetFileInfo{siunitx.sty}
% 
% \title{^^A
%   \pkg{siunitx-units} -- Parsing and formatting units^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
% 
% \begin{documentation}
% 
% \section{Defining symbolic units}
% 
% \begin{function}{\units_set_prefix:Nnn}
%   \begin{syntax}
%     \cs{units_set_prefix:Nnn} \meta{prefix} \Arg{symbol} \Arg{power}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. The prefix
%   should represent an integer \meta{power} of $10$, and this information
%   may be used to convert from one or more \meta{prefix} symbols to an
%   overall power applying to a unit. See also \cs{units_set_prefix:Nn}.
% \end{function}
% 
% \begin{function}{\units_set_prefix:Nn}
%   \begin{syntax}
%     \cs{units_set_prefix:Nn}  \meta{prefix} \Arg{symbol}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. In contrast
%   to \cs{units_set_prefix:Nnn}, there is no assumption about the mathematical
%   nature of the \meta{prefix}, \emph{i.e.}~the prefix may represent a
%   power of any base. As a result, no conversion of the \meta{prefix} to a
%   numerical power will be possible.
% \end{function}
% 
% \begin{function}{\units_set_power:NnN}
%   \begin{syntax}
%     \cs{units_set_unit:Nn} \meta{power} \Arg{value} \meta{precedes}
%   \end{syntax}
%   Defines a symbolic \meta{power} (which should be a control sequence
%   such as |\squsred|) to be converted by the parser to the \meta{value}.
%   The latter should be an integer or floating point number in the format
%   defined for \pkg{l3fp}. Powers may precede a unit or be given after it:
%   which case applies to the \meta{power} is determined by the boolean
%   \meta{precedes}. In literal mode, the \meta{value} will be applied as
%   a superscript to either the next token in the input (\meta{precedes} 
%   true) or appended to the previously-typeset material (\meta{precedes}
%   false).
% \end{function}
% 
% \begin{function}{\units_set_qualifier:Nn}
%   \begin{syntax}
%     \cs{units_set_qualifier:Nn} \meta{qualifier} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{qualifier} (which should be a control sequence
%   such as |\catalyst|) to be converted by the parser to the \meta{meaning}.
%   The latter should consist of literal content (\emph{e.g.}~|cat|). In
%   literal mode the \meta{meaning} will be typeset following a space after
%   the unit to which it applies.
% \end{function}
% 
% \begin{function}{\units_set_unit:Nn}
%   \begin{syntax}
%     \cs{units_set_unit:Nn} \meta{unit} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{unit} (which should be a control sequence
%   such as |\kilogram|) to be converted by the parser to the \meta{meaning}.
%   The latter may consist of literal content (\emph{e.g.}~|kg|), other
%   symbolic unit commands (\emph{e.g.}~|\kilo\gram|) or a mixture of the two.
%   In literal mode the \meta{meaning} will be typeset directly.
% \end{function}
% 
% \section{Pre-defined symbolic unit components}
% 
% The unit parser is defined to recognise a number of pre-defined units,
% prefixes and powers, and also interpret a small selection of
% \enquote{generic} symbolic parts
% 
% \begin{function}{\per}
%   \begin{syntax}
%     \cs{per} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   is reciprocal, \emph{i.e.}~raises it to the power $-1$. This symbolic
%   representation may be applied in addition to a \cs{power}, and will work
%   correctly if the \cs{power} itself is negative. In literal mode \cs{per}
%   will print a slash (\enquote{$/$}).
% \end{function}
% 
% \begin{function}{\cancel}
%   \begin{syntax}
%     \cs{cancel} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be \enquote{cancelled out}. In the parsed output, the entire unit
%   combination will be given as the argument to a function \cs{cancel}, which
%   is assumed to be available at a higher level. In literal mode, the same
%   higher-level \cs{cancel} will be applied to the next token. It is the
%   responsibility of the calling code to provide an appropriate definition
%   for \cs{cancel} outside of the scope of the unit parser.
% \end{function}
% 
% \begin{function}{\highlight}
%   \begin{syntax}
%     \cs{highlight} \Arg{color} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be highlighted in the specified \meta{color}. In the parsed output,
%   the entire unit combination will be given as the argument to a function
%   \cs{textcolor}, which is assumed to be available at a higher level. In
%   literal mode, the same higher-level \cs{textcolor} will be applied to the
%   next token. It is the responsibility of the calling code to provide an
%   appropriate definition for \cs{textcolor} outside of the scope of the unit
%   parser.
% \end{function}
%
% \begin{function}{\of}
%   \begin{syntax}
%     \meta{prefix} \meta{unit} \meta{power} \cs{of} \Arg{qualifier}
%   \end{syntax}
%   Indicates that the \meta{qualifier} applies to the current
%   \meta{prefix}/\meta{unit}/\meta{power} combination. In parsed mode, the
%   display of the result will depend upon module options. In literal mode,
%   the \meta{qualifier} will be printed in parentheses following the preceding
%   \meta{unit} and a full-width space.  
% \end{function}
% 
% \begin{function}{\raiseto, \tothe}
%   \begin{syntax}
%     \cs{raiseto} \Arg{power} \meta{prefix} \meta{unit}
%     \meta{prefix} \meta{unit} \cs{tothe} \Arg{power}
%   \end{syntax}
%   Indicates that the \meta{power} applies to the current
%   \meta{prefix}/\meta{unit} combination. As shown, \cs{raiseto} applies to
%   the next \meta{unit} whereas \cs{tothe} applies to the preceding unit. In
%   literal mode the \cs{power} will be printed as a superscript attached to
%   the next token (\cs{raiseto}) or preceding token (\cs{tothe}) as 
%   appropriate.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
% 
% \section{\pkg{siunitx-units} implementation}
% 
% Start the DocStrip guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 DocStrip convention): only internal
% material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_units>
%    \end{macrocode}
%    
% \subsection{Initial set up}
%
% The mechanisms defined here need a few variables to exist and to be
% correctly set: these don't belong to one subsection and so are created
% in a small general block.
% 
% \begin{variable}[int]{\l_@@_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\tl_new:N  \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
% 
% \begin{variable}[int]{\l_@@_parsing_bool}
%   A boolean is used to indicate when the symbolic unit functions should
%   produce symbolic or literal output. This is used when the symbolic names
%   are used along with literal input, and ensures that there is a sensible
%   fall-back for these cases.
%    \begin{macrocode}
\bool_new:N \l_@@_parsing_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_test_bool}
%   A switch used to indicate that the code is testing the input to find
%   if there is any typeset output from individual unit macros. This is needed
%   to allow the \enquote{base} macros to be found, and also to pick up the
%   difference between symbolic and literal unit input.
%    \begin{macrocode}
\bool_new:N \l_@@_test_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_if_symbolic:nTF}
%   The test for symbolic units is needed in two places. First, there is the
%   case of \enquote{pre-parsing} input to check if it can be parsed. Second,
%   when parsing there is a need to check if the current unit is built up
%   from others (symbolic) or is defined in terms of some literals. To do this,
%   the approach used is to set all of the symbolic unit commands expandable
%   and to do nothing, with the few special cases handled manually. If
%   an \texttt{x}-type definition then yields nothing at all then the
%   assumption is that the input is symbolic.
%   
%   Note that as we are dealing with arbitrary \LaTeXe{} input, there is the
%   need to use \cs{protected@edef} here: in a \enquote{pure} \LaTeX3 version
%   that would replaced by \cs{tl_set:Nx}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_symbolic:n #1 { TF }
  {
    \group_begin:
      \bool_set_true:N \l_@@_test_bool
      \protected@edef \l_@@_tmp_tl {#1}
    \exp_args:NNV \group_end:
    \tl_if_blank:nTF \l_@@_tmp_tl
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Defining symbolic unit}
%
% Unit macros and related support are created here. These exist only within
% the scope of the unit processor code, thus not polluting document-level
% namespace and allowing overlap with other areas in the case of useful short
% names (for example \cs{pm}). Setting up the mechanisms to allow this requires
% a few additional steps on top of simply saving the data given by the user
% in creating the unit.
% 
% \begin{variable}[int]{\l_@@_symbolic_seq}
%   A list of all of the symbolic units, \emph{etc.}, set up. This is needed
%   to allow the symbolic names to be defined within the scope of the unit
%   parser but not elsewhere using simple mappings.
%    \begin{macrocode}
\seq_new:N \l_@@_symbolic_seq
%    \end{macrocode}
% \end{variable}
% 
% \begin{macro}[int]{\@@_set_symbolic:Nnn}
% \begin{macro}[int]{\@@_set_symbolic:Npnn}
% \begin{macro}[aux]{\@@_set_symbolic:NNpnn}
%   The majority of the work for saving each symbolic definition is the same
%   irrespective of the item being defined (unit, prefix, power, qualifier).
%   This is therefore all carried out in a single internal function which
%   does the common tasks. The three arguments here are the symbolic macro
%   name, the literal output and the code to insert when doing full unit
%   parsing. To allow for the \enquote{special cases} (where arguments are
%   required) the entire mechanism is set up in a two-part fashion allowing
%   for flexibility at the slight cost of additional functions.
%   
%   Importantly, notice that the unit macros are declared as expandable. This
%   is required so that literals can be correctly converted into a token list
%   of material which does not depend on local redefinitions for the unit
%   macros. That is required so that the unit formatting system can be grouped.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_symbolic:Nnn #1
  { \@@_set_symbolic:NNnnn \cs_set_nopar:cpn #1 { } }
\cs_new_protected:Npn \@@_set_symbolic:Npnn #1#2#
  { \@@_set_symbolic:NNnnn \cs_set:cpn #1 {#2} }
\cs_new_protected:Npn \@@_set_symbolic:NNnnn #1#2#3#4#5
  {
    \seq_put_right:Nn \l_@@_symbolic_seq {#2}
    #1 { units ~ > ~ \token_to_str:N #2 } #3
      {
        \bool_if:NF \l_@@_test_bool
          {
            \bool_if:NTF \l_@@_parsing_bool
              {#5}
              {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\siunitx_units_set_power:NnN}
%   For powers, there is the slight complication that the symbolic name may
%   appear either before or after the unit it applies to, and these two
%   different cases need slightly different code for the literal case. A
%   boolean is used to determine which case is in operation, and in parsing
%   mode this data is passed directly to the underlying function.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_power:NnN #1#2#3
  {
    \bool_if:NTF #3
      {
        \@@_set_symbolic:Nnn #1
          { \@@_literal_power:nN {#1} }
      }
      {
        \@@_set_symbolic:Nnn #1
          { ^ {#2} }
      }
        { \@@_parse_power:nnN {#1} {#2} #3 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_prefix:Nn}
% \begin{macro}{\siunitx_units_set_prefix:Nnn}
% \begin{variable}[int]
%   {\l_@@_prefixes_forward_prop, \l_@@_prefixes_reverse_prop}
%   For prefixes there are a couple of options. In all cases, the basic
%   requirement is to set up to parse the prefix using the appropriate
%   internal function. For prefixes which are powers of $10$, there is also
%   the need to be able to do conversion to/from the numerical equivalent.
%   That is handled using two properly lists which can be used to supply
%   the conversion data later.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_prefix:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      { \@@_parse_prefix:Nn #1 {#2} }
  }
\cs_new_protected:Npn \siunitx_units_set_prefix:Nnn #1#2#3
  {
    \units_set_prefix:Nn #1 {#2}
    \prop_put:Nnn \l_@@_prefixes_forward_prop {#2} {#3}
    \prop_put:Nnn \l_@@_prefixes_reverse_prop {#3} {#2}
  }
\prop_new:N \l_@@_prefixes_forward_prop
\prop_new:N \l_@@_prefixes_reverse_prop
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_qualifier:Nn}
%   Qualifiers are relatively easy to handle: nothing to do other than save
%   the input appropriately.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_qualifier:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      { \  ( #2 ) }
      { \@@_parse_qualifier:nn {#1} {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_unit:Nn}
%   For the unit parsing, allowing for variations in definition order requires
%   that a test is made for the output of each unit at point of use.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_unit:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      {
        \@@_if_symbolic:nTF {#2}
          {#2}
          { \@@_parse_unit:Nn #1 {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Non-standard symbolic units}
%
% A few of the symbolic units require non-standard definitions: these are
% created here. They all use parts of the more general code but have particular
% requirements which can only be addressed by hand. Some of these could in
% principle be used in place of the dedicated definitions above, but at point
% of use that would then require additional expansions for each unit parsed:
% as the macro names would still be needed, this does not offer any real
% benefits.
%
% \begin{macro}{\per}
%   The \cs{per} symbolic unit is a bit special: it has a mechanism entirely
%   different from everything else, so has to be set up by hand. In literal
%   mode it is represented by a very simple symbol!
%    \begin{macrocode}
\@@_set_symbolic:Nnn \per
  { / }
  { \@@_parse_per: }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\cancel}
% \begin{macro}{\highlight}
%   The two special cases, \cs{cancel} and \cs{highlight}, are easy to deal
%   with when parsing. When not parsing, a precaution is taken to ensure that
%   the user level equivalents always get a braced argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \cancel
  { \@@_literal_special:nN { \cancel } }
  { \@@_parse_special:n { \cancel } }
\@@_set_symbolic:Npnn \highlight #1
  { \@@_literal_special:nN { \textcolor {#1} } }
  { \@@_parse_special:n { \textcolor {#1} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \begin{macro}{\of}
%   The generic qualifier is simply the same as the dedicated ones except for
%   needing to grab an argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \of #1
  { \  ( #1 ) }
  { \@@_parse_qualifier:nn { \of {#1} } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\raiseto, \tothe}
%   Generic versions of the pre-defined power macros. These require an
%   argument and so cannot be handled using the general approach. Other than
%   that, the code here is very similar to that in
%   \cs{siunitx_units_set_power:NnN}.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \raiseto #1
  { \@@_literal_power:nN {#1} }
  { \@@_parse_power:nnN { \raiseto {#1} } {#1} \c_true_bool }
\@@_set_symbolic:Npnn \tothe #1
  { ^ {#1} }
  { \@@_parse_power:nnN { \tothe {#1} } {#1} \c_false_bool }
%    \end{macrocode}
% \end{macro}
% 
% \subsection{Main formatting routine}
%
% Unit input can take two forms, \enquote{literal} units (material to be
% typeset directly) or \enquote{symbolic} units (macro-based). Before any
% parsing or typesetting is carried out, a small amount of pre-parsing has to
% be carried out to decide which of these cases applies.
% 
% \begin{variable}[int]{\l_@@_formatted_tl}
%   A token list for the final formatted result: may or may not be generated
%   by the parser, depending on the nature of the input.
%    \begin{macrocode}
\tl_new:N \l_@@_formatted_tl
%    \end{macrocode}
% \end{variable}
% 
% \subsection{Formatting literal units}
% 
% While in literal mode no parsing occurs, there is a need to provide a few
% auxiliary functions to handle one or two special cases.
% 
% \subsection{Parsing symbolic units}
%
% Parsing units takes place by storing information about each unit in a
% \texttt{prop}. As well as the unit itself, there are various other optional
% data points, for example a prefix or a power. Some of these can come before
% the unit, others only after. The parser therefore tracks the number of units
% read and uses the current position to allocate data to individual units.
% 
% \subsection{Formatting parsed units}
% 
% \subsection{Messages}
%    
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex