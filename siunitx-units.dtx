% \iffalse meta-comment
%
% File: siunitx-units.dtx Copyright (C) 2014 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    http://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{siunitx.sty}
%
% \title{^^A
%   \pkg{siunitx-units} -- Parsing and formatting units^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%
% This submodule is dedicated to formatting physical units. The main function,
% \cs{siunitx_units_format:nN}, takes user input specify physical units and
% converts it into a formatted token list suitable for typesetting in math
% mode. While the formatter will deal correctly with \enquote{literal} user
% input, the key strength of the module is providing a method to describe
% physical units in a \enquote{symbolic} manner. The output format of these
% symbolic units can then be controlled by a number of key--value options
% made available by the module.
%
% A small number of \LaTeXe{} math mode commands are assumed to be available
% as part of the formatted output. In particular, \cs{sb} and \cs{sp} are used
% to represent sub/superscripts in the formatted output: this avoids the need
% to take account of category codes for |_| and |^| and allows application of
% further \enquote{effects} at a higher level. The \cs{mathchoice} command
% (normally the \TeX{} primitive) is needed when using
% |per-mode = symbol-or-fraction|. The commands \cs{frac}, \cs{mathrm},
% \cs{mbox}, \verb*|\ | and \cs{,} are used by the standard module settings,
% and \cs{ensuremath}, \cs{hbar} and \cs{mathrm} in some standard unit
% defintions (for atomic and natural units). For the display of colored
% (highlighted) and cancelled units, the commands \cs{textcolor} and
% \cs{cancel} are assumed to be available.
%
% \section{Formatting units}
%
% \begin{function}{\siunitx_units_format:nN}
%   \begin{syntax}
%     \cs{siunitx_units_format:nN} \Arg{units} \meta{tl~var}
%   \end{syntax}
%   Parses the \meta{units}, which may either be symbolic or literal as
%   described elsewhere, and
% \end{function}
%
% \begin{function}{\siunitx_units_format:nNN}
%   \begin{syntax}
%     \cs{siunitx_units_format:nNN} \Arg{units} \meta{tl~var} \meta{fp~var}
%   \end{syntax}
% \end{function}
% 
% \begin{variable}{\l_siunitx_units_font_tl}
%   Stores the command applied to text during output of units: the content
%   should be command usable in math mode for font selection. This variable is
%   equivalent to the |font-command| key, but is available directly as this
%   allows rapid setting by higher-level systems which detect font usage. 
% \end{variable}
%
% \section{Defining symbolic units}
%
% \begin{function}{\siunitx_units_set_prefix:Nnn}
%   \begin{syntax}
%     \cs{siunitx_units_set_prefix:Nnn} \meta{prefix} \Arg{symbol} \Arg{power}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. The prefix
%   should represent an integer \meta{power} of $10$, and this information
%   may be used to convert from one or more \meta{prefix} symbols to an
%   overall power applying to a unit. See also
%   \cs{siunitx_units_set_prefix:Nn}.
% \end{function}
%
% \begin{function}{\siunitx_units_set_prefix:Nn}
%   \begin{syntax}
%     \cs{siunitx_units_set_prefix:Nn}  \meta{prefix} \Arg{symbol}
%   \end{syntax}
%   Defines a symbolic \meta{prefix} (which should be a control sequence
%   such as |\kilo|) to be converted by the parser to the \meta{symbol}.
%   The latter should consist of literal content (\emph{e.g.}~|k|).
%   In literal mode the \meta{symbol} will be typeset directly. In contrast
%   to \cs{siunitx_units_set_prefix:Nnn}, there is no assumption about the
%   mathematical nature of the \meta{prefix}, \emph{i.e.}~the prefix may
%   represent a power of any base. As a result, no conversion of the
%   \meta{prefix} to a numerical power will be possible.
% \end{function}
%
% \begin{function}{\siunitx_units_set_power:NnN}
%   \begin{syntax}
%     \cs{siunitx_units_set_unit:Nn} \meta{power} \Arg{value} \meta{precedes}
%   \end{syntax}
%   Defines a symbolic \meta{power} (which should be a control sequence
%   such as |\squsred|) to be converted by the parser to the \meta{value}.
%   The latter should be an integer or floating point number in the format
%   defined for \pkg{l3fp}. Powers may precede a unit or be given after it:
%   which case applies to the \meta{power} is determined by the boolean
%   \meta{precedes}. In literal mode, the \meta{value} will be applied as
%   a superscript to either the next token in the input (\meta{precedes}
%   true) or appended to the previously-typeset material (\meta{precedes}
%   false).
% \end{function}
%
% \begin{function}{\siunitx_units_set_qualifier:Nn}
%   \begin{syntax}
%     \cs{siunitx_units_set_qualifier:Nn} \meta{qualifier} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{qualifier} (which should be a control sequence
%   such as |\catalyst|) to be converted by the parser to the \meta{meaning}.
%   The latter should consist of literal content (\emph{e.g.}~|cat|). In
%   literal mode the \meta{meaning} will be typeset following a space after
%   the unit to which it applies.
% \end{function}
%
% \begin{function}{\siunitx_units_set_unit:Nn}
%   \begin{syntax}
%     \cs{siunitx_units_set_unit:Nn} \meta{unit} \Arg{meaning}
%   \end{syntax}
%   Defines a symbolic \meta{unit} (which should be a control sequence
%   such as |\kilogram|) to be converted by the parser to the \meta{meaning}.
%   The latter may consist of literal content (\emph{e.g.}~|kg|), other
%   symbolic unit commands (\emph{e.g.}~|\kilo\gram|) or a mixture of the two.
%   In literal mode the \meta{meaning} will be typeset directly.
% \end{function}
%
% \section{Pre-defined symbolic unit components}
%
% The unit parser is defined to recognise a number of pre-defined units,
% prefixes and powers, and also interpret a small selection of
% \enquote{generic} symbolic parts
%
% \begin{function}{\per}
%   \begin{syntax}
%     \cs{per} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   is reciprocal, \emph{i.e.}~raises it to the power $-1$. This symbolic
%   representation may be applied in addition to a \cs{power}, and will work
%   correctly if the \cs{power} itself is negative. In literal mode \cs{per}
%   will print a slash (\enquote{$/$}).
% \end{function}
%
% \begin{function}{\cancel}
%   \begin{syntax}
%     \cs{cancel} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be \enquote{cancelled out}. In the parsed output, the entire unit
%   combination will be given as the argument to a function \cs{cancel}, which
%   is assumed to be available at a higher level. In literal mode, the same
%   higher-level \cs{cancel} will be applied to the next token. It is the
%   responsibility of the calling code to provide an appropriate definition
%   for \cs{cancel} outside of the scope of the unit parser.
% \end{function}
%
% \begin{function}{\highlight}
%   \begin{syntax}
%     \cs{highlight} \Arg{color} \meta{prefix} \meta{unit} \meta{power}
%   \end{syntax}
%   Indicates that the next \meta{prefix}/\meta{unit}/\meta{power} combination
%   should be highlighted in the specified \meta{color}. In the parsed output,
%   the entire unit combination will be given as the argument to a function
%   \cs{textcolor}, which is assumed to be available at a higher level. In
%   literal mode, the same higher-level \cs{textcolor} will be applied to the
%   next token. It is the responsibility of the calling code to provide an
%   appropriate definition for \cs{textcolor} outside of the scope of the unit
%   parser.
% \end{function}
%
% \begin{function}{\of}
%   \begin{syntax}
%     \meta{prefix} \meta{unit} \meta{power} \cs{of} \Arg{qualifier}
%   \end{syntax}
%   Indicates that the \meta{qualifier} applies to the current
%   \meta{prefix}/\meta{unit}/\meta{power} combination. In parsed mode, the
%   display of the result will depend upon module options. In literal mode,
%   the \meta{qualifier} will be printed in parentheses following the preceding
%   \meta{unit} and a full-width space.
% \end{function}
%
% \begin{function}{\raiseto, \tothe}
%   \begin{syntax}
%     \cs{raiseto} \Arg{power} \meta{prefix} \meta{unit}
%     \meta{prefix} \meta{unit} \cs{tothe} \Arg{power}
%   \end{syntax}
%   Indicates that the \meta{power} applies to the current
%   \meta{prefix}/\meta{unit} combination. As shown, \cs{raiseto} applies to
%   the next \meta{unit} whereas \cs{tothe} applies to the preceding unit. In
%   literal mode the \cs{power} will be printed as a superscript attached to
%   the next token (\cs{raiseto}) or preceding token (\cs{tothe}) as
%   appropriate.
% \end{function}
%
% \subsection{Key--value options}
%
% The options defined by this submodule are available within the \pkg{l3keys}
% |siunitx/units| tree.
%
% \begin{function}{bracket-denominator}
%   \begin{syntax}
%     |bracket-denominator| = \meta{symbol}
%   \end{syntax}
%   Switch to determine whether brackets are added to the denominator part of
%   a unit when printed in fractional form. The standard setting is |false|.
% \end{function}
%
% \begin{function}{close-bracket}
%   \begin{syntax}
%     |close-bracket| = |true|\verb"|"|false|
%   \end{syntax}
%   Bracket symbol used to close a matched pair around units when once is
%   required to maintain mathematical logic. The standard setting is ^^A (
%   |)|.
% \end{function}
% 
% \begin{function}{font-command}
%   \begin{syntax}
%     |font-command| = \meta{command}
%   \end{syntax}
%   Command applied to text during output of units: should be command usable
%   in math mode for font selection. The standard setting is |\mathrm|. See
%   also \cs{l_siunitx_units_font_tl}.
% \end{function}
%
% \begin{function}{fraction-command}
%   \begin{syntax}
%     |fraction-command| = \meta{command}
%   \end{syntax}
%   Command used to create fractional output when |per-mode| is set to
%   |fraction|. The standard setting is |\frac|.
% \end{function}
%
% \begin{function}{open-bracket}
%   \begin{syntax}
%     |open-bracket| = \meta{symbol}
%   \end{syntax}
%   Bracket symbol used to open a matched pair around units when once is
%   required to maintain mathematical logic. The standard setting is |(|. ^^A )
% \end{function}
%
% \begin{function}{inter-unit-product}
%   \begin{syntax}
%     |inter-unit-product| = \meta{separator}
%   \end{syntax}
%   Inserted between unit combinations in parsed mode, and used to replace
%   |.| and |~| in literal mode. The standard setting is |\,|.
% \end{function}
%
% \begin{function}{per-mode}
%   \begin{syntax}
%     |per-mode| = \meta{choice}
%   \end{syntax}
%   Selects how the negative powers (\cs{per}) are formatted: a choice from
%   the options |fraction|, |power|, |power-positive-first|, |repeated-symbol|,
%   |symbol| and |symbol-or-fraction|. The option |fraction| generates
%   fractional output when appropriate using the command specified by
%   the |fraction-command| option. The setting |power| uses reciprocal powers
%   leaving the units in the order of input, while |power-positive-first| uses
%   the same display format but sorts units such that the positive powers
%   come before negative ones. The |symbol| setting uses a symbol (specified
%   by |per-symbol|) between positive and negative powers, while
%   |repeated-symbol| uses the same symbol but places it before \emph{every}
%   unit with a negative power (this is mathematically \enquote{wrong} but
%   often seen in real work). Finally, |symbol-or-fraction| acts like
%   |symbol| for inline output and like |fraction| when the output is used
%   in a display math environment. The standard setting is |power|.
% \end{function}
%
% \begin{function}{per-symbol}
%   \begin{syntax}
%     |per-symbol| = \meta{symbol}
%   \end{syntax}
%   Specifies the symbol to be used to denote negative powers when the option
%   |per-mode| is set to |repeated-symbol|, |symbol| or |symbol-or-fraction|.
%   The standard setting is |/|.
% \end{function}
%
% \begin{function}{qualifier-mode}
%   \begin{syntax}
%     |qualifier-mode| = \meta{choice}
%   \end{syntax}
%   Selects how qualifiers are formatted: a choice from the options |brackets|,
%   |phrase|, |space|, |subscript| and |text|. The option |brackets| wraps the
%   qualifier in parenthesis, |phrase| inserts a textual linker (see
%   |qualifier-phrase|), |space| introduces a space between the two items,
%   |subscript| formats the qualifier as a subscript and |text| inserts the
%   qualifier with no additional formatting. The standard setting is
%   |subscript|.
% \end{function}
%
% \begin{function}{qualifier-phrase}
%   \begin{syntax}
%     |qualifier-phrase| = \meta{text}
%   \end{syntax}
%   Specifies the \meta{text} inserted between a unit and associated qualifier
%   when |qualifier-mode| is set to |phrase|. The standard setting is
%   \verb*|\ of\ |.
% \end{function}
%
% \begin{function}{sticky-per}
%   \begin{syntax}
%     |sticky-per| = |true|\verb"|"|false|
%   \end{syntax}
%   Used to determine whether \cs{per} should be applied one a unit-by-unit
%   basis (when |false|) or should apply to all following units
%   (when |true|). The latter mode is somewhat akin conceptually to the
%   \TeX{} \cs{over} primitive. The standard setting is |false|.
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{siunitx-units} implementation}
%
% Start the DocStrip guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 DocStrip convention): only internal
% material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_units>
%    \end{macrocode}
%
% \subsection{Initial set up}
%
% The mechanisms defined here need a few variables to exist and to be
% correctly set: these don't belong to one subsection and so are created
% in a small general block.
%
%   Variants not provided by \pkg{expl3}.
%    \begin{macrocode}
\cs_generate_variant:Nn \tl_replace_all:Nnn { NnV }
%    \end{macrocode}
%
% \begin{variable}[int]{\l_@@_tmp_fp}
% \begin{variable}[int]{\l_@@_tmp_int}
% \begin{variable}[int]{\l_@@_tmp_tl}
%   Scratch space.
%    \begin{macrocode}
\fp_new:N \l_@@_tmp_fp
\int_new:N \l_@@_tmp_int
\tl_new:N  \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_parsing_bool}
%   A boolean is used to indicate when the symbolic unit functions should
%   produce symbolic or literal output. This is used when the symbolic names
%   are used along with literal input, and ensures that there is a sensible
%   fall-back for these cases.
%    \begin{macrocode}
\bool_new:N \l_@@_parsing_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_test_bool}
%   A switch used to indicate that the code is testing the input to find
%   if there is any typeset output from individual unit macros. This is needed
%   to allow the \enquote{base} macros to be found, and also to pick up the
%   difference between symbolic and literal unit input.
%    \begin{macrocode}
\bool_new:N \l_@@_test_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_if_symbolic:nTF}
%   The test for symbolic units is needed in two places. First, there is the
%   case of \enquote{pre-parsing} input to check if it can be parsed. Second,
%   when parsing there is a need to check if the current unit is built up
%   from others (symbolic) or is defined in terms of some literals. To do this,
%   the approach used is to set all of the symbolic unit commands expandable
%   and to do nothing, with the few special cases handled manually. If
%   an \texttt{x}-type definition then yields nothing at all then the
%   assumption is that the input is symbolic.
%
%   Note that as we are dealing with arbitrary \LaTeXe{} input, there is the
%   need to use \cs{protected@edef} here: in a \enquote{pure} \LaTeX3 version
%   that would replaced by \cs{tl_set:Nx}.
%    \begin{macrocode}
\prg_new_protected_conditional:Npnn \@@_if_symbolic:n #1 { TF }
  {
    \group_begin:
      \bool_set_true:N \l_@@_test_bool
      \protected@edef \l_@@_tmp_tl {#1}
    \exp_args:NNV \group_end:
    \tl_if_blank:nTF \l_@@_tmp_tl
      { \prg_return_true: }
      { \prg_return_false: }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Defining symbolic unit}
%
% Unit macros and related support are created here. These exist only within
% the scope of the unit processor code, thus not polluting document-level
% namespace and allowing overlap with other areas in the case of useful short
% names (for example \cs{pm}). Setting up the mechanisms to allow this requires
% a few additional steps on top of simply saving the data given by the user
% in creating the unit.
%
% \begin{variable}[int]{\l_@@_symbolic_seq}
%   A list of all of the symbolic units, \emph{etc.}, set up. This is needed
%   to allow the symbolic names to be defined within the scope of the unit
%   parser but not elsewhere using simple mappings.
%    \begin{macrocode}
\seq_new:N \l_@@_symbolic_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[int]{\@@_set_symbolic:Nnn}
% \begin{macro}[int]{\@@_set_symbolic:Npnn}
% \begin{macro}[aux]{\@@_set_symbolic:NNpnn}
%   The majority of the work for saving each symbolic definition is the same
%   irrespective of the item being defined (unit, prefix, power, qualifier).
%   This is therefore all carried out in a single internal function which
%   does the common tasks. The three arguments here are the symbolic macro
%   name, the literal output and the code to insert when doing full unit
%   parsing. To allow for the \enquote{special cases} (where arguments are
%   required) the entire mechanism is set up in a two-part fashion allowing
%   for flexibility at the slight cost of additional functions.
%
%   Importantly, notice that the unit macros are declared as expandable. This
%   is required so that literals can be correctly converted into a token list
%   of material which does not depend on local redefinitions for the unit
%   macros. That is required so that the unit formatting system can be grouped.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_set_symbolic:Nnn #1
  { \@@_set_symbolic:NNnnn \cs_set_nopar:cpn #1 { } }
\cs_new_protected:Npn \@@_set_symbolic:Npnn #1#2#
  { \@@_set_symbolic:NNnnn \cs_set:cpn #1 {#2} }
\cs_new_protected:Npn \@@_set_symbolic:NNnnn #1#2#3#4#5
  {
    \seq_put_right:Nn \l_@@_symbolic_seq {#2}
    #1 { units ~ > ~ \token_to_str:N #2 } #3
      {
        \bool_if:NF \l_@@_test_bool
          {
            \bool_if:NTF \l_@@_parsing_bool
              {#5}
              {#4}
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_power:NnN}
%   For powers, there is the slight complication that the symbolic name may
%   appear either before or after the unit it applies to, and these two
%   different cases need slightly different code for the literal case. A
%   boolean is used to determine which case is in operation, and in parsing
%   mode this data is passed directly to the underlying function.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_power:NnN #1#2#3
  {
    \bool_if:NTF #3
      {
        \@@_set_symbolic:Nnn #1
          { \@@_literal_power:nN {#1} }
      }
      {
        \@@_set_symbolic:Nnn #1
          { ^ {#2} }
      }
        { \@@_parse_power:nnN {#1} {#2} #3 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_prefix:Nn}
% \begin{macro}{\siunitx_units_set_prefix:Nnn}
% \begin{variable}[int]
%   {\l_@@_prefixes_forward_prop, \l_@@_prefixes_reverse_prop}
%   For prefixes there are a couple of options. In all cases, the basic
%   requirement is to set up to parse the prefix using the appropriate
%   internal function. For prefixes which are powers of $10$, there is also
%   the need to be able to do conversion to/from the numerical equivalent.
%   That is handled using two properly lists which can be used to supply
%   the conversion data later.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_prefix:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      { \@@_parse_prefix:Nn #1 {#2} }
  }
\cs_new_protected:Npn \siunitx_units_set_prefix:Nnn #1#2#3
  {
    \siunitx_units_set_prefix:Nn #1 {#2}
    \prop_put:Nnn \l_@@_prefixes_forward_prop {#2} {#3}
    \prop_put:Nnn \l_@@_prefixes_reverse_prop {#3} {#2}
  }
\prop_new:N \l_@@_prefixes_forward_prop
\prop_new:N \l_@@_prefixes_reverse_prop
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_qualifier:Nn}
%   Qualifiers are relatively easy to handle: nothing to do other than save
%   the input appropriately.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_qualifier:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      { \  ( #2 ) }
      { \@@_parse_qualifier:nn {#1} {#2} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\siunitx_units_set_unit:Nn}
%   For the unit parsing, allowing for variations in definition order requires
%   that a test is made for the output of each unit at point of use.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_set_unit:Nn #1#2
  {
    \@@_set_symbolic:Nnn #1
      {#2}
      {
        \@@_if_symbolic:nTF {#2}
          {#2}
          { \@@_parse_unit:Nn #1 {#2} }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Non-standard symbolic units}
%
% A few of the symbolic units require non-standard definitions: these are
% created here. They all use parts of the more general code but have particular
% requirements which can only be addressed by hand. Some of these could in
% principle be used in place of the dedicated definitions above, but at point
% of use that would then require additional expansions for each unit parsed:
% as the macro names would still be needed, this does not offer any real
% benefits.
%
% \begin{macro}{\per}
%   The \cs{per} symbolic unit is a bit special: it has a mechanism entirely
%   different from everything else, so has to be set up by hand. In literal
%   mode it is represented by a very simple symbol!
%    \begin{macrocode}
\@@_set_symbolic:Nnn \per
  { / }
  { \@@_parse_per: }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\cancel}
% \begin{macro}{\highlight}
%   The two special cases, \cs{cancel} and \cs{highlight}, are easy to deal
%   with when parsing. When not parsing, a precaution is taken to ensure that
%   the user level equivalents always get a braced argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \cancel
  { \@@_literal_special:nN { \cancel } }
  { \@@_parse_special:n { \cancel } }
\@@_set_symbolic:Npnn \highlight #1
  { \@@_literal_special:nN { \textcolor {#1} } }
  { \@@_parse_special:n { \textcolor {#1} } }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}{\of}
%   The generic qualifier is simply the same as the dedicated ones except for
%   needing to grab an argument.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \of #1
  { \  ( #1 ) }
  { \@@_parse_qualifier:nn { \of {#1} } {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\raiseto, \tothe}
%   Generic versions of the pre-defined power macros. These require an
%   argument and so cannot be handled using the general approach. Other than
%   that, the code here is very similar to that in
%   \cs{siunitx_units_set_power:NnN}.
%    \begin{macrocode}
\@@_set_symbolic:Npnn \raiseto #1
  { \@@_literal_power:nN {#1} }
  { \@@_parse_power:nnN { \raiseto {#1} } {#1} \c_true_bool }
\@@_set_symbolic:Npnn \tothe #1
  { ^ {#1} }
  { \@@_parse_power:nnN { \tothe {#1} } {#1} \c_false_bool }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Main formatting routine}
%
% Unit input can take two forms, \enquote{literal} units (material to be
% typeset directly) or \enquote{symbolic} units (macro-based). Before any
% parsing or typesetting is carried out, a small amount of pre-parsing has to
% be carried out to decide which of these cases applies.
%
% \begin{variable}{\l_siunitx_units_font_tl}
% \begin{variable}[int]{\l_@@_product_tl}
%   Options which apply to the main formatting routine, and so are not tided
%   to either symbolic or literal input.
%    \begin{macrocode}
\keys_define:nn { siunitx / units }
  {
    font-command       .tl_set:N = \l_siunitx_units_font_tl ,
    inter-unit-product .tl_set:N = \l_@@_product_tl
  }
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_formatted_tl}
%   A token list for the final formatted result: may or may not be generated
%   by the parser, depending on the nature of the input.
%    \begin{macrocode}
\tl_new:N \l_@@_formatted_tl
%    \end{macrocode}
% \end{variable}
%
% \subsection{Formatting literal units}
%
% While in literal mode no parsing occurs, there is a need to provide a few
% auxiliary functions to handle one or two special cases.
%
% \begin{macro}[int]{\@@_literal_power:nN}
%   For printing literal units which are given before the unit they apply to,
%   there is a slight rearrangement.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_literal_power:nN #1#2 { #2 ^ {#1} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_literal_special:nN}
%   When dealing with the special cases, there is an argument to absorb. This
%   should be braced to be passed up to the user level, which is dealt with
%   here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_literal_special:nN #1#2 { #1 {#2} }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_literal:n}
%   To format literal units, there are two tasks to do. The input is
%   \texttt{x}-type expanded to force any symbolic units to be converted into
%   their literal representation: this requires setting the appropriate
%   switch. In the resulting token list, all |.| and |~| tokens are then
%   replaced by the current unit product token list. To enable this to happen
%   correctly with a normal (active) |~|, a small amount of
%   \enquote{protection} is needed first. The same is true fro \cs{sb} and
%   \cs{sp} as they may be made expandable by the \pkg{mathstyle} package.
%
%   The series of \cs{tl_replace_all:Nnn} are needed as if the output ends up
%   inside for example \cs{textrm} then math mode sub/superscripts cannot be
%   used. Replacing them all here is done using two category codes: the normal
%   \LaTeXe{} ones and as \enquote{other} characters. The reason for the latter
%   is that most packages that carry out \enquote{special effects} with these
%   chars use mathcode rather than catcode to alter behaviour.
%
%   As with other code dealing with user input, \cs{protected@edef} is used
%   here rather than \cs{tl_set:Nx} as \LaTeXe{} robust commands may be
%   present.
%    \begin{macrocode}
\group_begin:
  \char_set_catcode_active:n { `\~ }
  \char_set_catcode_math_subscript:n { `\= }
  \char_set_lccode:nn { `\+ } { `\^ }
  \char_set_lccode:nn { `\= } { `\_ }
  \tl_to_lowercase:n
    {
      \group_end:
      \cs_new_protected:Npn \@@_format_literal:n #1
        {
          \group_begin:
            \bool_set_false:N \l_@@_parsing_bool
            \tl_replace_all:NnV \l_@@_formatted_tl { . }
              \l_@@_product_tl
            \tl_replace_all:NnV \l_@@_formatted_tl { ~ }
              \l_@@_product_tl
            \tl_replace_all:Nnn \l_@@_formatted_tl { ^ } { \sp }
            \tl_replace_all:Nnn \l_@@_formatted_tl { + } { \sp }
            \tl_replace_all:Nnn \l_@@_formatted_tl { _ } { \sb }
            \tl_replace_all:Nnn \l_@@_formatted_tl { = } { \sb }
            \cs_set_protected_nopar:Npn \sb { }
            \cs_set_protected_nopar:Npn \sp { }
            \protected@edef \l_@@_formatted_tl
              { \exp_not:V \l_siunitx_units_font_tl {#1} }
          \exp_args:NNNV \group_end:
          \tl_set:Nn \l_@@_formatted_tl \l_@@_formatted_tl
        }
    }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Parsing symbolic units}
%
% Parsing units takes place by storing information about each unit in a
% \texttt{prop}. As well as the unit itself, there are various other optional
% data points, for example a prefix or a power. Some of these can come before
% the unit, others only after. The parser therefore tracks the number of units
% read and uses the current position to allocate data to individual units.
%
% The result of parsing is a property list (\cs{l_@@_parsed_prop}) which
% contains one or more entries for each unit:
% \begin{itemize}
%   \item \texttt{prefix-$n$} The symbol for the prefix which applies to this
%     unit, \emph{e.g.} for \cs{kilo} with (almost certainly) would be
%     |k|.
%   \item \texttt{unit-$n$} The symbol for the unit itself, \emph{e.g.}~for
%     \cs{metre} with (almost certainly) would be |m|.
%   \item \texttt{power-$n$} The power which a unit is raised to. During
%     initial parsing this will (almost certainly) be positive, but is combined
%     with \texttt{per-$n$} to give a \enquote{fully qualified} power before
%     any formatting takes place
%   \item \texttt{per-$n$} Indicates that \texttt{per} applies to the current
%     unit: stored during initial parsing then combined with \texttt{power-$n$}
%     (and removed from the list) before further work.
%   \item \texttt{qualifier-$n$} Any qualifier which applies to the current
%     unit.
%   \item \texttt{special-$n$} Any \enquote{special effect} to apply to the
%     current unit.
% \end{itemize}
%
% \begin{variable}[int]{\l_@@_sticky_per_bool}
%   There is one option when \emph{parsing} the input (as opposed to
%   \emph{formatting} for output): how to deal with \cs{per}.
%    \begin{macrocode}
\keys_define:nn { siunitx / units }
  {
    sticky-per .bool_set:N = \l_@@_sticky_per_bool
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_parsed_prop}
% \begin{variable}[int]{\l_@@_per_bool}
% \begin{variable}[int]{\l_@@_position_int}
%   Parsing units requires a small number of variables are available: a
%   \texttt{prop} for the parsed units themselves, a \texttt{bool} to
%   indicate if \cs{per} is active and an \texttt{int} to track how many units
%   have be parsed.
%    \begin{macrocode}
\prop_new:N \l_@@_parsed_prop
\bool_new:N \l_@@_per_bool
\int_new:N \l_@@_position_int
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \end{variable}
%
% \begin{macro}[int]{\@@_parse:n}
%   The main parsing function is quite simple. After initialising the variables,
%   each symbolic unit is set up. The input is then simply inserted into the
%   input stream: the symbolic units themselves then do the real work of
%   placing data into the parsing system. There is then a bit of tidying up to
%   ensure that later stages can rely on the nature of the data here.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse:n #1
  {
    \prop_clear:N \l_@@_parsed_prop
    \bool_set_true:N \l_@@_parsing_bool
    \bool_set_false:N \l_@@_per_bool
    \bool_set_false:N \l_@@_test_bool
    \int_zero:N \l_@@_position_int
    #1
    \int_step_inline:nnnn \c_one \c_one \l_@@_position_int
      { \@@_parse_finalise:n {##1} }
    \@@_parse_finalise:
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_add:nnnn}
%   In all cases, storing a data item requires setting a temporary \texttt{tl}
%   which will be used as the key, then using this to store the value. The
%   \texttt{tl} is  set using \texttt{x}-type expansion as this will expand the
%   unit index and any additional calculations made for this.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_add:nnnn #1#2#3#4
  {
    \tl_set:Nx \l_@@_tmp_tl { #1 - #2 }
    \prop_if_in:NVTF \l_@@_parsed_prop \l_@@_tmp_tl
      { \msg_error:nnnn { siunitx / units } { duplicate-part } {#1} {#3} }
      { \prop_put:NVn \l_@@_parsed_prop \l_@@_tmp_tl {#4} }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_prefix:Nn}
% \begin{macro}[int]{\@@_parse_power:nnN}
% \begin{macro}[int]{\@@_parse_qualifier:nn}
% \begin{macro}[int]{\@@_parse_special:nn}
%   Storage of the various optional items follows broadly the same pattern
%   in each case. The data to be stored is passed along with an appropriate
%   key name to the underlying storage system. The details for each type of
%   item should be relatively clear. For example, prefixes have to come before
%   their \enquote{parent} unit and so there is some adjustment to do to add
%   them to the correct unit.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_prefix:Nn #1#2
  {
    \int_set:Nn \l_@@_tmp_int { \l_@@_position_int + \c_one }
    \@@_parse_add:nnnn { prefix } { \int_use:N \l_@@_tmp_int }
      {#1} {#2}
  }
\cs_new_protected:Npn \@@_parse_power:nnN #1#2#3
  {
    \@@_parse_add:nnnn { power }
      { \int_eval:n { \l_@@_position_int \bool_if:NT #3 { + \c_one } } }
      {#1} {#2}
  }
\cs_new_protected:Npn \@@_parse_qualifier:nn #1#2
  {
    \tl_set:Nx \l_@@_tmp_tl
      { unit- \int_use:N \l_@@_position_int }
    \prop_if_in:NVTF \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \@@_parse_add:nnnn { qualifier }
          { \int_use:N \l_@@_position_int } {#1} {#2}
      }
      { \msg_error:nnn { siunitx / units } { qualifier-before-unit } {#1} }
  }
%    \end{macrocode}
%  Special (exceptional) items should always come before the relevant units.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_special:nn #1#2
  {
    \@@_parse_add:nnnn { special }
      { \int_eval:n { \l_@@_position_int + \c_one } }
      {#1} {#2}
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_unit:Nn}
%   Parsing units is slightly more involved than the other cases: this is the
%   one place where the tracking value is incremented.  If the switch
%   \cs{l_@@_per_bool} is set true then the current unit is also
%   reciprocal: this can only happen if \cs{l_@@_sticky_per_bool} is also
%   true, so only one test is required.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_unit:Nn #1#2
  {
    \int_incr:N \l_@@_position_int
    \@@_parse_add:nnnn { unit } { \int_use:N \l_@@_position_int }
      {#1} {#2}
    \bool_if:NT \l_@@_per_bool
      {
        \@@_parse_add:nnnn { per } { \int_use:N \l_@@_position_int }
          { \per } { true }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_per:}
%   Storing the \cs{per} command requires adding a data item separate from
%   the power which applies: this makes later formatting much more
%   straight-forward. This data could in principle be combined with the
%   \texttt{power}, but depending on the output format required that may make
%   life  more complex. Thus this information is stored separately for later
%   retrieval. If \cs{per} is set to be \enquote{sticky} then after parsing
%   the first occurrence, any further uses are in error.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_per:
  {
    \bool_if:NTF \l_@@_sticky_per_bool
      {
        \bool_set_true:N \l_@@_per_bool
        \cs_set_protected_nopar:Npn \per
          { \msg_error:nn { siunitx / units } { duplicate-sticky-per } }
      }
      {
        \@@_parse_add:nnnn
          { per } { \int_eval:n { \l_@@_position_int + \c_one } }
          { \per } { true }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_finalise:n}
%   If \cs{per} applies to the current unit, the power needs to be multiplied
%   by $-1$. That is done using an \texttt{fp} operation so that non-integer
%   powers are supported. The flag for \cs{per} is also removed as this means
%   we don't have to check that the original power was positive. To be on
%   the safe side, there is a check for a trivial power at this stage.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_finalise:n #1
  {
    \tl_set:Nx \l_@@_tmp_tl { per- #1 }
    \prop_if_in:NVT \l_@@_parsed_prop \l_@@_tmp_tl
      {
        \prop_remove:NV \l_@@_parsed_prop \l_@@_tmp_tl
        \tl_set:Nx \l_@@_tmp_tl { power- #1 }
        \prop_get:NVNTF \l_@@_parsed_prop \l_@@_tmp_tl
          \l_@@_part_tl
          {
            \tl_set:Nx \l_@@_part_tl
              { \fp_eval:n { \l_@@_part_tl * -1 } }
            \fp_compare:nNnTF \l_@@_part_tl = \c_one_fp
              { \prop_remove:NV \l_@@_parsed_prop \l_@@_tmp_tl }
              {
                \prop_put:NVV \l_@@_parsed_prop
                  \l_@@_tmp_tl \l_@@_part_tl
              }
          }
          { \prop_put:NVn \l_@@_parsed_prop \l_@@_tmp_tl { -1 } }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_finalise:}
%   The final task is to check that there is not a \enquote{dangling} prefix:
%   these are added to the \enquote{next} unit so are easy to test for.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_finalise:
  {
    \tl_set:Nx \l_@@_tmp_tl
      { prefix- \int_eval:n { \l_@@_position_int + \c_one } }
    \prop_if_in:NVT \l_@@_parsed_prop \l_@@_tmp_tl
      { \msg_error:nn { siunitx / units } { prefix-only } }
  }
%    \end{macrocode}
% \end{macro}
%
% \subsection{Formatting parsed units}
%
% \begin{variable}[int]^^A
%   {
%     \l_@@_denominator_bracket_bool ,
%     \l_@@_fraction_function_tl     ,
%     \l_@@_bracket_close_tl         ,
%     \l_@@_bracket_open_tl          ,
%     \l_@@_per_symbol_tl            ,
%     \l_@@_qualifier_mode_tl        ,
%     \l_@@_qualifier_phrase_tl
%   }
%   Set up the options which apply to formatting.
%    \begin{macrocode}
\keys_define:nn { siunitx / units }
  {
    bracket-denominator .bool_set:N      = \l_@@_denominator_bracket_bool ,
    fraction-command    .tl_set:N        = \l_@@_fraction_function_tl     ,
    close-bracket       .tl_set:N        = \l_@@_bracket_close_tl         ,
    open-bracket        .tl_set:N        = \l_@@_bracket_open_tl          ,
    per-mode            .choice:                                          ,
    per-mode / fraction             .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_false:N \l_@@_per_symbol_bool
        \bool_set_true:N  \l_@@_powers_positive_bool
        \bool_set_true:N  \l_@@_two_part_bool
      } ,
    per-mode / power                .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_false:N \l_@@_per_symbol_bool
        \bool_set_false:N \l_@@_powers_positive_bool
        \bool_set_false:N \l_@@_two_part_bool
      } ,
    per-mode / power-positive-first .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_false:N \l_@@_per_symbol_bool
        \bool_set_false:N \l_@@_powers_positive_bool
        \bool_set_true:N  \l_@@_two_part_bool
      } ,
    per-mode / repeated-symbol      .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_true:N  \l_@@_per_symbol_bool
        \bool_set_true:N  \l_@@_powers_positive_bool
        \bool_set_false:N \l_@@_two_part_bool
      } ,
    per-mode / symbol               .code:n =
      {
        \bool_set_false:N \l_@@_autofrac_bool
        \bool_set_true:N  \l_@@_per_symbol_bool
        \bool_set_true:N  \l_@@_powers_positive_bool
        \bool_set_true:N  \l_@@_two_part_bool
      } ,
    per-mode / symbol-or-fraction   .code:n =
      {
        \bool_set_true:N \l_@@_autofrac_bool
        \bool_set_true:N \l_@@_per_symbol_bool
        \bool_set_true:N \l_@@_powers_positive_bool
        \bool_set_true:N \l_@@_two_part_bool
      } ,
    per-symbol          .tl_set:N        = \l_@@_per_symbol_tl             ,
    qualifier-mode      .choice:                                           ,
    qualifier-mode / brackets .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { brackets } }  ,
    qualifier-mode / phrase   .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { phrase } }    ,
    qualifier-mode / space .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { space } }     ,
    qualifier-mode / subscript .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { subscript } } ,
    qualifier-mode / text      .code:n =
      { \tl_set:Nn \l_@@_qualifier_mode_tl { text } }      ,
    qualifier-phrase .tl_set:N = \l_@@_qualifier_phrase_tl
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_bracket_bool}
%   A flag to indicate that the unit currently under construction will require
%   brackets if a power is added.
%    \begin{macrocode}
\bool_new:N \l_@@_bracket_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]^^A
%   {
%     \l_@@_autofrac_bool        ,
%     \l_@@_powers_positive_bool ,
%     \l_@@_per_symbol_bool      ,
%     \l_@@_two_part_bool
%   }
%   Dealing with the various ways that reciprocal (\cs{per}) can be handled
%   requires a few different switches.
%    \begin{macrocode}
\bool_new:N \l_@@_autofrac_bool
\bool_new:N \l_@@_per_symbol_bool
\bool_new:N \l_@@_powers_positive_bool
\bool_new:N \l_@@_two_part_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_numerator_bool}
%   Indicates that the current unit should go into the numerator when splitting
%   into two parts (fractions or other \enquote{sorted} styles).
%    \begin{macrocode}
\bool_new:N \l_@@_numerator_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\tl_new:N \l_@@_qualifier_mode_tl}
%   For storing the text of options which are best handled by picking
%   function names.
%    \begin{macrocode}
\tl_new:N \l_@@_qualifier_mode_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_prefix_power_bool}
%   Used to determine if prefixes are converted into powers. Note that
%   while this may be set as an option \enquote{higher up}, at this point it
%   is handled as an internal switch (see the two formatting interfaces for
%   reasons).
%    \begin{macrocode}
\bool_new:N \l_@@_prefix_power_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_prefix_fp}
%   When converting prefixes to powers, the calculations are done as an
%   \texttt{fp}.
%    \begin{macrocode}
\fp_new:N \l_@@_prefix_fp
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_current_tl, \l_@@_part_tl}
%   Building up the (partial) formatted unit requires some token list storage.
%   Each part of the unit combination that is recovered also has to be
%   placed in a token list: this is a dedicated one to leave the scratch
%   variables available.
%    \begin{macrocode}
\tl_new:N \l_@@_current_tl
\tl_new:N \l_@@_part_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_denominator_tl}
%   For fraction-like units, space is needed for the denominator as well as
%   the numerator (which is handled using \cs{l_@@_formatted_tl}).
%    \begin{macrocode}
\tl_new:N \l_@@_denominator_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_total_int}
%   The formatting routine needs to know both the total number of units and
%   the current unit. Thus an \texttt{int} is required in addition to
%   \cs{l_@@_position_int}.
%    \begin{macrocode}
\int_new:N \l_@@_total_int
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\siunitx_units_format:nN}
% \begin{macro}{\siunitx_units_format:nNN}
% \begin{macro}[aux]{\@@_format:nNN}
% \begin{macro}[aux]{\@@_format_aux:}
%   Formatting parsed units can take place either with the prefixes printed or
%   separated out into a power of ten. This variation is handled using two
%   separate functions: as this submodule does not really deal with numbers,
%   formatting the numeral part here would be tricky and it is better therefore
%   to have a mechanism to return a simple numerical power. At the same time,
%   most uses will no want this more complex return format and so a version of
%   the code which does not do this is also provided.
%
%   The main unit formatting routine groups all of the parsing/formatting, so
%   that the only value altered will be the return token list. As definitions
%   for the various unit macros are not globally created, the first step is to
%   map over the list of names and active the unit definitions: these do
%   different things depending on the switches set. There is then a decision to
%   be made: is the unit input one that can be parsed (\enquote{symbolic}), or
%   is is one containing one or more literals. In the latter case, there is a
%   still the need to convert the input into an expanded token list as some
%   parts of the input could still be using unit macros.
%
%   Notice that for \cs{siunitx_units_format:nN} a second return value from the
%   auxiliary has to be allowed for, but is simply discarded.
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_units_format:nN #1#2
  {
    \bool_set_false:N \l_@@_prefix_power_bool
    \@@_format:nNN {#1} #2 \l_@@_tmp_fp
  }
\cs_new_protected:Npn \siunitx_units_format:nNN #1#2#3
  {
    \bool_set_true:N \l_@@_prefix_power_bool
    \@@_format:nNN {#1} #2 #3
  }
\cs_new_protected:Npn \@@_format:nNN #1#2#3
  {
    \group_begin:
      \seq_map_inline:Nn \l_@@_symbolic_seq
        { \cs_set_eq:Nc ##1 { units ~ > ~ \token_to_str:N ##1 } }
      \@@_if_symbolic:nTF {#1}
        {
          \@@_parse:n {#1}
          \@@_format_parsed:
        }
        {
          \fp_zero:N \l_@@_prefix_fp
          \@@_format_literal:n {#1}
        }
      \cs_set_protected_nopar:Npx \@@_format_aux:
        {
          \tl_set:Nn \exp_not:N #2
            { \exp_not:V \l_@@_formatted_tl }
          \fp_set:Nn \exp_not:N #3
            { \fp_use:N \l_@@_prefix_fp }
        }
    \exp_after:wN \group_end:
    \@@_format_aux:
  }
\cs_new_protected_nopar:Npn \@@_format_aux: { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_parsed:}
% \begin{macro}[aux]{\@@_format_parsed_aux:n}
%   The main formatting routine is essentially a loop over each position,
%   reading the various parts of the unit to build up complete unit
%   combination.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_parsed:
  {
    \int_set_eq:NN \l_@@_total_int \l_@@_position_int
    \tl_clear:N \l_@@_denominator_tl
    \tl_clear:N \l_@@_formatted_tl
    \fp_zero:N \l_@@_prefix_fp
    \int_zero:N \l_@@_position_int
    \int_do_while:nNnn \l_@@_position_int < \l_@@_total_int
      {
        \bool_set_false:N \l_@@_bracket_bool
        \tl_clear:N \l_@@_current_tl
        \bool_set_true:N \l_@@_numerator_bool
        \int_incr:N \l_@@_position_int
        \clist_map_inline:nn { prefix , unit , qualifier , power , special }
          { \@@_format_parsed_aux:n {##1} }
        \@@_format_output:
      }
    \@@_format_finalise:
  }
\cs_new_protected:Npn \@@_format_parsed_aux:n #1
  {
    \tl_set:Nx \l_@@_tmp_tl { #1 - \int_use:N \l_@@_position_int }
    \prop_get:NVNT \l_@@_parsed_prop
      \l_@@_tmp_tl \l_@@_part_tl
      { \use:c { @@_format_ #1 : } }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int, EXP]{\@@_format_bracket:N}
%   A quick utility function which wraps up a token list variable in brackets
%   if they are required.
%    \begin{macrocode}
\cs_new:Npn \@@_format_bracket:N #1
  {
    \bool_if:NTF \l_@@_bracket_bool
      {
        \exp_not:V \l_@@_bracket_open_tl
        \exp_not:V #1
        \exp_not:V \l_@@_bracket_close_tl
      }
      { \exp_not:V #1 }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_power:}
% \begin{macro}[aux, EXP]{\@@_format_power_aux:wTF}
% \begin{macro}[aux]^^A
%   {
%     \@@_format_power_positive: ,
%     \@@_format_power_negative:
%   }
% \begin{macro}[aux, EXP]{\@@_format_power_negative_aux:w}
% \begin{macro}[aux]{\@@_format_power_superscript:}
%   Formatting powers requires a test for negative numbers and depending on
%   output format requests some adjustment to the stored value. This could be
%   done using an \texttt{fp} function, but that would be slow compared to
%   a dedicated if lower-level approach based on delimited arguments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_power:
  {
    \exp_after:wN \@@_format_power_aux:wTF \l_@@_part_tl - \q_stop
      { \@@_format_power_negative: }
      { \@@_format_power_positive: }
  }
\cs_new:Npn \@@_format_power_aux:wTF #1 - #2 \q_stop
  { \tl_if_empty:nTF {#1} }
%    \end{macrocode}
%   In the case of positive powers, there is little to do: add the power
%   as a subscript (must be required as the parser ensures it's $\neq 1$).
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_power_positive:
  { \@@_format_power_superscript: }
%    \end{macrocode}
%   Dealing with negative powers starts by flipping the switch used to track
%   where in the final output the current part should get added to. For the
%   case where the output is fraction-like, strip off the |~| then ensure that
%   the result is not the trivial power~$1$. Assuming all is well, addition
%   to the current unit combination goes ahead.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_power_negative:
  {
    \bool_set_false:N \l_@@_numerator_bool
    \bool_if:NTF \l_@@_powers_positive_bool
      {
        \tl_set:Nx \l_@@_part_tl
          {
            \exp_after:wN \@@_format_power_negative_aux:w
              \l_@@_part_tl \q_stop
          }
        \str_if_eq_x:nnF { \exp_not:V \l_@@_part_tl } { 1 }
          { \@@_format_power_superscript: }
      }
      { \@@_format_power_superscript: }
  }
\cs_new:Npn \@@_format_power_negative_aux:w - #1 \q_stop
  { \exp_not:n {#1} }
%    \end{macrocode}
%   Adding the power as a superscript has the slight complication that there
%   is the possibility of needing some brackets. The superscript itself uses
%   \cs{sp} as that avoids any category code issues and also allows redirection
%   at a higher level more readily.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_power_superscript:
  {
    \tl_set:Nx \l_@@_current_tl
      {
        \@@_format_bracket:N \l_@@_current_tl
        \exp_not:N \sp { \exp_not:V \l_@@_part_tl }
      }
    \bool_set_false:N \l_@@_bracket_bool
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_prefix:}
% \begin{macro}[aux]{\@@_format_prefix_power:, \@@_format_prefix_symbol:}
%   Formatting for prefixes depends on whether they are to be expressed as
%   symbols or collected up to be returned as a power of $10$. The latter
%   case requires a bit of processing, which includes checking that the
%   conversion is possible and allowing for any power that applies to the
%   current unit.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_prefix:
  {
    \bool_if:NTF \l_@@_prefix_power_bool
      { \@@_format_prefix_power: }
      { \@@_format_prefix_symbol: }
  }
\cs_new_protected_nopar:Npn \@@_format_prefix_power:
  {
    \prop_get:NVNTF \l_@@_prefixes_forward_prop
      \l_@@_part_tl \l_@@_part_tl
      {
        \tl_set:Nx \l_@@_tmp_tl
          { power- \int_use:N \l_@@_position_int }
        \prop_get:NVNF \l_@@_parsed_prop
          \l_@@_tmp_tl \l_@@_tmp_tl
          { \tl_set:Nn \l_@@_tmp_tl { 1 } }
        \fp_add:Nn \l_@@_prefix_fp
          { \l_@@_tmp_tl * \l_@@_part_tl }
      }
      { \@@_format_prefix_symbol: }
  }
\cs_new_protected_nopar:Npn \@@_format_prefix_symbol:
  { \tl_set_eq:NN \l_@@_current_tl \l_@@_part_tl }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_qualifier:}
% \begin{macro}[aux]^^A
%   {
%     \@@_format_qualifier_brackets:  ,
%     \@@_format_qualifier_phrase:    ,
%     \@@_format_qualifier_space: ,
%     \@@_format_qualifier_subscript: ,
%     \@@_format_qualifier_text:
%   }
%  There are various ways that a qualifier can be added to the output. The
%  idea here is to modify the \enquote{base} text appropriately and then add
%  to the current unit. In the case that a linking phrase is in use, the
%  addition of spaces means that the unit may end up ambiguous, and brackets
%  are therefore required \emph{if} there is a power. Notice that when the
%  qualifier is just treated as \enquote{text}, the auxiliary is actually
%  a no-op.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_qualifier:
  {
    \use:c { @@_format_qualifier_ \l_@@_qualifier_mode_tl : }
    \tl_put_right:NV \l_@@_current_tl \l_@@_part_tl
  }
\cs_new_protected_nopar:Npn \@@_format_qualifier_brackets:
  {
    \tl_set:Nx \l_@@_part_tl
      {
        \exp_not:V \l_@@_bracket_open_tl
        \exp_not:V \l_@@_part_tl
        \exp_not:V \l_@@_bracket_close_tl
      }
  }
\cs_new_protected_nopar:Npn \@@_format_qualifier_phrase:
  {
    \tl_set:Nx \l_@@_part_tl
      {
        \exp_not:V \l_@@_qualifier_phrase_tl
        \exp_not:V \l_@@_part_tl
      }
    \bool_set_true:N \l_@@_bracket_bool
  }
\cs_new_protected_nopar:Npn \@@_format_qualifier_space:
  {
    \tl_put_left:Nn \l_@@_part_tl { \  }
    \bool_set_true:N \l_@@_bracket_bool
  }
\cs_new_protected_nopar:Npn \@@_format_qualifier_subscript:
  {
    \tl_set:Nx \l_@@_part_tl
      { \exp_not:N \sb { \exp_not:V \l_@@_part_tl } }
  }
\cs_new_protected_nopar:Npn \@@_format_qualifier_text: { }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_special:}
%   Any special odds and ends are handled by simply making the current
%   combination into an argument for the recovered code.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_special:
  {
    \tl_set:Nx \l_@@_current_tl
      {
        \exp_not:V \l_@@_part_tl
          { \exp_not:V \l_@@_current_tl }
      }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_unit:}
%   A very simple task: add the unit to the output currently being
%   constructed.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_unit:
  { \tl_put_right:NV \l_@@_current_tl \l_@@_part_tl }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_output:}
% \begin{macro}[aux]^^A
%   {\@@_format_output_aux:, \@@_format_output_denominator:}
% \begin{macro}[aux]^^A
%   {
%     \@@_format_output_aux:nn ,
%     \@@_format_output_aux:nV ,
%     \@@_format_output_aux:nv
%   }
%   The first step here is to make a choice based on whether the current
%   part should be stored as part of the numerator or denominator of a
%   fraction. In all cases, if the switch \cs{l_@@_numerator_bool} is
%   true then life is simple: add the current part to the numerator with
%   a standard separator
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_output:
  {
    \bool_set_false:N \l_@@_bracket_bool
    \use:c
      {
        @@_format_output_
        \bool_if:NTF \l_@@_numerator_bool
          { aux: }
          { denominator: }
      }
  }
\cs_new_protected_nopar:Npn \@@_format_output_aux:
  {
    \@@_format_output_aux:nV { formatted }
      \l_@@_product_tl
  }
%    \end{macrocode}
%   There are a few things to worry about at this stage if the current part
%   is in the denominator.  Powers have already been dealt with and some
%   formatting outcomes only need a branch at the final point of building
%   the entire unit. That means that there are three possible outcomes here:
%   if collecting two separate parts, add to the denominator with a product
%   separator, or if only building one token list there may be a need to use
%   a symbol separator.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_output_denominator:
  {
    \bool_if:NTF \l_@@_two_part_bool
      {
        \bool_if:nT
          {
             ! ( \tl_if_empty_p:N \l_@@_denominator_tl )
             &&
             \l_@@_denominator_bracket_bool
          }
          { \bool_set_true:N \l_@@_bracket_bool }
        \@@_format_output_aux:nV { denominator }
          \l_@@_product_tl
      }
      {
        \@@_format_output_aux:nv { formatted }
          {
            l_@@_
            \bool_if:NTF \l_@@_per_symbol_bool
              { per_symbol }
              { product }
            _tl
          }
      }
  }
\cs_new_protected:Npn \@@_format_output_aux:nn #1#2
  {
    \tl_set:cx { l_@@_ #1 _tl }
      {
         \exp_not:v { l_@@_ #1 _tl }
         \tl_if_empty:cF { l_@@_ #1 _tl }
           { \exp_not:n {#2} }
         \exp_not:V \l_siunitx_units_font_tl
           { \exp_not:V \l_@@_current_tl }
      }
  }
\cs_generate_variant:Nn \@@_format_output_aux:nn { nV , nv }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_format_finalise:}
% \begin{macro}[aux]^^A
%   {
%     \@@_format_finalise_autofrac:   ,
%     \@@_format_finalise_fractional: ,
%     \@@_format_finalise_power:
%   }
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_finalise:
  {
    \tl_if_empty:NF \l_@@_denominator_tl
      {
        \bool_if:NTF \l_@@_powers_positive_bool
          { \@@_format_finalise_fractional: }
          { \@@_format_finalise_power: }
      }
  }
%    \end{macrocode}
%   For fraction-like output, there are three possible choices and two
%   actual styles. To deal with the \enquote{auto-format} case, the two
%   styles (fraction and symbol) are handled in auxiliaries: this allows both
%   to be used at the same time! Beyond that, the key here is to use a
%   single \cs{tl_set:Nx} to keep down the number of assignments.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_finalise_fractional:
  {
    \bool_if:NTF \l_@@_autofrac_bool
      { \@@_format_finalise_autofrac: }
      {
        \bool_if:NTF \l_@@_per_symbol_bool
          { \@@_format_finalise_symbol: }
          { \@@_format_finalise_fraction: }
      }
  }
%    \end{macrocode}
%   For the \enquote{auto-selected} fraction method, the two other auxiliary
%   functions are used to do both forms of formatting. So that everything
%   required is available, this needs one group so that the second auxiliary
%   receives the correct input. After that it is just a case of applying
%   \cs{mathchoice} to the formatted output.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_finalise_autofrac:
  {
    \group_begin:
      \@@_format_finalise_fraction:
    \exp_args:NNNV \group_end:
    \tl_set:Nn \l_@@_tmp_tl \l_@@_formatted_tl
    \@@_format_finalise_symbol:
    \tl_set:Nx \l_@@_formatted_tl
      {
        \mathchoice
          { \exp_not:V \l_@@_tmp_tl }
          { \exp_not:V \l_@@_formatted_tl }
          { \exp_not:V \l_@@_formatted_tl }
          { \exp_not:V \l_@@_formatted_tl }
      }
  }
\cs_new_protected_nopar:Npn \@@_format_finalise_fraction:
  {
    \tl_set:Nx \l_@@_formatted_tl
      {
        \exp_not:V \l_@@_fraction_function_tl
          {
            \tl_if_empty:NTF \l_@@_formatted_tl
              { 1 }
              { \exp_not:V \l_@@_formatted_tl }
          }
          { \exp_not:V \l_@@_denominator_tl }
      }
  }
\cs_new_protected_nopar:Npn \@@_format_finalise_symbol:
  {
    \tl_set:Nx \l_@@_formatted_tl
      {
        \exp_not:V \l_@@_formatted_tl
        \exp_not:V \l_@@_per_symbol_tl
        \@@_format_bracket:N \l_@@_denominator_tl
      }
  }
%    \end{macrocode}
%   In the case of sorted powers, there is a test to make sure there was
%   at least one positive power, and if so a simple join of the two parts
%   with the appropriate product.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_format_finalise_power:
  {
    \tl_if_empty:NTF \l_@@_formatted_tl
      { \tl_set_eq:NN \l_@@_formatted_tl \l_@@_denominator_tl }
      {
        \tl_set:Nx \l_@@_formatted_tl
          {
            \exp_not:V \l_@@_formatted_tl
            \exp_not:V \l_@@_product_tl
            \exp_not:V \l_@@_denominator_tl
          }
      }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
% 
% \subsection{Pre-defined unit components}
% 
% Quite a number of units can be predefined: while this is a code-level module,
% there is little point having a unit parser which does not start off able to
% parse any units!
%
% \begin{macro}^^A
%   {
%     \kilogram ,
%     \metre    ,
%     \meter    ,
%     \mole     ,
%     \kelvin   ,
%     \candela  ,
%     \second   ,
%     \ampere
%   }
%   The basic SI units: technically the correct spelling is \cs{metre} but
%   US users tend to use \cs{meter}.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \kilogram { \kilo \gram }
\siunitx_units_set_unit:Nn \metre    { m }
\siunitx_units_set_unit:Nn \meter    { \metre }
\siunitx_units_set_unit:Nn \mole     { mol }
\siunitx_units_set_unit:Nn \second   { s }
\siunitx_units_set_unit:Nn \ampere   { A }
\siunitx_units_set_unit:Nn \kelvin   { K }
\siunitx_units_set_unit:Nn \candela  { cd }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\gram}
%   The gram is an odd unit as it is needed for the base unit kilogram.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \gram { g }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}^^A
%   {
%     \yocto ,
%     \zepto ,
%     \atto  ,
%     \femto ,
%     \pico  ,
%     \nano  ,
%     \micro ,
%     \milli ,
%     \centi ,
%     \deci
%  }
%   The various SI multiple prefixes are defined here: first the small
%   ones.
%    \begin{macrocode}
\siunitx_units_set_prefix:Nnn \yocto { y } { -24 }
\siunitx_units_set_prefix:Nnn \zepto { z } { -21 }
\siunitx_units_set_prefix:Nnn \atto  { a } { -18 }
\siunitx_units_set_prefix:Nnn \femto { f } { -15 }
\siunitx_units_set_prefix:Nnn \pico  { p } { -12 }
\siunitx_units_set_prefix:Nnn \nano  { n } { -9 }
\siunitx_units_set_prefix:Nnn \micro { \unitsymbol { micro } } { -6 }
\siunitx_units_set_prefix:Nnn \milli { m } { -3 }
\siunitx_units_set_prefix:Nnn \centi { c } { -2 }
\siunitx_units_set_prefix:Nnn \deci  { d } { -1 }
%    \end{macrocode}
% \end{macro}
% \begin{macro}^^A
%   {
%     \deca  ,
%     \deka  ,
%     \hecto ,
%     \kilo  ,
%     \mega  ,
%     \giga  ,
%     \tera  ,
%     \peta  ,
%     \exa   ,
%     \zetta ,
%     \yotta
%   }
%   Now the large ones.
%    \begin{macrocode}
\siunitx_units_set_prefix:Nnn \deca  { da } { 1 }
\siunitx_units_set_prefix:Nnn \deka  { da } { 1 }
\siunitx_units_set_prefix:Nnn \hecto { h }  { 2 }
\siunitx_units_set_prefix:Nnn \kilo  { k }  { 3 }
\siunitx_units_set_prefix:Nnn \mega  { M }  { 6 }
\siunitx_units_set_prefix:Nnn \giga  { G }  { 9 }
\siunitx_units_set_prefix:Nnn \tera  { T }  { 12 }
\siunitx_units_set_prefix:Nnn \peta  { P }  { 15 }
\siunitx_units_set_prefix:Nnn \exa   { E }  { 18 }
\siunitx_units_set_prefix:Nnn \zetta { Z }  { 21 }
\siunitx_units_set_prefix:Nnn \yotta { Y }  { 24 }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}^^A
%   {
%     \becquerel     ,
%     \degreeCelsius ,
%     \coulomb       ,
%     \farad         ,
%     \gray          ,
%     \hertz         ,
%     \henry         ,
%     \joule         ,
%     \katal         ,
%     \lumen         ,
%     \lux
%  }
%    Named derived units: first half of alphabet.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \becquerel     { Bq }
\siunitx_units_set_unit:Nn \degreeCelsius { \degree C }
\siunitx_units_set_unit:Nn \coulomb       { C }
\siunitx_units_set_unit:Nn \farad         { F }
\siunitx_units_set_unit:Nn \gray          { Gy }
\siunitx_units_set_unit:Nn \hertz         { Hz }
\siunitx_units_set_unit:Nn \henry         { H }
\siunitx_units_set_unit:Nn \joule         { J }
\siunitx_units_set_unit:Nn \katal         { kat }
\siunitx_units_set_unit:Nn \lumen         { lm }
\siunitx_units_set_unit:Nn \lux           { lx }
%    \end{macrocode}
% \end{macro}
% \begin{macro}^^A
%   {
%     \newton    ,
%     \ohm       ,
%     \pascal    ,
%     \radian    ,
%     \siemens   ,
%     \sievert   ,
%     \steradian ,
%     \tesla     ,
%     \volt      ,
%     \watt      ,
%     \weber
%  }
%    Named derived units: second half of alphabet.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \newton        { N }
\siunitx_units_set_unit:Nn \ohm           { \unitsymbol { ohm } }
\siunitx_units_set_unit:Nn \pascal        { Pa }
\siunitx_units_set_unit:Nn \radian        { rad }
\siunitx_units_set_unit:Nn \siemens       { S }
\siunitx_units_set_unit:Nn \sievert       { Sv }
\siunitx_units_set_unit:Nn \steradian     { sr }
\siunitx_units_set_unit:Nn \tesla         { T }
\siunitx_units_set_unit:Nn \volt          { V }
\siunitx_units_set_unit:Nn \watt          { W }
\siunitx_units_set_unit:Nn \weber         { Wb }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}^^A
%   {
%     \day       ,
%     \hectare   ,
%     \hour      ,
%     \litre     ,
%     \liter     ,
%     \minute    ,
%     \tonne
%  }
%   Non-SI, but accepted for general use. Once again there are two
%   spellings, here for litre and with different output in this case.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \day     { d }
\siunitx_units_set_unit:Nn \hectare { ha }
\siunitx_units_set_unit:Nn \hour    { h }
\siunitx_units_set_unit:Nn \litre   { L }
\siunitx_units_set_unit:Nn \liter   { \litre }
\siunitx_units_set_unit:Nn \minute  { min }
\siunitx_units_set_unit:Nn \tonne   { t }
%    \end{macrocode}
% \end{macro}
% \begin{macro}^^A
%   {
%     \arcminute ,
%     \arcsecond ,
%     \degree    ,
%  }
%   Arc units: again, non-SI, but accepted for general use.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \arcminute { \unitsymbol { arcminute } }
\siunitx_units_set_unit:Nn \arcsecond { \unitsymbol { arcsecond } }
\siunitx_units_set_unit:Nn \degree    { \unitsymbol { degree } }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\astronomicalunit, \atomicmassunit, \dalton, \electronvolt}
%   A few units based on physical measurements exist: these ones are accepted
%   for use with the International System.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \astronomicalunit { ua }
\siunitx_units_set_unit:Nn \atomicmassunit   { u }
\siunitx_units_set_unit:Nn \dalton           { Da }
\siunitx_units_set_unit:Nn \electronvolt     { eV }
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\nuaction, \numass, \nuspeed, \nutime}
%   Natural units based on physical constants.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \nuaction { \ensuremath { \hbar } }
\siunitx_units_set_unit:Nn \numass
  { \ensuremath { m \sb { \mathrm { e } } } }
\siunitx_units_set_unit:Nn \nuspeed  { \ensuremath { c \sb{ 0 } } }
\siunitx_units_set_unit:Nn \nutime
  { \numass \per \numass \per \nuspeed \squared }
%    \end{macrocode}
% \end{macro}
% \begin{macro}^^A
%   {
%     \auaction ,
%     \aucharge ,
%     \auenergy ,
%     \aulength ,
%     \aumass   ,
%     \autime   ,
%     \bohr     ,
%     \hartree
%   }
%   Atomic units based on physical constants.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \auaction { \ensuremath { \hbar } }
\siunitx_units_set_unit:Nn \aucharge { \ensuremath { e } }
\siunitx_units_set_unit:Nn \auenergy
  { \ensuremath { E \sb { \mathrm { h } } } }
\siunitx_units_set_unit:Nn \aulength { \ensuremath { a \sb { 0 } } }
\siunitx_units_set_unit:Nn \aumass
  { \ensuremath { m \sb { \mathrm { e } } } }
\siunitx_units_set_unit:Nn \autime   { \auaction \per \auenergy }
\siunitx_units_set_unit:Nn \bohr     { \aulength }
\siunitx_units_set_unit:Nn \hartree  { \auenergy }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}^^A
%   {
%     \angstrom          ,
%     \bar               ,
%     \barn              ,
%     \bel               ,
%     \decibel           ,
%     \knot              ,
%     \millimetremercury ,
%     \nauticalmile      ,
%     \neper
%  }
%   There are then some day-to-day units which are accepted for use
%   with SI, but are not part of the official specification.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \angstrom          { \unitsymbol { angstrom }  }
\siunitx_units_set_unit:Nn \bar               { bar }
\siunitx_units_set_unit:Nn \barn              { b }
\siunitx_units_set_unit:Nn \bel               { B }
\siunitx_units_set_unit:Nn \decibel           { \deci \bel }
\siunitx_units_set_unit:Nn \knot              { kn }
\siunitx_units_set_unit:Nn \millimetremercury { mmHg }
\siunitx_units_set_unit:Nn \nauticalmile      { M }
\siunitx_units_set_unit:Nn \neper             { Np }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}^^A
%   {
%     \dyne    ,
%     \erg     ,
%     \gal     ,
%     \gauss   ,
%     \maxwell ,
%     \oersted ,
%     \phot    ,
%     \poise   ,
%     \stilb   ,
%     \stokes
%  }
%   \textsc{cgs} units: similar to the set immediately above, these may be used
%   for specific applications.
%    \begin{macrocode}
\siunitx_units_set_unit:Nn \dyne    { dyn  }
\siunitx_units_set_unit:Nn \erg     { erg }
\siunitx_units_set_unit:Nn \gal     { Gal }
\siunitx_units_set_unit:Nn \gauss   { G }
\siunitx_units_set_unit:Nn \maxwell { Mx }
\siunitx_units_set_unit:Nn \oersted { Oe }
\siunitx_units_set_unit:Nn \phot    { ph }
\siunitx_units_set_unit:Nn \poise   { P }
\siunitx_units_set_unit:Nn \stilb   { sb }
\siunitx_units_set_unit:Nn \stokes  { St }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}{\square, \cubic}
%  Basic powers which come before the unit.
%    \begin{macrocode}
\siunitx_units_set_power:NnN \square { 2 } \c_true_bool
\siunitx_units_set_power:NnN \cubic  { 3 } \c_true_bool
%    \end{macrocode}
% \end{macro}
% \begin{macro}{\squared, \cubed}
%   Basic powers which come after the unit.
%    \begin{macrocode}
\siunitx_units_set_power:NnN \squared { 2 } \c_false_bool
\siunitx_units_set_power:NnN \cubed   { 3 } \c_false_bool
%    \end{macrocode}
% \end{macro}
%
% \subsection{Messages}
%
%    \begin{macrocode}
\msg_new:nnnn { siunitx / units } { duplicate-part }
  { Duplicate~#1~part~'#2'. }
  {
    Each~unit~may~have~only~one~#1:\\
    the~additional~value~'#2'~will~be~ignored.
  }
\msg_new:nnnn { siunitx / units } { duplicate-sticky-per }
  { Duplicate~\token_to_str:N \per. }
  {
    When~the~'sticky-per'~option~is~active,~only~one~
    \token_to_str:N \per \  may~appear~in~a~unit.
  }
\msg_new:nnn { siunitx / units } { prefix-only }
  { Prefix~with~no~unit. }
\msg_new:nnnn { siunitx / units } { qualifier-before-unit }
  { Qualifier~before~unit:~'#1'. }
  {
    Unit~qualifiers~have~to~follow~after~units:~
    they~cannot~appear~before~them.\\ \\
    The~qualifier~'#1'~will~be~ignored.
  }
%    \end{macrocode}
%
% \subsection{Standard settings for module options}
%
% Some of these follow naturally from the point of definition
% (\emph{e.g.}~boolean variables are always |false| to begin with),
% but for clarity everything is set here.
%    \begin{macrocode}
\keys_set:nn { siunitx / units }
  {
    bracket-denominator = true          , % (
    close-bracket       = )             ,
    font-command        = \mathrm       ,
    fraction-command   = \frac         ,
    open-bracket        = (             , % )
    inter-unit-product  = \,            ,
    per-mode            = power         ,
    per-symbol          = /             ,
    qualifier-mode      = subscript     ,
    qualifier-phrase    = \ \mbox{of}\  ,
    sticky-per          = false
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex