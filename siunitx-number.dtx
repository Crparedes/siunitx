% \iffalse meta-comment
%
% File: siunitx-number.dtx Copyright (C) 2014 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    http://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{siunitx.sty}
%
% \title{^^A
%   \pkg{siunitx-number} -- Parsing and formatting numbers^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{siunitx-number} implementation}
%
% Start the DocStrip guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 DocStrip convention): only internal
% material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_number>
%    \end{macrocode}
%
% \subsection{Main formatting routine}
%
% \begin{variable}[int]{\l_@@_formatted_tl}
%   A token list for the final formatted result: may or may not be generated
%   by the parser, depending on settings which are active.
%    \begin{macrocode}
\tl_new:N \l_@@_formatted_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\siunitx_number_format:nN}
% \begin{macro}[aux]{\@@_format:nN}
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_number_format:nN #1#2
  {
    \@@_format:nN {#1} #2
  }
\cs_new_protected:Npn \@@_format:nN #1#2
  {
    \group_begin:
      \@@_parse:n {#1}
    \exp_args:NNNV \group_end:
    \tl_set:Nn #1 \l_@@_formatted_tl
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Parsing numbers}
%
% Before numbers can be manipulated or formatted they need to be parsed into
% an internal form. In particular, if multiple code paths are to be avoided,
% it is necessary to do such parsing even for relatively simple cases such
% as converting |1e10| to |1 \times 10^{10}|.
% 
% Storing the result of such parsing can be done in a number of ways. In the
% first version of \pkg{siunitx} a series of separate data stores were used.
% This is potentially quite fast (as recovery of items relies only on \TeX{}'s
% hash table) but makes managing the various data entries somewhat tedious and
% error-prone. For version two of the package, a single data structure
% (property list) was used for each part of the parsed number. Whilst this is
% easy to manage and extend, it is somewhat slower as at a \TeX{} level there
% are repeated pack--unpack steps. In particular, the fact that there are a
% limited number of items to track for a \enquote{number} means that a more
% efficient approach is desirable (contrast parsing units, which is open-ended
% and therefore fits well with using a property list).
% 
% In this version a hybrid approach is taken to storing the parsed data,
% splitting the number into \enquote{fixed} and \enquote{flexible} parts.
% The \enquote{fixed} part is stored in a form similar to that used by many
% computer systems to represent real numbers.
% \begin{quote}
%   \meta{sign}\meta{integer}.\meta{decimal}(\meta{uncertainty})^^A
%     e\meta{sign}\meta{exponent}
% \end{quote}
% where
% \begin{itemize}
%   \item The \meta{sign} is exactly one token in both cases
%   \item The \meta{integer} should be one or more digits
%   \item The \meta{decimal} may be zero or more digits where no digits
%     at all represents a stored integer
%   \item The \meta{uncertainty} should be one or more digits with |0|
%     representing the fact that no uncertainty was given
%    \item The \meta{exponent} should be one or more digits
% \end{itemize}
% The \enquote{flexible} part is made up of a series of keys stored in a
% property list, with the current possible keys being
% \begin{itemize}
% \end{itemize}
% 
% To allow for complex numbers, two parallel data structures are used, one for
% the real part and one for the imaginary part. If the part is entirely absent
% then the data structures are left empty.
%
% \begin{variable}[int]^^A
%   {
%      \l_@@_input_uncert_close_tl ,
%      \l_@@_input_complex_tl      ,
%      \l_@@_input_comparator_tl   ,
%      \l_@@_input_decimal_tl      ,
%      \l_@@_input_digit_tl        ,
%      \l_@@_input_exponent_tl     ,
%      \l_@@_input_ignore_tl       ,
%      \l_@@_input_uncert_open_tl  ,
%      \l_@@_input_protect_tl      ,
%      \l_@@_input_sign_tl         ,
%      \l_@@_input_symbol_tl       ,
%      \l_@@_input_uncert_sign_tl
%   }
%   Options which determine the various valid parts of a parsed number.
%    \begin{macrocode}
\keys_define:nn { siunitx / number }
 {
    input-close-uncertainty .tl_set:N = \l_@@_input_uncert_close_tl ,
    input-complex-roots     .tl_set:N = \l_@@_input_complex_tl      ,
    input-comparators       .tl_set:N = \l_@@_input_comparator_tl   ,
    input-decimal-markers   .tl_set:N = \l_@@_input_decimal_tl      ,
    input-digits            .tl_set:N = \l_@@_input_digit_tl        ,
    input-exponent-markers  .tl_set:N = \l_@@_input_exponent_tl     ,
    input-ignore            .tl_set:N = \l_@@_input_ignore_tl       ,
    input-open-uncertainty  .tl_set:N = \l_@@_input_uncert_open_tl  ,
    input-signs             .tl_set:N = \l_@@_input_sign_tl         ,
    input-uncertainty-signs .code:n   =
      {
        \tl_set:Nn \l_@@_input_uncert_sign_tl {#1}
        \tl_map_inline:nn {#1}
          {
            \tl_if_in:NnF \l_@@_input_sign_tl {##1}
              { \tl_put_right:Nn \l_@@_input_sign_tl {##1} }
          }
      }
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_arg_tl}
%   The input argument or a part thereof, depending on the position in
%   the parsing routine.
%    \begin{macrocode}
\tl_new:N \l_@@_arg_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_imaginary_prop, \l_@@_real_prop}
% \begin{variable}[int]{\l_@@_imaginary_tl, \l_@@_real_tl}
%   Used to hold the real and imaginary parts of a number in the standardised
%   format.
%    \begin{macrocode}
\prop_new:N \l_@@_imaginary_prop
\prop_new:N \l_@@_real_prop
\tl_new:N \l_@@_imaginary_tl
\tl_new:N \l_@@_real_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{macro}[int]{\@@_parse:n}
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse:n #1
  {
    \prop_clear:N \l_@@_imaginary_prop
    \prop_clear:N \l_@@_real_prop
    \tl_clear:N \l_@@_imaginary_tl
    \tl_clear:N \l_@@_real_tl
    \protected@edef \l_@@_arg_tl {#1}
    \@@_parse_replace:N #1
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_replace:N}
% \begin{macro}[aux]{\@@_parse_replace_aux:NNN}
% \begin{macro}[aux]{\@@_parse_replace_aux:NnN}
% \begin{macro}[aux]{\@@_parse_replace_sign:N}
% \begin{variable}{\c_@@_parse_normalise_tl, \c_@@_parse_sign_replacement_tl}
%   There are three parts to the replacement code. First, any active
%   hyphens signs are normalised: these can come up with some packages and
%   cause issues. There is then a normalisation step to avoid having to worry
%   about the multiple possible tokens in the input for each data part.
%   Finally, multi-token signs are converted to the single token equivalents.
%    \end{macrocode}
\cs_new_protected:Npn \@@_parse_replace:N #1
  {
    \@@_parse_replace_minus:N #1
    \exp_last_unbraced:NNV \@@_parse_replace_aux:NNN #1
      \c_@@_parse_normalise_tl
      ? \q_recursion_tail
        \q_recursion_stop
    \exp_last_unbraced:NNV \@@_parse_replace_aux:NnN #1
      \c_@@_parse_sign_replacement_tl
      { ? } \q_recursion_tail
        \q_recursion_stop
  }
\cs_set_protected:Npn \@@_parse_replace_aux:NNN #1#2#3
  {
    \quark_if_recursion_tail_stop:N #3
    \tl_map_inline:Nn #2
      {
        \tl_replace_all:Nnn #1 {##1} {#3}
      }
    \@@_parse_replace_aux:NNN #1
  }
\tl_const:Npn \c_@@_parse_normalise_tl
  {
    \l_@@_input_decimal_tl      .
    \l_@@_input_uncert_open_tl  (
    \l_@@_input_uncert_close_tl )
    \l_@@_input_exponent_tl     e
    \l_@@_input_complex_tl      i
  }
\cs_set_protected:Npn \@@_parse_replace_aux:NnN #1#2#3
  {
    \quark_if_recursion_tail_stop:N #3
    \tl_replace_all:Nnn #1 {##1} {#3}
    \@@_parse_replace_aux:NnN #1
  }
\tl_const:Npn \c_@@_parse_sign_replacement_tl
  {
    { -+ } \mp
    { +- } \pm
    { << } \ll
    { <= } \le
    { >> } \gg
    { >= } \ge
  }
\group_begin:
\char_set_catcode_active:N \*
\char_set_lccode:nn { `\* } { `\- }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new_protected:Npn \@@_parse_replace_minus:N #1
      {
        \tl_replace_all:Nnn #1 { * }  { - }
      }
  }
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \subsection{Processing numbers}
%
% \subsection{Formatting parsed numbers}
%
% \subsection{Standard settings for module options}
%
% Some of these follow naturally from the point of definition
% (\emph{e.g.}~boolean variables are always |false| to begin with),
% but for clarity everything is set here.
%    \begin{macrocode}
\keys_set:nn { siunitx / number }
  { % (
    input-close-uncertainty = )                                      ,
    input-complex-roots     = ij                                     , 
    input-comparators       = { <=>\approx\ge\geq\gg\le\leq\ll\sim } ,
    input-decimal-markers   = { ., }                                 ,
    input-digits            = 0123456789                             ,
    input-exponent-markers  = dDeE                                   ,
    input-open-uncertainty  = (                                      , % )
    input-signs             = +-\mp\pm                               ,
    input-uncertainty-signs = \pm
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex