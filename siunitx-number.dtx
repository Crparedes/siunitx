% \iffalse meta-comment
%
% File: siunitx-number.dtx Copyright (C) 2014 Joseph Wright
%
% It may be distributed and/or modified under the conditions of the
% LaTeX Project Public License (LPPL), either version 1.3c of this
% license or (at your option) any later version.  The latest version
% of this license is in the file
%
%    http://www.latex-project.org/lppl.txt
%
% This file is part of the "siunitx bundle" (The Work in LPPL)
% and all files in that bundle must be distributed together.
%
% The released version of this bundle is available from CTAN.
%
% -----------------------------------------------------------------------
%
% The development version of the bundle can be found at
%
%    http://github.com/josephwright/siunitx
%
% for those people who are interested.
%
% -----------------------------------------------------------------------
%
%<*driver>
\documentclass{l3doc}
% The next line is needed so that \GetFileInfo will be able to pick up
% version data
\usepackage{siunitx}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \GetFileInfo{siunitx.sty}
%
% \title{^^A
%   \pkg{siunitx-number} -- Parsing and formatting numbers^^A
%   \thanks{This file describes \fileversion,
%     last revised \filedate.}^^A
% }
%
% \author{^^A
%  Joseph Wright^^A
%  \thanks{^^A
%    E-mail:
%    \href{mailto:joseph.wright@morningstar2.co.uk}
%      {joseph.wright@morningstar2.co.uk}^^A
%   }^^A
% }
%
% \date{Released \filedate}
%
% \maketitle
%
% \begin{documentation}
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{siunitx-number} implementation}
%
% Start the DocStrip guards.
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%
% Identify the internal prefix (\LaTeX3 DocStrip convention): only internal
% material in this \emph{submodule} should be used directly.
%    \begin{macrocode}
%<@@=siunitx_number>
%    \end{macrocode}
%
% \begin{variable}[int]{\l_@@_tmp_tl}
%   Scratch space
%    \begin{macrocode}
\tl_new:N \l_@@_tmp_tl
%    \end{macrocode}
% \end{variable}
%
% \subsection{Main formatting routine}
%
% \begin{variable}[int]{\l_@@_formatted_tl}
%   A token list for the final formatted result: may or may not be generated
%   by the parser, depending on settings which are active.
%    \begin{macrocode}
\tl_new:N \l_@@_formatted_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\siunitx_number_format:nN}
% \begin{macro}[aux]{\@@_format:nN}
%    \begin{macrocode}
\cs_new_protected:Npn \siunitx_number_format:nN #1#2
  {
    \@@_format:nN {#1} #2
  }
\cs_new_protected:Npn \@@_format:nN #1#2
  {
    \group_begin:
      \@@_parse:n {#1}
    \exp_args:NNNV \group_end:
    \tl_set:Nn #1 \l_@@_formatted_tl
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Parsing numbers}
%
% Before numbers can be manipulated or formatted they need to be parsed into
% an internal form. In particular, if multiple code paths are to be avoided,
% it is necessary to do such parsing even for relatively simple cases such
% as converting |1e10| to |1 \times 10^{10}|.
% 
% Storing the result of such parsing can be done in a number of ways. In the
% first version of \pkg{siunitx} a series of separate data stores were used.
% This is potentially quite fast (as recovery of items relies only on \TeX{}'s
% hash table) but makes managing the various data entries somewhat tedious and
% error-prone. For version two of the package, a single data structure
% (property list) was used for each part of the parsed number. Whilst this is
% easy to manage and extend, it is somewhat slower as at a \TeX{} level there
% are repeated pack--unpack steps. In particular, the fact that there are a
% limited number of items to track for a \enquote{number} means that a more
% efficient approach is desirable (contrast parsing units, which is open-ended
% and therefore fits well with using a property list).
% 
% In this version a hybrid approach is taken to storing the parsed data,
% splitting the number into \enquote{fixed} and \enquote{flexible} parts.
% The \enquote{fixed} part is stored in a form similar to that used by many
% computer systems to represent real numbers.
% \begin{quote}
%   \meta{sign}\meta{integer}.\meta{decimal}(\meta{uncertainty})^^A
%     e\meta{sign}\meta{exponent}
% \end{quote}
% where
% \begin{itemize}
%   \item The \meta{sign} is exactly one token in both cases
%   \item The \meta{integer} should be one or more digits
%   \item The \meta{decimal} may be zero or more digits where no digits
%     at all represents a stored integer
%   \item The \meta{uncertainty} should be one or more digits with |0|
%     representing the fact that no uncertainty was given
%    \item The \meta{exponent} should be one or more digits
% \end{itemize}
% The \enquote{flexible} part is made up of a series of keys stored in a
% property list, with the current possible keys being
% \begin{itemize}
%   \item \texttt{comparator} Any comparator found (a single token)
% \end{itemize}
% 
% To allow for complex numbers, two parallel data structures are used, one for
% the real part and one for the imaginary part. If the part is entirely absent
% then the data structures are left empty.
%
% \begin{variable}[int]^^A
%   {
%      \l_@@_input_uncert_close_tl ,
%      \l_@@_input_complex_tl      ,
%      \l_@@_input_comparator_tl   ,
%      \l_@@_input_decimal_tl      ,
%      \l_@@_input_digit_tl        ,
%      \l_@@_input_exponent_tl     ,
%      \l_@@_input_ignore_tl       ,
%      \l_@@_input_uncert_open_tl  ,
%      \l_@@_input_protect_tl      ,
%      \l_@@_input_sign_tl         ,
%      \l_@@_input_symbol_tl       ,
%      \l_@@_input_uncert_sign_tl
%   }
%   Options which determine the various valid parts of a parsed number.
%    \begin{macrocode}
\keys_define:nn { siunitx / number }
 {
    input-close-uncertainty .tl_set:N = \l_@@_input_uncert_close_tl ,
    input-complex-roots     .tl_set:N = \l_@@_input_complex_tl      ,
    input-comparators       .tl_set:N = \l_@@_input_comparator_tl   ,
    input-decimal-markers   .tl_set:N = \l_@@_input_decimal_tl      ,
    input-digits            .tl_set:N = \l_@@_input_digit_tl        ,
    input-exponent-markers  .tl_set:N = \l_@@_input_exponent_tl     ,
    input-ignore            .tl_set:N = \l_@@_input_ignore_tl       ,
    input-open-uncertainty  .tl_set:N = \l_@@_input_uncert_open_tl  ,
    input-signs             .tl_set:N = \l_@@_input_sign_tl         ,
    input-uncertainty-signs .code:n   =
      {
        \tl_set:Nn \l_@@_input_uncert_sign_tl {#1}
        \tl_map_inline:nn {#1}
          {
            \tl_if_in:NnF \l_@@_input_sign_tl {##1}
              { \tl_put_right:Nn \l_@@_input_sign_tl {##1} }
          }
      }
  }
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_arg_tl}
%   The input argument or a part thereof, depending on the position in
%   the parsing routine.
%    \begin{macrocode}
\tl_new:N \l_@@_arg_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_exponent_tl}
%   The exponent part of a parsed number. It is easiest to find this
%   relatively early in the parsing process, but as it needs to go at
%   the end of the internal format is held separately until required.
%    \begin{macrocode}
\tl_new:N \l_@@_exponent_tl
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}[int]{\l_@@_imaginary_prop, \l_@@_real_prop}
% \begin{variable}[int]{\l_@@_imaginary_tl, \l_@@_real_tl}
%   Used to hold the real and imaginary parts of a number in the standardised
%   format.
%    \begin{macrocode}
\prop_new:N \l_@@_imaginary_prop
\prop_new:N \l_@@_real_prop
\tl_new:N \l_@@_imaginary_tl
\tl_new:N \l_@@_real_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
%
% \begin{macro}[int]{\@@_parse:n}
%   After some initial set up, the parser expands the input and then replaces
%   as far as possible tricky tokens with ones that can be handled using
%   delimited arguments. The parser begins with the assumption that the input
%   is a real number. To avoid multiple conditionals here, the parser is
%   set up as a chain of commands initially, with a loop only later. This
%   avoids more conditionals than are necessary.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse:n #1
  {
    \prop_clear:N \l_@@_real_prop
    \tl_clear:N \l_@@_real_tl
    \protected@edef \l_@@_arg_tl {#1}
    \@@_parse_replace:
    \tl_if_blank:nF {#1}
      { \@@_parse_comparator: }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_comparator:}
% \begin{macro}[aux]{\@@_parse_comparator_aux:Nw}
%   A comparator has to be the very first token in the input. A such, the
%   test for this can be very fast: grab the first token, do a check and
%   if appropriate store the result.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_comparator:
  {
    \exp_after:wN \@@_parse_comparator_aux:Nw \l_@@_arg_tl \q_stop
  }
\cs_new_protected:Npn \@@_parse_comparator_aux:Nw #1#2 \q_stop
  {
    \tl_if_in:NnT \l_@@_input_comparator_tl {#1}
      {
        \prop_put:Nnn \l_@@_real_prop { comparator } {#1}
        \tl_set:Nn \l_@@_arg_tl {#2}
      }
    \tl_if_blank:NF \l_@@_arg_tl
      { \@@_parse_sign: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_digit_check:nT}
%   A test that the argument given is made up only of tokens from the current
%   list of digits. If it is, the break statement will never be inserted and
%   the \cs{use:n} will remove the braces from the |T| argument. However, if
%   there is an issue the break will occur and \cs{use_none:nn} will remove
%   both \cs{use:n} and the |T| argument.
%    \begin{macrocode}
\cs_new_protected:Npn \@@_parse_digit_check:nT #1
  {
    \tl_map_inline:nn {#1}
      {
        \tl_if_in:VF \l_@@_input_digit_tl
          { \tl_map_break:nn { \use_none:nn } }
      }
    \use:n
  }
%    \end{macrocode}
% \end{macro}
% 
% \begin{macro}[int]{\@@_parse_exponent:}
% \begin{macro}[aux]{\@@_parse_exponent_aux:w}
% \begin{macro}[aux]{\@@_parse_exponent_aux:nn}
% \begin{macro}[aux]{\@@_parse_exponent_aux:Nw}
% \begin{macro}[aux]{\@@_parse_exponent_aux:Nn}
% \begin{macro}[aux, EXP]{\@@_parse_exponent_zero_test:N}
% \begin{macro}[aux, EXP]{\@@_parse_exponent_tidy:N}
%   An exponent part of a number has to come at the end and can only occur
%   once. Thus it is relatively easy to parse. First, there is a check that
%   an exponent part is allowed, and if so a split is made (the previous
%   part of the chain checks that there is some content in \cs{l_@@_arg_tl}
%   before calling this function). After splitting, if there is no exponent
%   then simply save a default. Otherwise, check for a sign and then store
%   either this or an assumed |+| and the digits after a check that nothing
%   else is present after the~|e|. The only slight complication to all of
%   this is allowing an arbitrary token in the input to represent the exponent:
%   this is done by setting any exponent tokens to the first of the allowed
%   list, then using that in a delimited argument set up. Once an exponent
%   part is found, there is a loop to check that each of the tokens is a digit
%   then a tidy up step to remove any leading zeros.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_exponent:
  {
    \tl_if_blank:NTF \l_@@_input_exponent_tl
      { \tl_set:Nn \l_@@_exponent_tl { e+0 } }
      {
        \tl_set:Nx \l_@@_tmp_tl { \tl_head:V \l_@@_input_exponent_tl }
        \tl_map_inline:Vn \l_@@_input_exponent_tl
          { \tl_replace_all:NnV \l_@@_arg_tl {##1} \l_@@_tmp_tl }
        \use:x
          {
            \cs_set_protected:Npn \exp_not:N \@@_parse_exponent_aux:w
              ####1 \exp_not:V \l_@@_tmp_tl
              ####2 \exp_not:V \l_@@_tmp_tl
              ####3 \exp_not:N \q_stop
          }
            { \@@_parse_exponent_aux:nn {##1} {##2} }
        \use:x
          {
            \@@_parse_exponent_aux:w \exp_not:V \l_@@_arg_tl
              \exp_not:V \l_@@_tmp_tl \exp_not:N \q_nil
              \exp_not:V \l_@@_tmp_tl \exp_not:N \q_stop
          }
      }
  }
\cs_new_protected:Npn \@@_parse_exponent_aux:w  { }
\cs_new_protected:Npn \@@_parse_exponent_aux:nn #1#2
  {
    \quark_if_nil:nTF {#2}
      { \tl_set:Nn \l_@@_exponent_tl { e+0 } }
      {
        \tl_set:Nn \l_@@_arg_tl {#1}
        \tl_if_blank:nTF {#2}
          { \tl_clear:N \l_@@_real_tl }
          { \@@_parse_exponent_aux:Nw #2 \q_stop }
      }
    \tl_if_empty:NF \l_@@_real_tl
      {  }
  }
\cs_new_protected:Npn \@@_parse_exponent_aux:Nw #1#2 \q_stop
  {
    \tl_if_in:VNTF \l_@@_input_sign_tl #1
      { \@@_parse_exponent_aux:Nn #1 {#2} }
      { \@@_parse_exponent_aux:Nn + {#1#2} }
    \tl_if_empty:NT \l_@@_exponent_tl
      { \tl_clear:N \l_@@_real_tl }
  }
\cs_new_protected:Npn \@@_parse_exponent_aux:Nn #1#2
  {
    \@@_parse_digit_check:nT {#2}
      {
        \tl_set:Nn \l_@@_exponent_tl
          {
            e #1
            \@@_parse_exponent_zero_test:N #2
              \q_recursion_tail \q_recursion_stop
          }
      }
  }
\cs_new:Npn \@@_parse_exponent_zero_test:N #1
  {
    \quark_if_recursion_tail_stop_do:Nn #1 { 0 }
    \str_if_eq:nnTF {#1} { 0 }
      { \@@_parse_exponent_zero_test:N }
      { \@@_parse_exponent_tidy:wNN }
  }
\cs_new:Npn \@@_parse_exponent_tidy:wNN
  #1 \q_recursion_tail \q_recursion_stop {#1}
%    \end{macrocode}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_replace:}
% \begin{macro}[aux]{\@@_parse_replace_aux:nN}
% \begin{macro}[aux]{\@@_parse_replace_sign:}
% \begin{variable}{\c_@@_parse_sign_replacement_tl}
%   There are two parts to the replacement code. First, any active
%   hyphens signs are normalised: these can come up with some packages and
%   cause issues. Multi-token signs then are converted to the single token
%   equivalents so that everything else can work on a one token basis.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_replace:
  {
    \@@_parse_replace_minus:
    \exp_last_unbraced:NNV \@@_parse_replace_aux:nN
      \c_@@_parse_sign_replacement_tl
      { ? } \q_recursion_tail
        \q_recursion_stop
  }
\cs_set_protected:Npn \@@_parse_replace_aux:nN #1#2
  {
    \quark_if_recursion_tail_stop:N #2
    \tl_replace_all:Nnn \l_@@_arg_tl {#1} {#2}
    \@@_parse_replace_aux:nN
  }
\tl_const:Nn \c_@@_parse_sign_replacement_tl
  {
    { -+ } \mp
    { +- } \pm
    { << } \ll
    { <= } \le
    { >> } \gg
    { >= } \ge
  }
\group_begin:
\char_set_catcode_active:N \*
\char_set_lccode:nn { `\* } { `\- }
\tl_to_lowercase:n
  {
    \group_end:
    \cs_new_protected_nopar:Npn \@@_parse_replace_minus:
      {
        \tl_replace_all:Nnn \l_@@_arg_tl { * }  { - }
      }
  }
%    \end{macrocode}
% \end{variable}
% \end{macro}
% \end{macro}
% \end{macro}
% \end{macro}
%
% \begin{macro}[int]{\@@_parse_sign:}
% \begin{macro}[aux]{\@@_parse_sign_aux:Nw}
%  The first token of a number after a comparator could be a sign. A quick
%  check is made and if found stored; if there is no sign then the internal
%  format requires that |+| is used. For the number to be valid it has to be
%  more than just a sign, so the next part of the chain is only called if that
%  is the case.
%    \begin{macrocode}
\cs_new_protected_nopar:Npn \@@_parse_sign:
  { \exp_after:wN \@@_parse_sign_aux:Nw \l_@@_arg_tl \q_stop }
\cs_new_protected:Npn \@@_parse_sign_aux:Nw #1#2 \q_stop
  {
    \tl_if_in:nNTF {#1} \l_@@_sign_tl
      {
        \tl_set:Nn \l_@@_arg_tl {#2}
        \tl_set:Nn \l_@@_real_tl {#1}
      }
      { \tl_set:Nn \l_@@_real_tl { + } }
    \tl_if_empty:NTF \l_@@_arg_tl
      { \tl_clear:N \l_@@_real_tl }
      { \@@_parse_exponent: }
  }
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsection{Processing numbers}
%
% \subsection{Formatting parsed numbers}
%
% \subsection{Standard settings for module options}
%
% Some of these follow naturally from the point of definition
% (\emph{e.g.}~boolean variables are always |false| to begin with),
% but for clarity everything is set here.
%    \begin{macrocode}
\keys_set:nn { siunitx / number }
  { % (
    input-close-uncertainty = )                                      ,
    input-complex-roots     = ij                                     , 
    input-comparators       = { <=>\approx\ge\geq\gg\le\leq\ll\sim } ,
    input-decimal-markers   = { ., }                                 ,
    input-digits            = 0123456789                             ,
    input-exponent-markers  = dDeE                                   ,
    input-ignore            = \,                                     ,
    input-open-uncertainty  = (                                      , % )
    input-signs             = +-\mp\pm                               ,
    input-uncertainty-signs = \pm
  }
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex